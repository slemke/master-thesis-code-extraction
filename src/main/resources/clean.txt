private static Class < ? extends Date > verifyDateType ( Class < ? extends Date > dateType ) { if ( dateType != Date.class && dateType != java.sql.Date.class && dateType != Timestamp.class ) { throw new IllegalArgumentException ( " Date type must be one of " + Date.class + " , " + Timestamp.class + " , or " + java.sql.Date.class + " but was " + dateType ) ; } return dateType ; } 
public void write ( JsonWriter out , Date value ) throws IOException { if ( value == null ) { out.nullValue ( ) ; return ; } synchronized ( dateFormats ) { String dateFormatAsString = dateFormats.get ( 0 ) .format ( value ) ; out.value ( dateFormatAsString ) ; } } 
public Class < ? > getDeclaringClass ( ) { return field.getDeclaringClass ( ) ; }
public String getName ( ) { return field.getName ( ) ; } 
public Type getDeclaredType ( ) { return field.getGenericType ( ) ; } 
public Class < ? > getDeclaredClass ( ) { return field.getType ( ) ; } 
public < T extends Annotation > T getAnnotation ( Class < T > annotation ) { return field.getAnnotation ( annotation ) ; } 
public Collection < Annotation > getAnnotations ( ) { return Arrays.asList ( field.getAnnotations ( ) ) ; } 
public boolean hasModifier ( int modifier ) { return ( field.getModifiers ( ) & modifier ) != 0 ; } 
Object get ( Object instance ) throws IllegalAccessException { return field.get ( instance ) ; } 
boolean isSynthetic ( ) { return field.isSynthetic ( ) ; } 
static String separateCamelCase ( String name , String separator ) { StringBuilder translation = new StringBuilder ( ) ; for ( int i = 0 , length = name.length ( ) ; i < length ; i++ ) { char character = name.charAt ( i ) ; if ( Character.isUpperCase ( character ) && translation.length ( ) != 0 ) { translation.append ( separator ) ; } translation.append ( character ) ; } return translation.toString ( ) ; } 
private static String modifyString ( char firstCharacter , String srcString , int indexOfSubstring ) { return ( indexOfSubstring < srcString.length ( ) ) ? firstCharacter + srcString.substring ( indexOfSubstring ) : String.valueOf ( firstCharacter ) ; } 
public String translateName ( Field f ) { return f.getName ( ) ; } 
public String translateName ( Field f ) { return upperCaseFirstLetter ( f.getName ( ) ) ; } 
public String translateName ( Field f ) { return upperCaseFirstLetter ( separateCamelCase ( f.getName ( ) , " " ) ) ; } 
public String translateName ( Field f ) { return separateCamelCase ( f.getName ( ) , " _ " ) .toLowerCase ( Locale.ENGLISH ) ; } 
public String translateName ( Field f ) { return separateCamelCase ( f.getName ( ) , " - " ) .toLowerCase ( Locale.ENGLISH ) ; } 
public String translateName ( Field f ) { return separateCamelCase ( f.getName ( ) , " . " ) .toLowerCase ( Locale.ENGLISH ) ; } 
public GsonBuilder newBuilder ( ) { return new GsonBuilder ( this ) ; } 
public Excluder excluder ( ) { return excluder ; } 
public FieldNamingStrategy fieldNamingStrategy ( ) { return fieldNamingStrategy ; } 
public boolean serializeNulls ( ) { return serializeNulls ; } 
public boolean htmlSafe ( ) { return htmlSafe ; } 
public void write ( JsonWriter out , Number value ) throws IOException { if ( value == null ) { out.nullValue ( ) ; return ; } double doubleValue = value.doubleValue ( ) ; checkValidFloatingPoint ( doubleValue ) ; out.value ( value ) ; }
public void write ( JsonWriter out , Number value ) throws IOException { if ( value == null ) { out.nullValue ( ) ; return ; } float floatValue = value.floatValue ( ) ; checkValidFloatingPoint ( floatValue ) ; out.value ( value ) ; }
static void checkValidFloatingPoint ( double value ) { if ( Double.isNaN ( value ) || Double.isInfinite ( value ) ) { throw new IllegalArgumentException ( value + " is not a valid double value as per JSON specification. To override this " + " behavior , use GsonBuilder.serializeSpecialFloatingPointValues ( ) method. " ) ; } } 
public void write ( JsonWriter out , Number value ) throws IOException { if ( value == null ) { out.nullValue ( ) ; return ; } out.value ( value.toString ( ) ) ; }
public void write ( JsonWriter out , AtomicLong value ) throws IOException { longAdapter.write ( out , value.get ( ) ) ; } 
public AtomicLong read ( JsonReader in ) throws IOException { Number value = longAdapter.read ( in ) ; return new AtomicLong ( value.longValue ( ) ) ; } 
public void write ( JsonWriter out , AtomicLongArray value ) throws IOException { out.beginArray ( ) ; for ( int i = 0 , length = value.length ( ) ; i < length ; i++ ) { longAdapter.write ( out , value.get ( i ) ) ; } out.endArray ( ) ; } 
public AtomicLongArray read ( JsonReader in ) throws IOException { List < Long > list = new ArrayList < Long > ( ) ; in.beginArray ( ) ; while ( in.hasNext ( ) ) { long value = longAdapter.read ( in ) .longValue ( ) ; list.add ( value ) ; } in.endArray ( ) ; int length = list.size ( ) ; AtomicLongArray array = new AtomicLongArray ( length ) ; for ( int i = 0 ; i < length ; ++i ) { array.set ( i , list.get ( i ) ) ; } return array ; } 
public < T > TypeAdapter < T > getAdapter ( Class < T > type ) { return getAdapter ( TypeToken.get ( type ) ) ; } 
public JsonElement toJsonTree ( Object src ) { if ( src == null ) { return JsonNull.INSTANCE ; } return toJsonTree ( src , src.getClass ( ) ) ; } 
public JsonElement toJsonTree ( Object src , Type typeOfSrc ) { JsonTreeWriter writer = new JsonTreeWriter ( ) ; toJson ( src , typeOfSrc , writer ) ; return writer.get ( ) ; } 
public String toJson ( Object src ) { if ( src == null ) { return toJson ( JsonNull.INSTANCE ) ; } return toJson ( src , src.getClass ( ) ) ; } 
public String toJson ( Object src , Type typeOfSrc ) { StringWriter writer = new StringWriter ( ) ; toJson ( src , typeOfSrc , writer ) ; return writer.toString ( ) ; } 
public void toJson ( Object src , Appendable writer ) throws JsonIOException { if ( src != null ) { toJson ( src , src.getClass ( ) , writer ) ; } else { toJson ( JsonNull.INSTANCE , writer ) ; } } 
public void toJson ( Object src , Type typeOfSrc , Appendable writer ) throws JsonIOException { try { JsonWriter jsonWriter = newJsonWriter ( Streams.writerForAppendable ( writer ) ) ; toJson ( src , typeOfSrc , jsonWriter ) ; } catch ( IOException e ) { throw new JsonIOException ( e ) ; } } 
public String toJson ( JsonElement jsonElement ) { StringWriter writer = new StringWriter ( ) ; toJson ( jsonElement , writer ) ; return writer.toString ( ) ; } 
public void toJson ( JsonElement jsonElement , Appendable writer ) throws JsonIOException { try { JsonWriter jsonWriter = newJsonWriter ( Streams.writerForAppendable ( writer ) ) ; toJson ( jsonElement , jsonWriter ) ; } catch ( IOException e ) { throw new JsonIOException ( e ) ; } } 
public JsonWriter newJsonWriter ( Writer writer ) throws IOException { if ( generateNonExecutableJson ) { writer.write ( JSON_NON_EXECUTABLE_PREFIX ) ; } JsonWriter jsonWriter = new JsonWriter ( writer ) ; if ( prettyPrinting ) { jsonWriter.setIndent ( " " ) ; } jsonWriter.setSerializeNulls ( serializeNulls ) ; return jsonWriter ; } 
public JsonReader newJsonReader ( Reader reader ) { JsonReader jsonReader = new JsonReader ( reader ) ; jsonReader.setLenient ( lenient ) ; return jsonReader ; } 
public < T > T fromJson ( String json , Class < T > classOfT ) throws JsonSyntaxException { Object object = fromJson ( json , ( Type ) classOfT ) ; return Primitives.wrap ( classOfT ) .cast ( object ) ; } 
public < T > T fromJson ( Reader json , Class < T > classOfT ) throws JsonSyntaxException , JsonIOException { JsonReader jsonReader = newJsonReader ( json ) ; Object object = fromJson ( jsonReader , classOfT ) ; assertFullConsumption ( object , jsonReader ) ; return Primitives.wrap ( classOfT ) .cast ( object ) ; }
public < T > T fromJson ( Reader json , Type typeOfT ) throws JsonIOException , JsonSyntaxException { JsonReader jsonReader = newJsonReader ( json ) ; T object = ( T ) fromJson ( jsonReader , typeOfT ) ; assertFullConsumption ( object , jsonReader ) ; return object ; } 
private static void assertFullConsumption ( Object obj , JsonReader reader ) { try { if ( obj != null && reader.peek ( ) != JsonToken.END_DOCUMENT ) { throw new JsonIOException ( " JSON document was not fully consumed. " ) ; } } catch ( MalformedJsonException e ) { throw new JsonSyntaxException ( e ) ; } catch ( IOException e ) { throw new JsonIOException ( e ) ; } } 
public < T > T fromJson ( JsonElement json , Class < T > classOfT ) throws JsonSyntaxException { Object object = fromJson ( json , ( Type ) classOfT ) ; return Primitives.wrap ( classOfT ) .cast ( object ) ; } 
public void setDelegate ( TypeAdapter < T > typeAdapter ) { if ( delegate != null ) { throw new AssertionError ( ) ; } delegate = typeAdapter ; }
public T read ( JsonReader in ) throws IOException { if ( delegate == null ) { throw new IllegalStateException ( ) ; } return delegate.read ( in ) ; } 
public void write ( JsonWriter out , T value ) throws IOException { if ( delegate == null ) { throw new IllegalStateException ( ) ; } delegate.write ( out , value ) ; } 
public GsonBuilder setVersion ( double ignoreVersionsAfter ) { excluder = excluder.withVersion ( ignoreVersionsAfter ) ; return this ; } 
public GsonBuilder excludeFieldsWithModifiers ( int... modifiers ) { excluder = excluder.withModifiers ( modifiers ) ; return this ; } 
public GsonBuilder generateNonExecutableJson ( ) { this.generateNonExecutableJson = true ; return this ; } 
public GsonBuilder excludeFieldsWithoutExposeAnnotation ( ) { excluder = excluder.excludeFieldsWithoutExposeAnnotation ( ) ; return this ; } 
public GsonBuilder serializeNulls ( ) { this.serializeNulls = true ; return this ; } 
public GsonBuilder enableComplexMapKeySerialization ( ) { complexMapKeySerialization = true ; return this ; } 
public GsonBuilder disableInnerClassSerialization ( ) { excluder = excluder.disableInnerClassSerialization ( ) ; return this ; } 
public GsonBuilder setLongSerializationPolicy ( LongSerializationPolicy serializationPolicy ) { this.longSerializationPolicy = serializationPolicy ; return this ; } 
public GsonBuilder setFieldNamingPolicy ( FieldNamingPolicy namingConvention ) { this.fieldNamingPolicy = namingConvention ; return this ; } 
public GsonBuilder setFieldNamingStrategy ( FieldNamingStrategy fieldNamingStrategy ) { this.fieldNamingPolicy = fieldNamingStrategy ; return this ; } 
public GsonBuilder setExclusionStrategies ( ExclusionStrategy... strategies ) { for ( ExclusionStrategy strategy : strategies ) { excluder = excluder.withExclusionStrategy ( strategy , true , true ) ; } return this ; } 
public GsonBuilder addSerializationExclusionStrategy ( ExclusionStrategy strategy ) { excluder = excluder.withExclusionStrategy ( strategy , true , false ) ; return this ; } 
public GsonBuilder addDeserializationExclusionStrategy ( ExclusionStrategy strategy ) { excluder = excluder.withExclusionStrategy ( strategy , false , true ) ; return this ; } 
public GsonBuilder setPrettyPrinting ( ) { prettyPrinting = true ; return this ; } 
public GsonBuilder setLenient ( ) { lenient = true ; return this ; } 
public GsonBuilder disableHtmlEscaping ( ) { this.escapeHtmlChars = false ; return this ; } 
public GsonBuilder setDateFormat ( String pattern ) { this.datePattern = pattern ; return this ; } 
public GsonBuilder setDateFormat ( int style ) { this.dateStyle = style ; this.datePattern = null ; return this ; } 
public GsonBuilder setDateFormat ( int dateStyle , int timeStyle ) { this.dateStyle = dateStyle ; this.timeStyle = timeStyle ; this.datePattern = null ; return this ; } 
public GsonBuilder registerTypeAdapterFactory ( TypeAdapterFactory factory ) { factories.add ( factory ) ; return this ; } 
public GsonBuilder serializeSpecialFloatingPointValues ( ) { this.serializeSpecialFloatingPointValues = true ; return this ; } 
public Gson create ( ) { List < TypeAdapterFactory > factories = new ArrayList < TypeAdapterFactory > ( this.factories.size ( ) + this.hierarchyFactories.size ( ) + 3 ) ; factories.addAll ( this.factories ) ; Collections.reverse ( factories ) ; List < TypeAdapterFactory > hierarchyFactories = new ArrayList < TypeAdapterFactory > ( this.hierarchyFactories ) ; Collections.reverse ( hierarchyFactories ) ; factories.addAll ( hierarchyFactories ) ; addTypeAdaptersForDate ( datePattern , dateStyle , timeStyle , factories ) ; return new Gson ( excluder , fieldNamingPolicy , instanceCreators , serializeNulls , complexMapKeySerialization , generateNonExecutableJson , escapeHtmlChars , prettyPrinting , lenient , serializeSpecialFloatingPointValues , longSerializationPolicy , datePattern , dateStyle , timeStyle , this.factories , this.hierarchyFactories , factories ) ; } 
public static < T > T checkNotNull ( T obj ) { if ( obj == null ) { throw new NullPointerException ( ) ; } return obj ; } 
public static void checkArgument ( boolean condition ) { if ( !condition ) { throw new IllegalArgumentException ( ) ; } } 
public static ParameterizedType newParameterizedTypeWithOwner ( Type ownerType , Type rawType , Type... typeArguments ) { return new ParameterizedTypeImpl ( ownerType , rawType , typeArguments ) ; } 
public static GenericArrayType arrayOf ( Type componentType ) { return new GenericArrayTypeImpl ( componentType ) ; } 
public static WildcardType subtypeOf ( Type bound ) { Type[] upperBounds ; if ( bound instanceof WildcardType ) { upperBounds = ( ( WildcardType ) bound ) .getUpperBounds ( ) ; } else { upperBounds = new Type[] { bound } ; } return new WildcardTypeImpl ( upperBounds , EMPTY_TYPE_ARRAY ) ; } 
public static WildcardType supertypeOf ( Type bound ) { Type[] lowerBounds ; if ( bound instanceof WildcardType ) { lowerBounds = ( ( WildcardType ) bound ) .getLowerBounds ( ) ; } else { lowerBounds = new Type[] { bound } ; } return new WildcardTypeImpl ( new Type[] { Object.class } , lowerBounds ) ; } 
static int hashCodeOrZero ( Object o ) { return o != null ? o.hashCode ( ) : 0 ; } 
public static String typeToString ( Type type ) { return type instanceof Class ? ( ( Class < ? > ) type ) .getName ( ) : type.toString ( ) ; } 
static Type getSupertype ( Type context , Class < ? > contextRawType , Class < ? > supertype ) { if ( context instanceof WildcardType ) { context = ( ( WildcardType ) context ) .getUpperBounds ( ) [0] ; } checkArgument ( supertype.isAssignableFrom ( contextRawType ) ) ; return resolve ( context , contextRawType , $Gson$Types.getGenericSupertype ( context , contextRawType , supertype ) ) ; } 
public static Type getArrayComponentType ( Type array ) { return array instanceof GenericArrayType ? ( ( GenericArrayType ) array ) .getGenericComponentType ( ) : ( ( Class < ? > ) array ) .getComponentType ( ) ; } 
public static Type getCollectionElementType ( Type context , Class < ? > contextRawType ) { Type collectionType = getSupertype ( context , contextRawType , Collection.class ) ; if ( collectionType instanceof WildcardType ) { collectionType = ( ( WildcardType ) collectionType ) .getUpperBounds ( ) [0] ; } if ( collectionType instanceof ParameterizedType ) { return ( ( ParameterizedType ) collectionType ) .getActualTypeArguments ( ) [0] ; } return Object.class ; } 
public static Type[] getMapKeyAndValueTypes ( Type context , Class < ? > contextRawType ) { if ( context == Properties.class ) { return new Type[] { String.class , String.class } ; } Type mapType = getSupertype ( context , contextRawType , Map.class ) ; if ( mapType instanceof ParameterizedType ) { ParameterizedType mapParameterizedType = ( ParameterizedType ) mapType ; return mapParameterizedType.getActualTypeArguments ( ) ; } return new Type[] { Object.class , Object.class } ; } 
public static Type resolve ( Type context , Class < ? > contextRawType , Type toResolve ) { return resolve ( context , contextRawType , toResolve , new HashSet < TypeVariable > ( ) ) ; } 
static Type resolveTypeVariable ( Type context , Class < ? > contextRawType , TypeVariable < ? > unknown ) { Class < ? > declaredByRaw = declaringClassOf ( unknown ) ; if ( declaredByRaw == null ) { return unknown ; } Type declaredBy = getGenericSupertype ( context , contextRawType , declaredByRaw ) ; if ( declaredBy instanceof ParameterizedType ) { int index = indexOf ( declaredByRaw.getTypeParameters ( ) , unknown ) ; return ( ( ParameterizedType ) declaredBy ) .getActualTypeArguments ( ) [index] ; } return unknown ; } 
private static int indexOf ( Object[] array , Object toFind ) { for ( int i = 0 , length = array.length ; i < length ; i++ ) { if ( toFind.equals ( array[i] ) ) { return i ; } } throw new NoSuchElementException ( ) ; } 
private static Class < ? > declaringClassOf ( TypeVariable < ? > typeVariable ) { GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration ( ) ; return genericDeclaration instanceof Class ? ( Class < ? > ) genericDeclaration : null ; } 
static void checkNotPrimitive ( Type type ) { checkArgument ( ! ( type instanceof Class < ? > ) || ! ( ( Class < ? > ) type ) .isPrimitive ( ) ) ; } 
public Type[] getActualTypeArguments ( ) { return typeArguments.clone ( ) ; } 
public Type getRawType ( ) { return rawType ; } 
public Type getOwnerType ( ) { return ownerType ; } 
public Type getGenericComponentType ( ) { return componentType ; }
public Type[] getUpperBounds ( ) { return new Type[] { upperBound } ; } 
public Type[] getLowerBounds ( ) { return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY ; } 
public void write ( JsonWriter out , Object array ) throws IOException { if ( array == null ) { out.nullValue ( ) ; return ; } out.beginArray ( ) ; for ( int i = 0 , length = Array.getLength ( array ) ; i < length ; i++ ) { E value = ( E ) Array.get ( array , i ) ; componentTypeAdapter.write ( out , value ) ; } out.endArray ( ) ; }
public void write ( JsonWriter out , Collection < E > collection ) throws IOException { if ( collection == null ) { out.nullValue ( ) ; return ; } out.beginArray ( ) ; for ( E element : collection ) { elementTypeAdapter.write ( out , element ) ; } out.endArray ( ) ; }
public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > typeToken ) { return typeToken.getRawType ( ) == Date.class ? ( TypeAdapter < T > ) new DateTypeAdapter ( ) : null ; } 
public synchronized void write ( JsonWriter out , Date value ) throws IOException { if ( value == null ) { out.nullValue ( ) ; return ; } String dateFormatAsString = dateFormats.get ( 0 ) .format ( value ) ; out.value ( dateFormatAsString ) ; }
public int read ( char[] buffer , int offset , int count ) throws IOException { throw new AssertionError ( ) ; }
public void close ( ) throws IOException { throw new AssertionError ( ) ; } 
public void beginArray ( ) throws IOException { expect ( JsonToken.BEGIN_ARRAY ) ; JsonArray array = ( JsonArray ) peekStack ( ) ; push ( array.iterator ( ) ) ; pathIndices[stackSize - 1] = 0 ; } 
public void endArray ( ) throws IOException { expect ( JsonToken.END_ARRAY ) ; popStack ( ) ; popStack ( ) ; if ( stackSize > 0 ) { pathIndices[stackSize - 1]++ ; } } 
public void beginObject ( ) throws IOException { expect ( JsonToken.BEGIN_OBJECT ) ; JsonObject object = ( JsonObject ) peekStack ( ) ; push ( object.entrySet ( ) .iterator ( ) ) ; } 
public void endObject ( ) throws IOException { expect ( JsonToken.END_OBJECT ) ; popStack ( ) ; popStack ( ) ; if ( stackSize > 0 ) { pathIndices[stackSize - 1]++ ; } } 
public boolean hasNext ( ) throws IOException { JsonToken token = peek ( ) ; return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY ; } 
private Object peekStack ( ) { return stack[stackSize - 1] ; } 
private Object popStack ( ) { Object result = stack[--stackSize] ; stack[stackSize] = null ; return result ; } 
private void expect ( JsonToken expected ) throws IOException { if ( peek ( ) != expected ) { throw new IllegalStateException ( " Expected " + expected + " but was " + peek ( ) + locationString ( ) ) ; } } 
public String nextName ( ) throws IOException { expect ( JsonToken.NAME ) ; Iterator < ? > i = ( Iterator < ? > ) peekStack ( ) ; Map.Entry < ? , ? > entry = ( Map.Entry < ? , ? > ) i.next ( ) ; String result = ( String ) entry.getKey ( ) ; pathNames[stackSize - 1] = result ; push ( entry.getValue ( ) ) ; return result ; } 
public String nextString ( ) throws IOException { JsonToken token = peek ( ) ; if ( token != JsonToken.STRING && token != JsonToken.NUMBER ) { throw new IllegalStateException ( " Expected " + JsonToken.STRING + " but was " + token + locationString ( ) ) ; } String result = ( ( JsonPrimitive ) popStack ( ) ) .getAsString ( ) ; if ( stackSize > 0 ) { pathIndices[stackSize - 1]++ ; } return result ; } 
public boolean nextBoolean ( ) throws IOException { expect ( JsonToken.BOOLEAN ) ; boolean result = ( ( JsonPrimitive ) popStack ( ) ) .getAsBoolean ( ) ; if ( stackSize > 0 ) { pathIndices[stackSize - 1]++ ; } return result ; } 
public void nextNull ( ) throws IOException { expect ( JsonToken.NULL ) ; popStack ( ) ; if ( stackSize > 0 ) { pathIndices[stackSize - 1]++ ; } } 
public double nextDouble ( ) throws IOException { JsonToken token = peek ( ) ; if ( token != JsonToken.NUMBER && token != JsonToken.STRING ) { throw new IllegalStateException ( " Expected " + JsonToken.NUMBER + " but was " + token + locationString ( ) ) ; } double result = ( ( JsonPrimitive ) peekStack ( ) ) .getAsDouble ( ) ; if ( !isLenient ( ) && ( Double.isNaN ( result ) || Double.isInfinite ( result ) ) ) { throw new NumberFormatException ( " JSON forbids NaN and infinities: " + result ) ; } popStack ( ) ; if ( stackSize > 0 ) { pathIndices[stackSize - 1]++ ; } return result ; } 
public long nextLong ( ) throws IOException { JsonToken token = peek ( ) ; if ( token != JsonToken.NUMBER && token != JsonToken.STRING ) { throw new IllegalStateException ( " Expected " + JsonToken.NUMBER + " but was " + token + locationString ( ) ) ; } long result = ( ( JsonPrimitive ) peekStack ( ) ) .getAsLong ( ) ; popStack ( ) ; if ( stackSize > 0 ) { pathIndices[stackSize - 1]++ ; } return result ; } 
public int nextInt ( ) throws IOException { JsonToken token = peek ( ) ; if ( token != JsonToken.NUMBER && token != JsonToken.STRING ) { throw new IllegalStateException ( " Expected " + JsonToken.NUMBER + " but was " + token + locationString ( ) ) ; } int result = ( ( JsonPrimitive ) peekStack ( ) ) .getAsInt ( ) ; popStack ( ) ; if ( stackSize > 0 ) { pathIndices[stackSize - 1]++ ; } return result ; } 
public void close ( ) throws IOException { stack = new Object[] { SENTINEL_CLOSED } ; stackSize = 1 ; } 
public void skipValue ( ) throws IOException { if ( peek ( ) == JsonToken.NAME ) { nextName ( ) ; pathNames[stackSize - 2] = " null " ; } else { popStack ( ) ; if ( stackSize > 0 ) { pathNames[stackSize - 1] = " null " ; } } if ( stackSize > 0 ) { pathIndices[stackSize - 1]++ ; } } 
public void promoteNameToValue ( ) throws IOException { expect ( JsonToken.NAME ) ; Iterator < ? > i = ( Iterator < ? > ) peekStack ( ) ; Map.Entry < ? , ? > entry = ( Map.Entry < ? , ? > ) i.next ( ) ; push ( entry.getValue ( ) ) ; push ( new JsonPrimitive ( ( String ) entry.getKey ( ) ) ) ; } 
private String locationString ( ) { return " at path " + getPath ( ) ; } 
public void write ( char[] buffer , int offset , int counter ) { throw new AssertionError ( ) ; } 
public void flush ( ) throws IOException { throw new AssertionError ( ) ; } 
public JsonElement get ( ) { if ( !stack.isEmpty ( ) ) { throw new IllegalStateException ( " Expected one JSON element but was " + stack ) ; } return product ; } 
private JsonElement peek ( ) { return stack.get ( stack.size ( ) - 1 ) ; } 
public JsonWriter beginArray ( ) throws IOException { JsonArray array = new JsonArray ( ) ; put ( array ) ; stack.add ( array ) ; return this ; } 
public JsonWriter endArray ( ) throws IOException { if ( stack.isEmpty ( ) || pendingName != null ) { throw new IllegalStateException ( ) ; } JsonElement element = peek ( ) ; if ( element instanceof JsonArray ) { stack.remove ( stack.size ( ) - 1 ) ; return this ; } throw new IllegalStateException ( ) ; } 
public JsonWriter beginObject ( ) throws IOException { JsonObject object = new JsonObject ( ) ; put ( object ) ; stack.add ( object ) ; return this ; } 
public JsonWriter endObject ( ) throws IOException { if ( stack.isEmpty ( ) || pendingName != null ) { throw new IllegalStateException ( ) ; } JsonElement element = peek ( ) ; if ( element instanceof JsonObject ) { stack.remove ( stack.size ( ) - 1 ) ; return this ; } throw new IllegalStateException ( ) ; } 
public JsonWriter name ( String name ) throws IOException { if ( stack.isEmpty ( ) || pendingName != null ) { throw new IllegalStateException ( ) ; } JsonElement element = peek ( ) ; if ( element instanceof JsonObject ) { pendingName = name ; return this ; } throw new IllegalStateException ( ) ; } 
public JsonWriter nullValue ( ) throws IOException { put ( JsonNull.INSTANCE ) ; return this ; }
public JsonWriter value ( boolean value ) throws IOException { put ( new JsonPrimitive ( value ) ) ; return this ; } 
public JsonWriter value ( double value ) throws IOException { if ( !isLenient ( ) && ( Double.isNaN ( value ) || Double.isInfinite ( value ) ) ) { throw new IllegalArgumentException ( " JSON forbids NaN and infinities: " + value ) ; } put ( new JsonPrimitive ( value ) ) ; return this ; }
public JsonWriter value ( long value ) throws IOException { put ( new JsonPrimitive ( value ) ) ; return this ; } 
public void close ( ) throws IOException { if ( !stack.isEmpty ( ) ) { throw new IOException ( " Incomplete document " ) ; } stack.add ( SENTINEL_CLOSED ) ; }
private TypeAdapter < ? > getKeyAdapter ( Gson context , Type keyType ) { return ( keyType == boolean.class || keyType == Boolean.class ) ? TypeAdapters.BOOLEAN_AS_STRING : context.getAdapter ( TypeToken.get ( keyType ) ) ; } 
public void write ( JsonWriter out , Object value ) throws IOException { if ( value == null ) { out.nullValue ( ) ; return ; } TypeAdapter < Object > typeAdapter = ( TypeAdapter < Object > ) gson.getAdapter ( value.getClass ( ) ) ; if ( typeAdapter instanceof ObjectTypeAdapter ) { out.beginObject ( ) ; out.endObject ( ) ; return ; } typeAdapter.write ( out , value ) ; }
public boolean excludeField ( Field f , boolean serialize ) { return excludeField ( f , serialize , excluder ) ; } 
static boolean excludeField ( Field f , boolean serialize , Excluder excluder ) { return !excluder.excludeClass ( f.getType ( ) , serialize ) && !excluder.excludeField ( f , serialize ) ; } 
void write ( JsonWriter writer , Object value ) throws IOException , IllegalAccessException { Object fieldValue = field.get ( value ) ; TypeAdapter t = jsonAdapterPresent ? typeAdapter : new TypeAdapterRuntimeTypeWrapper ( context , typeAdapter , fieldType.getType ( ) ) ; t.write ( writer , fieldValue ) ; }
void read ( JsonReader reader , Object value ) throws IOException , IllegalAccessException { Object fieldValue = typeAdapter.read ( reader ) ; if ( fieldValue != null || !isPrimitive ) { field.set ( value , fieldValue ) ; } } 
public boolean writeField ( Object value ) throws IOException , IllegalAccessException { if ( !serialized ) return false ; Object fieldValue = field.get ( value ) ; return fieldValue != value ; } 
public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > typeToken ) { return typeToken.getRawType ( ) == java.sql.Date.class ? ( TypeAdapter < T > ) new SqlDateTypeAdapter ( ) : null ; } 
public synchronized void write ( JsonWriter out , java.sql.Date value ) throws IOException { out.value ( value == null ? null : format.format ( value ) ) ; }
public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > typeToken ) { return typeToken.getRawType ( ) == Time.class ? ( TypeAdapter < T > ) new TimeTypeAdapter ( ) : null ; } 
public synchronized void write ( JsonWriter out , Time value ) throws IOException { out.value ( value == null ? null : format.format ( value ) ) ; }
public void write ( JsonWriter out , T value ) throws IOException { if ( serializer == null ) { delegate ( ) .write ( out , value ) ; return ; } if ( value == null ) { out.nullValue ( ) ; return ; } JsonElement tree = serializer.serialize ( value , typeToken.getType ( ) , context ) ; Streams.write ( tree , out ) ; }
private TypeAdapter < T > delegate ( ) { TypeAdapter < T > d = delegate ; return d != null ? d : ( delegate = gson.getDelegateAdapter ( skipPast , typeToken ) ) ; } 
public static TypeAdapterFactory newFactoryWithMatchRawType ( TypeToken < ? > exactType , Object typeAdapter ) { boolean matchRawType = exactType.getType ( ) == exactType.getRawType ( ) ; return new SingleTypeFactory ( typeAdapter , exactType , matchRawType , null ) ; } 
public static TypeAdapterFactory newTypeHierarchyFactory ( Class < ? > hierarchyType , Object typeAdapter ) { return new SingleTypeFactory ( typeAdapter , null , false , hierarchyType ) ; } 
public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > type ) { boolean matches = exactType != null ? exactType.equals ( type ) || matchRawType && exactType.getType ( ) == type.getRawType ( ) : hierarchyType.isAssignableFrom ( type.getRawType ( ) ) ; return matches ? new TreeTypeAdapter < T > ( ( JsonSerializer < T > ) serializer , ( JsonDeserializer < T > ) deserializer , gson , type , this ) : null ; } 
public JsonElement serialize ( Object src ) { return gson.toJsonTree ( src ) ; } 
public JsonElement serialize ( Object src , Type typeOfSrc ) { return gson.toJsonTree ( src , typeOfSrc ) ; } 
public < R > R deserialize ( JsonElement json , Type typeOfT ) throws JsonParseException { return ( R ) gson.fromJson ( json , typeOfT ) ; } 
public T read ( JsonReader in ) throws IOException { return delegate.read ( in ) ; } 
private Type getRuntimeTypeIfMoreSpecific ( Type type , Object value ) { if ( value != null && ( type == Object.class || type instanceof TypeVariable < ? > || type instanceof Class < ? > ) ) { type = value.getClass ( ) ; } return type ; } 
public void write ( JsonWriter out , BitSet src ) throws IOException { out.beginArray ( ) ; for ( int i = 0 , length = src.length ( ) ; i < length ; i++ ) { int value = ( src.get ( i ) ) ? 1 : 0 ; out.value ( value ) ; } out.endArray ( ) ; }
public void write ( JsonWriter out , Boolean value ) throws IOException { out.value ( value ) ; }
public void write ( JsonWriter out , Boolean value ) throws IOException { out.value ( value == null ? " null " : value.toString ( ) ) ; }
public void write ( JsonWriter out , Number value ) throws IOException { out.value ( value ) ; }
public AtomicInteger read ( JsonReader in ) throws IOException { try { return new AtomicInteger ( in.nextInt ( ) ) ; } catch ( NumberFormatException e ) { throw new JsonSyntaxException ( e ) ; } }
public void write ( JsonWriter out , AtomicInteger value ) throws IOException { out.value ( value.get ( ) ) ; } 
public AtomicBoolean read ( JsonReader in ) throws IOException { return new AtomicBoolean ( in.nextBoolean ( ) ) ; } 
public void write ( JsonWriter out , AtomicBoolean value ) throws IOException { out.value ( value.get ( ) ) ; } 
public void write ( JsonWriter out , AtomicIntegerArray value ) throws IOException { out.beginArray ( ) ; for ( int i = 0 , length = value.length ( ) ; i < length ; i++ ) { out.value ( value.get ( i ) ) ; } out.endArray ( ) ; } 
public void write ( JsonWriter out , Character value ) throws IOException { out.value ( value == null ? null : String.valueOf ( value ) ) ; }
public void write ( JsonWriter out , String value ) throws IOException { out.value ( value ) ; }
public void write ( JsonWriter out , BigDecimal value ) throws IOException { out.value ( value ) ; }
public void write ( JsonWriter out , BigInteger value ) throws IOException { out.value ( value ) ; }
public void write ( JsonWriter out , StringBuilder value ) throws IOException { out.value ( value == null ? null : value.toString ( ) ) ; }
public void write ( JsonWriter out , StringBuffer value ) throws IOException { out.value ( value == null ? null : value.toString ( ) ) ; }
public void write ( JsonWriter out , URL value ) throws IOException { out.value ( value == null ? null : value.toExternalForm ( ) ) ; }
public void write ( JsonWriter out , URI value ) throws IOException { out.value ( value == null ? null : value.toASCIIString ( ) ) ; }
public void write ( JsonWriter out , InetAddress value ) throws IOException { out.value ( value == null ? null : value.getHostAddress ( ) ) ; }
public void write ( JsonWriter out , UUID value ) throws IOException { out.value ( value == null ? null : value.toString ( ) ) ; }
public Currency read ( JsonReader in ) throws IOException { return Currency.getInstance ( in.nextString ( ) ) ; } 
public void write ( JsonWriter out , Currency value ) throws IOException { out.value ( value.getCurrencyCode ( ) ) ; } 
public Timestamp read ( JsonReader in ) throws IOException { Date date = dateTypeAdapter.read ( in ) ; return date != null ? new Timestamp ( date.getTime ( ) ) : null ; } 
public void write ( JsonWriter out , Timestamp value ) throws IOException { dateTypeAdapter.write ( out , value ) ; } 
public void write ( JsonWriter out , Locale value ) throws IOException { out.value ( value == null ? null : value.toString ( ) ) ; } 
public void write ( JsonWriter out , T value ) throws IOException { out.value ( value == null ? null : constantToName.get ( value ) ) ; }
public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > typeToken ) { return typeToken.equals ( type ) ? ( TypeAdapter < T > ) typeAdapter : null ; }
public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > typeToken ) { return typeToken.getRawType ( ) == type ? ( TypeAdapter < T > ) typeAdapter : null ; } 
public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > typeToken ) { Class < ? super T > rawType = typeToken.getRawType ( ) ; return ( rawType == unboxed || rawType == boxed ) ? ( TypeAdapter < T > ) typeAdapter : null ; } 
public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > typeToken ) { Class < ? super T > rawType = typeToken.getRawType ( ) ; return ( rawType == base || rawType == sub ) ? ( TypeAdapter < T > ) typeAdapter : null ; } 
public void write ( JsonWriter out , T1 value ) throws IOException { typeAdapter.write ( out , value ) ; } 
public T1 read ( JsonReader in ) throws IOException { T1 result = typeAdapter.read ( in ) ; if ( result != null && !requestedType.isInstance ( result ) ) { throw new JsonSyntaxException ( " Expected a " + requestedType.getName ( ) + " but was " + result.getClass ( ) .getName ( ) ) ; } return result ; } 
public static String format ( Date date ) { return format ( date , false , TIMEZONE_UTC ) ; } 
public static String format ( Date date , boolean millis ) { return format ( date , millis , TIMEZONE_UTC ) ; } 
private static boolean checkOffset ( String value , int offset , char expected ) { return ( offset < value.length ( ) ) && ( value.charAt ( offset ) == expected ) ; } 
private static void padInt ( StringBuilder buffer , int value , int length ) { String strValue = Integer.toString ( value ) ; for ( int i = length - strValue.length ( ) ; i > 0 ; i-- ) { buffer.append ( '0' ) ; } buffer.append ( strValue ) ; } 
private static int indexOfNonDigit ( String string , int offset ) { for ( int i = offset ; i < string.length ( ) ; i++ ) { char c = string.charAt ( i ) ; if ( c < '0' || c > '9' ) return i ; } return string.length ( ) ; } 
public T construct ( ) { return typeCreator.createInstance ( type ) ; } 
public T construct ( ) { return rawTypeCreator.createInstance ( type ) ; } 
public T construct ( ) { try { Object[] args = null ; return ( T ) constructor.newInstance ( args ) ; } catch ( InstantiationException e ) { throw new RuntimeException ( " Failed to invoke " + constructor + " with no args " , e ) ; } catch ( InvocationTargetException e ) { throw new RuntimeException ( " Failed to invoke " + constructor + " with no args " , e.getTargetException ( ) ) ; } catch ( IllegalAccessException e ) { throw new AssertionError ( e ) ; } } 
public T construct ( ) { return ( T ) new TreeSet < Object > ( ) ; } 
public T construct ( ) { if ( type instanceof ParameterizedType ) { Type elementType = ( ( ParameterizedType ) type ) .getActualTypeArguments ( ) [0] ; if ( elementType instanceof Class ) { return ( T ) EnumSet.noneOf ( ( Class ) elementType ) ; } else { throw new JsonIOException ( " Invalid EnumSet type: " + type.toString ( ) ) ; } } else { throw new JsonIOException ( " Invalid EnumSet type: " + type.toString ( ) ) ; } } 
public T construct ( ) { return ( T ) new LinkedHashSet < Object > ( ) ; } 
public T construct ( ) { return ( T ) new ArrayDeque < Object > ( ) ; } 
public T construct ( ) { return ( T ) new ArrayList < Object > ( ) ; } 
public T construct ( ) { return ( T ) new ConcurrentSkipListMap < Object , Object > ( ) ; } 
public T construct ( ) { return ( T ) new ConcurrentHashMap < Object , Object > ( ) ; } 
public T construct ( ) { return ( T ) new TreeMap < Object , Object > ( ) ; } 
public T construct ( ) { return ( T ) new LinkedHashMap < Object , Object > ( ) ; } 
public T construct ( ) { return ( T ) new LinkedTreeMap < String , Object > ( ) ; } 
public T construct ( ) { try { Object newInstance = unsafeAllocator.newInstance ( rawType ) ; return ( T ) newInstance ; } catch ( Exception e ) { throw new RuntimeException ( ( " Unable to invoke no-args constructor for " + type + " . " + " Registering an InstanceCreator with Gson for this type may fix this problem. " ) , e ) ; } } 
protected Excluder clone ( ) { try { return ( Excluder ) super.clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new AssertionError ( e ) ; } } 
public Excluder withVersion ( double ignoreVersionsAfter ) { Excluder result = clone ( ) ; result.version = ignoreVersionsAfter ; return result ; } 
public Excluder withModifiers ( int... modifiers ) { Excluder result = clone ( ) ; result.modifiers = 0 ; for ( int modifier : modifiers ) { result.modifiers |= modifier ; } return result ; } 
public Excluder disableInnerClassSerialization ( ) { Excluder result = clone ( ) ; result.serializeInnerClasses = false ; return result ; } 
public Excluder excludeFieldsWithoutExposeAnnotation ( ) { Excluder result = clone ( ) ; result.requireExpose = true ; return result ; } 
public Excluder withExclusionStrategy ( ExclusionStrategy exclusionStrategy , boolean serialization , boolean deserialization ) { Excluder result = clone ( ) ; if ( serialization ) { result.serializationStrategies = new ArrayList < ExclusionStrategy > ( serializationStrategies ) ; result.serializationStrategies.add ( exclusionStrategy ) ; } if ( deserialization ) { result.deserializationStrategies = new ArrayList < ExclusionStrategy > ( deserializationStrategies ) ; result.deserializationStrategies.add ( exclusionStrategy ) ; } return result ; } 
public void write ( JsonWriter out , T value ) throws IOException { if ( skipSerialize ) { out.nullValue ( ) ; return ; } delegate ( ) .write ( out , value ) ; }
private TypeAdapter < T > delegate ( ) { TypeAdapter < T > d = delegate ; return d != null ? d : ( delegate = gson.getDelegateAdapter ( Excluder.this , type ) ) ; } 
private boolean excludeClassChecks ( Class < ? > clazz ) { if ( version != Excluder.IGNORE_VERSIONS && !isValidVersion ( clazz.getAnnotation ( Since.class ) , clazz.getAnnotation ( Until.class ) ) ) { return true ; } if ( !serializeInnerClasses && isInnerClass ( clazz ) ) { return true ; } if ( isAnonymousOrLocal ( clazz ) ) { return true ; } return false ; } 
private boolean isAnonymousOrLocal ( Class < ? > clazz ) { return !Enum.class.isAssignableFrom ( clazz ) && ( clazz.isAnonymousClass ( ) || clazz.isLocalClass ( ) ) ; } 
private boolean isInnerClass ( Class < ? > clazz ) { return clazz.isMemberClass ( ) && !isStatic ( clazz ) ; } 
private boolean isStatic ( Class < ? > clazz ) { return ( clazz.getModifiers ( ) & Modifier.STATIC ) != 0 ; } 
private boolean isValidVersion ( Since since , Until until ) { return isValidSince ( since ) && isValidUntil ( until ) ; } 
private boolean isValidSince ( Since annotation ) { if ( annotation != null ) { double annotationVersion = annotation.value ( ) ; if ( annotationVersion > version ) { return false ; } } return true ; } 
private boolean isValidUntil ( Until annotation ) { if ( annotation != null ) { double annotationVersion = annotation.value ( ) ; if ( annotationVersion < = version ) { return false ; } } return true ; } 
private static int determineMajorJavaVersion ( ) { String javaVersion = System.getProperty ( " java.version " ) ; return getMajorJavaVersion ( javaVersion ) ; } 
static int getMajorJavaVersion ( String javaVersion ) { int version = parseDotted ( javaVersion ) ; if ( version == -1 ) { version = extractBeginningInt ( javaVersion ) ; } if ( version == -1 ) { return 6 ; } return version ; } 
private static int parseDotted ( String javaVersion ) { try { String[] parts = javaVersion.split ( " [._] " ) ; int firstVer = Integer.parseInt ( parts[0] ) ; if ( firstVer == 1 && parts.length > 1 ) { return Integer.parseInt ( parts[1] ) ; } else { return firstVer ; } } catch ( NumberFormatException e ) { return -1 ; } } 
public static int getMajorJavaVersion ( ) { return majorJavaVersion ; } 
public static boolean isJava9OrLater ( ) { return majorJavaVersion > = 9 ; } 
public int intValue ( ) { try { return Integer.parseInt ( value ) ; } catch ( NumberFormatException e ) { try { return ( int ) Long.parseLong ( value ) ; } catch ( NumberFormatException nfe ) { return new BigDecimal ( value ) .intValue ( ) ; } } } 
public long longValue ( ) { try { return Long.parseLong ( value ) ; } catch ( NumberFormatException e ) { return new BigDecimal ( value ) .longValue ( ) ; } } 
public float floatValue ( ) { return Float.parseFloat ( value ) ; } 
public double doubleValue ( ) { return Double.parseDouble ( value ) ; } 
private Object writeReplace ( ) throws ObjectStreamException { return new BigDecimal ( value ) ; }
public int compare ( Comparable a , Comparable b ) { return a.compareTo ( b ) ; }
public int size ( ) { return size ; } 
public V get ( Object key ) { Node < K , V > node = findByObject ( key ) ; return node != null ? node.value : null ; } 
public boolean containsKey ( Object key ) { return findByObject ( key ) != null ; } 
public V put ( K key , V value ) { if ( key == null ) { throw new NullPointerException ( " key == null " ) ; } Node < K , V > created = find ( key , true ) ; V result = created.value ; created.value = value ; return result ; } 
public void clear ( ) { Arrays.fill ( table , null ) ; size = 0 ; modCount++ ; Node < K , V > header = this.header ; for ( Node < K , V > e = header.next ; e != header ; ) { Node < K , V > next = e.next ; e.next = e.prev = null ; e = next ; } header.next = header.prev = header ; } 
public V remove ( Object key ) { Node < K , V > node = removeInternalByKey ( key ) ; return node != null ? node.value : null ; } 
Node < K , V > findByEntry ( Entry < ? , ? > entry ) { Node < K , V > mine = findByObject ( entry.getKey ( ) ) ; boolean valuesEqual = mine != null && equal ( mine.value , entry.getValue ( ) ) ; return valuesEqual ? mine : null ; }
private boolean equal ( Object a , Object b ) { return a == b || ( a != null && a.equals ( b ) ) ; } 
private static int secondaryHash ( int h ) { h ^= ( h > > > 20 ) ^ ( h > > > 12 ) ; return h ^ ( h > > > 7 ) ^ ( h > > > 4 ) ; } 
Node < K , V > removeInternalByKey ( Object key ) { Node < K , V > node = findByObject ( key ) ; if ( node != null ) { removeInternal ( node , true ) ; } return node ; } 
public Set < Entry < K , V > > entrySet ( ) { EntrySet result = entrySet ; return result != null ? result : ( entrySet = new EntrySet ( ) ) ; } 
public Set < K > keySet ( ) { KeySet result = keySet ; return result != null ? result : ( keySet = new KeySet ( ) ) ; } 
public K getKey ( ) { return key ; } 
public V getValue ( ) { return value ; } 
public V setValue ( V value ) { V oldValue = this.value ; this.value = value ; return oldValue ; } 
public Node < K , V > first ( ) { Node < K , V > node = this ; Node < K , V > child = node.left ; while ( child != null ) { node = child ; child = node.left ; } return node ; }
public Node < K , V > last ( ) { Node < K , V > node = this ; Node < K , V > child = node.right ; while ( child != null ) { node = child ; child = node.right ; } return node ; } 
private void doubleCapacity ( ) { table = doubleCapacity ( table ) ; threshold = ( table.length / 2 ) + ( table.length / 4 ) ; } 
void reset ( Node < K , V > root ) { Node < K , V > stackTop = null ; for ( Node < K , V > n = root ; n != null ; n = n.left ) { n.parent = stackTop ; stackTop = n ; } this.stackTop = stackTop ; } 
void reset ( int targetSize ) { int treeCapacity = Integer.highestOneBit ( targetSize ) * 2 - 1 ; leavesToSkip = treeCapacity - targetSize ; size = 0 ; leavesSkipped = 0 ; stack = null ; } 
Node < K , V > root ( ) { Node < K , V > stackTop = this.stack ; if ( stackTop.parent != null ) { throw new IllegalStateException ( ) ; } return stackTop ; } 
public final boolean hasNext ( ) { return next != header ; } 
final Node < K , V > nextNode ( ) { Node < K , V > e = next ; if ( e == header ) { throw new NoSuchElementException ( ) ; } if ( modCount != expectedModCount ) { throw new ConcurrentModificationException ( ) ; } next = e.next ; return lastReturned = e ; } 
public final void remove ( ) { if ( lastReturned == null ) { throw new IllegalStateException ( ) ; } removeInternal ( lastReturned , true ) ; lastReturned = null ; expectedModCount = modCount ; } 
public Entry < K , V > next ( ) { return nextNode ( ) ; } 
public boolean contains ( Object o ) { return o instanceof Entry && findByEntry ( ( Entry < ? , ? > ) o ) != null ; } 
public boolean remove ( Object o ) { if ( ! ( o instanceof Entry ) ) { return false ; } Node < K , V > node = findByEntry ( ( Entry < ? , ? > ) o ) ; if ( node == null ) { return false ; } removeInternal ( node , true ) ; return true ; } 
public void clear ( ) { LinkedHashTreeMap.this.clear ( ) ; } 
public K next ( ) { return nextNode ( ) .key ; } 
public boolean contains ( Object o ) { return containsKey ( o ) ; } 
public boolean remove ( Object key ) { return removeInternalByKey ( key ) != null ; } 
private Object writeReplace ( ) throws ObjectStreamException { return new LinkedHashMap < K , V > ( this ) ; } 
public void clear ( ) { root = null ; size = 0 ; modCount++ ; Node < K , V > header = this.header ; header.next = header.prev = header ; } 
public void clear ( ) { LinkedTreeMap.this.clear ( ) ; } 
public static DateFormat getUSDateFormat ( int style ) { return new SimpleDateFormat ( getDateFormatPattern ( style ) , Locale.US ) ; } 
public static DateFormat getUSDateTimeFormat ( int dateStyle , int timeStyle ) { String pattern = getDatePartOfDateTimePattern ( dateStyle ) + " " + getTimePartOfDateTimePattern ( timeStyle ) ; return new SimpleDateFormat ( pattern , Locale.US ) ; } 
private static void add ( Map < Class < ? > , Class < ? > > forward , Map < Class < ? > , Class < ? > > backward , Class < ? > key , Class < ? > value ) { forward.put ( key , value ) ; backward.put ( value , key ) ; } 
public static boolean isPrimitive ( Type type ) { return PRIMITIVE_TO_WRAPPER_TYPE.containsKey ( type ) ; } 
public static boolean isWrapperType ( Type type ) { return WRAPPER_TO_PRIMITIVE_TYPE.containsKey ( $Gson$Preconditions.checkNotNull ( type ) ) ; } 
public static < T > Class < T > wrap ( Class < T > type ) { @SuppressWarnings ( " unchecked " ) Class < T > wrapped = ( Class < T > ) PRIMITIVE_TO_WRAPPER_TYPE.get ( $Gson$Preconditions.checkNotNull ( type ) ) ; return ( wrapped == null ) ? type : wrapped ; } 
public static < T > Class < T > unwrap ( Class < T > type ) { @SuppressWarnings ( " unchecked " ) Class < T > unwrapped = ( Class < T > ) WRAPPER_TO_PRIMITIVE_TYPE.get ( $Gson$Preconditions.checkNotNull ( type ) ) ; return ( unwrapped == null ) ? type : unwrapped ; } 
public void makeAccessible ( AccessibleObject ao ) { ao.setAccessible ( true ) ; } 
public static ReflectionAccessor getInstance ( ) { return instance ; } 
public void makeAccessible ( AccessibleObject ao ) { boolean success = makeAccessibleWithUnsafe ( ao ) ; if ( !success ) { try { ao.setAccessible ( true ) ; } catch ( SecurityException e ) { throw new JsonIOException ( " Gson couldn't modify fields for " + ao + " \nand sun.misc.Unsafe not found.\nEither write a custom type adapter , " + " or make fields accessible , or include sun.misc.Unsafe. " , e ) ; } } } 
public static void write ( JsonElement element , JsonWriter writer ) throws IOException { TypeAdapters.JSON_ELEMENT.write ( writer , element ) ; }
public static Writer writerForAppendable ( Appendable appendable ) { return appendable instanceof Writer ? ( Writer ) appendable : new AppendableWriter ( appendable ) ; } 
public void write ( char[] chars , int offset , int length ) throws IOException { currentWrite.chars = chars ; appendable.append ( currentWrite , offset , offset + length ) ; } 
public void write ( int i ) throws IOException { appendable.append ( ( char ) i ) ; } 
public int length ( ) { return chars.length ; } 
public char charAt ( int i ) { return chars[i] ; } 
public CharSequence subSequence ( int start , int end ) { return new String ( chars , start , end - start ) ; } 
public < T > T newInstance ( Class < T > c ) throws Exception { assertInstantiable ( c ) ; return ( T ) allocateInstance.invoke ( unsafe , c ) ; } 
public < T > T newInstance ( Class < T > c ) throws Exception { assertInstantiable ( c ) ; return ( T ) newInstance.invoke ( null , c , constructorId ) ; } 
public < T > T newInstance ( Class < T > c ) throws Exception { assertInstantiable ( c ) ; return ( T ) newInstance.invoke ( null , c , Object.class ) ; } 
public JsonArray deepCopy ( ) { if ( !elements.isEmpty ( ) ) { JsonArray result = new JsonArray ( elements.size ( ) ) ; for ( JsonElement element : elements ) { result.add ( element.deepCopy ( ) ) ; } return result ; } return new JsonArray ( ) ; }
public void add ( Character character ) { elements.add ( character == null ? JsonNull.INSTANCE : new JsonPrimitive ( character ) ) ; } 
public void add ( Number number ) { elements.add ( number == null ? JsonNull.INSTANCE : new JsonPrimitive ( number ) ) ; } 
public void add ( String string ) { elements.add ( string == null ? JsonNull.INSTANCE : new JsonPrimitive ( string ) ) ; } 
public void add ( JsonElement element ) { if ( element == null ) { element = JsonNull.INSTANCE ; } elements.add ( element ) ; } 
public void addAll ( JsonArray array ) { elements.addAll ( array.elements ) ; } 
public JsonElement set ( int index , JsonElement element ) { return elements.set ( index , element ) ; } 
public boolean remove ( JsonElement element ) { return elements.remove ( element ) ; } 
public JsonElement remove ( int index ) { return elements.remove ( index ) ; } 
public boolean contains ( JsonElement element ) { return elements.contains ( element ) ; } 
public int size ( ) { return elements.size ( ) ; } 
public Iterator < JsonElement > iterator ( ) { return elements.iterator ( ) ; } 
public JsonElement get ( int i ) { return elements.get ( i ) ; } 
public Number getAsNumber ( ) { if ( elements.size ( ) == 1 ) { return elements.get ( 0 ) .getAsNumber ( ) ; } throw new IllegalStateException ( ) ; } 
public String getAsString ( ) { if ( elements.size ( ) == 1 ) { return elements.get ( 0 ) .getAsString ( ) ; } throw new IllegalStateException ( ) ; } 
public double getAsDouble ( ) { if ( elements.size ( ) == 1 ) { return elements.get ( 0 ) .getAsDouble ( ) ; } throw new IllegalStateException ( ) ; } 
public BigDecimal getAsBigDecimal ( ) { if ( elements.size ( ) == 1 ) { return elements.get ( 0 ) .getAsBigDecimal ( ) ; } throw new IllegalStateException ( ) ; } 
public BigInteger getAsBigInteger ( ) { if ( elements.size ( ) == 1 ) { return elements.get ( 0 ) .getAsBigInteger ( ) ; } throw new IllegalStateException ( ) ; } 
public float getAsFloat ( ) { if ( elements.size ( ) == 1 ) { return elements.get ( 0 ) .getAsFloat ( ) ; } throw new IllegalStateException ( ) ; } 
public long getAsLong ( ) { if ( elements.size ( ) == 1 ) { return elements.get ( 0 ) .getAsLong ( ) ; } throw new IllegalStateException ( ) ; } 
public int getAsInt ( ) { if ( elements.size ( ) == 1 ) { return elements.get ( 0 ) .getAsInt ( ) ; } throw new IllegalStateException ( ) ; } 
public byte getAsByte ( ) { if ( elements.size ( ) == 1 ) { return elements.get ( 0 ) .getAsByte ( ) ; } throw new IllegalStateException ( ) ; } 
public char getAsCharacter ( ) { if ( elements.size ( ) == 1 ) { return elements.get ( 0 ) .getAsCharacter ( ) ; } throw new IllegalStateException ( ) ; } 
public short getAsShort ( ) { if ( elements.size ( ) == 1 ) { return elements.get ( 0 ) .getAsShort ( ) ; } throw new IllegalStateException ( ) ; } 
public boolean getAsBoolean ( ) { if ( elements.size ( ) == 1 ) { return elements.get ( 0 ) .getAsBoolean ( ) ; } throw new IllegalStateException ( ) ; } 
public boolean isJsonArray ( ) { return this instanceof JsonArray ; }
public boolean isJsonObject ( ) { return this instanceof JsonObject ; } 
public boolean isJsonPrimitive ( ) { return this instanceof JsonPrimitive ; } 
public boolean isJsonNull ( ) { return this instanceof JsonNull ; } 
public JsonObject getAsJsonObject ( ) { if ( isJsonObject ( ) ) { return ( JsonObject ) this ; } throw new IllegalStateException ( " Not a JSON Object: " + this ) ; } 
public JsonArray getAsJsonArray ( ) { if ( isJsonArray ( ) ) { return ( JsonArray ) this ; } throw new IllegalStateException ( " Not a JSON Array: " + this ) ; } 
public JsonPrimitive getAsJsonPrimitive ( ) { if ( isJsonPrimitive ( ) ) { return ( JsonPrimitive ) this ; } throw new IllegalStateException ( " Not a JSON Primitive: " + this ) ; } 
public JsonNull getAsJsonNull ( ) { if ( isJsonNull ( ) ) { return ( JsonNull ) this ; } throw new IllegalStateException ( " Not a JSON Null: " + this ) ; } 
public JsonNull deepCopy ( ) { return INSTANCE ; }
public JsonObject deepCopy ( ) { JsonObject result = new JsonObject ( ) ; for ( Map.Entry < String , JsonElement > entry : members.entrySet ( ) ) { result.add ( entry.getKey ( ) , entry.getValue ( ) .deepCopy ( ) ) ; } return result ; }
public void add ( String property , JsonElement value ) { if ( value == null ) { value = JsonNull.INSTANCE ; } members.put ( property , value ) ; } 
public JsonElement remove ( String property ) { return members.remove ( property ) ; } 
public void addProperty ( String property , String value ) { add ( property , createJsonElement ( value ) ) ; } 
public void addProperty ( String property , Number value ) { add ( property , createJsonElement ( value ) ) ; } 
public void addProperty ( String property , Boolean value ) { add ( property , createJsonElement ( value ) ) ; } 
public void addProperty ( String property , Character value ) { add ( property , createJsonElement ( value ) ) ; } 
private JsonElement createJsonElement ( Object value ) { return value == null ? JsonNull.INSTANCE : new JsonPrimitive ( value ) ; } 
public Set < Map.Entry < String , JsonElement > > entrySet ( ) { return members.entrySet ( ) ; } 
public Set < String > keySet ( ) { return members.keySet ( ) ; } 
public int size ( ) { return members.size ( ) ; } 
public boolean has ( String memberName ) { return members.containsKey ( memberName ) ; } 
public JsonElement get ( String memberName ) { return members.get ( memberName ) ; } 
public JsonPrimitive getAsJsonPrimitive ( String memberName ) { return ( JsonPrimitive ) members.get ( memberName ) ; } 
public JsonArray getAsJsonArray ( String memberName ) { return ( JsonArray ) members.get ( memberName ) ; } 
public JsonObject getAsJsonObject ( String memberName ) { return ( JsonObject ) members.get ( memberName ) ; } 
public JsonElement parse ( String json ) throws JsonSyntaxException { return parse ( new StringReader ( json ) ) ; }
public JsonElement parse ( JsonReader json ) throws JsonIOException , JsonSyntaxException { boolean lenient = json.isLenient ( ) ; json.setLenient ( true ) ; try { return Streams.parse ( json ) ; } catch ( StackOverflowError e ) { throw new JsonParseException ( " Failed parsing JSON source: " + json + " to Json " , e ) ; } catch ( OutOfMemoryError e ) { throw new JsonParseException ( " Failed parsing JSON source: " + json + " to Json " , e ) ; } finally { json.setLenient ( lenient ) ; } } 
public JsonPrimitive deepCopy ( ) { return this ; } 
void setValue ( Object primitive ) { if ( primitive instanceof Character ) { char c = ( ( Character ) primitive ) .charValue ( ) ; this.value = String.valueOf ( c ) ; } else { $Gson$Preconditions.checkArgument ( primitive instanceof Number || isPrimitiveOrString ( primitive ) ) ; this.value = primitive ; } } 
public boolean isBoolean ( ) { return value instanceof Boolean ; } 
Boolean getAsBooleanWrapper ( ) { return ( Boolean ) value ; } 
public boolean getAsBoolean ( ) { if ( isBoolean ( ) ) { return getAsBooleanWrapper ( ) .booleanValue ( ) ; } else { return Boolean.parseBoolean ( getAsString ( ) ) ; } } 
public boolean isNumber ( ) { return value instanceof Number ; } 
public Number getAsNumber ( ) { return value instanceof String ? new LazilyParsedNumber ( ( String ) value ) : ( Number ) value ; } 
public boolean isString ( ) { return value instanceof String ; } 
public String getAsString ( ) { if ( isNumber ( ) ) { return getAsNumber ( ) .toString ( ) ; } else if ( isBoolean ( ) ) { return getAsBooleanWrapper ( ) .toString ( ) ; } else { return ( String ) value ; } } 
public double getAsDouble ( ) { return isNumber ( ) ? getAsNumber ( ) .doubleValue ( ) : Double.parseDouble ( getAsString ( ) ) ; } 
public BigDecimal getAsBigDecimal ( ) { return value instanceof BigDecimal ? ( BigDecimal ) value : new BigDecimal ( value.toString ( ) ) ; } 
public BigInteger getAsBigInteger ( ) { return value instanceof BigInteger ? ( BigInteger ) value : new BigInteger ( value.toString ( ) ) ; } 
public float getAsFloat ( ) { return isNumber ( ) ? getAsNumber ( ) .floatValue ( ) : Float.parseFloat ( getAsString ( ) ) ; } 
public long getAsLong ( ) { return isNumber ( ) ? getAsNumber ( ) .longValue ( ) : Long.parseLong ( getAsString ( ) ) ; } 
public short getAsShort ( ) { return isNumber ( ) ? getAsNumber ( ) .shortValue ( ) : Short.parseShort ( getAsString ( ) ) ; } 
public int getAsInt ( ) { return isNumber ( ) ? getAsNumber ( ) .intValue ( ) : Integer.parseInt ( getAsString ( ) ) ; } 
public byte getAsByte ( ) { return isNumber ( ) ? getAsNumber ( ) .byteValue ( ) : Byte.parseByte ( getAsString ( ) ) ; } 
public char getAsCharacter ( ) { return getAsString ( ) .charAt ( 0 ) ; } 
private static boolean isPrimitiveOrString ( Object target ) { if ( target instanceof String ) { return true ; } Class < ? > classOfPrimitive = target.getClass ( ) ; for ( Class < ? > standardPrimitive : PRIMITIVE_TYPES ) { if ( standardPrimitive.isAssignableFrom ( classOfPrimitive ) ) { return true ; } } return false ; } 
private static boolean isIntegral ( JsonPrimitive primitive ) { if ( primitive.value instanceof Number ) { Number number = ( Number ) primitive.value ; return number instanceof BigInteger || number instanceof Long || number instanceof Integer || number instanceof Short || number instanceof Byte ; } return false ; }
public JsonElement next ( ) throws JsonParseException { if ( !hasNext ( ) ) { throw new NoSuchElementException ( ) ; } try { return Streams.parse ( parser ) ; } catch ( StackOverflowError e ) { throw new JsonParseException ( " Failed parsing JSON source to Json " , e ) ; } catch ( OutOfMemoryError e ) { throw new JsonParseException ( " Failed parsing JSON source to Json " , e ) ; } catch ( JsonParseException e ) { throw e.getCause ( ) instanceof EOFException ? new NoSuchElementException ( ) : e ; } } 
public boolean hasNext ( ) { synchronized ( lock ) { try { return parser.peek ( ) != JsonToken.END_DOCUMENT ; } catch ( MalformedJsonException e ) { throw new JsonSyntaxException ( e ) ; } catch ( IOException e ) { throw new JsonIOException ( e ) ; } } } 
public JsonElement serialize ( Long value ) { return new JsonPrimitive ( value ) ; } 
public JsonElement serialize ( Long value ) { return new JsonPrimitive ( String.valueOf ( value ) ) ; } 
static Type getSuperclassTypeParameter ( Class < ? > subclass ) { Type superclass = subclass.getGenericSuperclass ( ) ; if ( superclass instanceof Class ) { throw new RuntimeException ( " Missing type parameter. " ) ; } ParameterizedType parameterized = ( ParameterizedType ) superclass ; return $Gson$Types.canonicalize ( parameterized.getActualTypeArguments ( ) [0] ) ; } 
public final Class < ? super T > getRawType ( ) { return rawType ; } 
public final Type getType ( ) { return type ; } 
public boolean isAssignableFrom ( Class < ? > cls ) { return isAssignableFrom ( ( Type ) cls ) ; } 
public boolean isAssignableFrom ( TypeToken < ? > token ) { return isAssignableFrom ( token.getType ( ) ) ; } 
private static boolean typeEquals ( ParameterizedType from , ParameterizedType to , Map < String , Type > typeVarMap ) { if ( from.getRawType ( ) .equals ( to.getRawType ( ) ) ) { Type[] fromArgs = from.getActualTypeArguments ( ) ; Type[] toArgs = to.getActualTypeArguments ( ) ; for ( int i = 0 ; i < fromArgs.length ; i++ ) { if ( !matches ( fromArgs[i] , toArgs[i] , typeVarMap ) ) { return false ; } } return true ; } return false ; } 
private static boolean matches ( Type from , Type to , Map < String , Type > typeMap ) { return to.equals ( from ) || ( from instanceof TypeVariable && to.equals ( typeMap.get ( ( ( TypeVariable < ? > ) from ) .getName ( ) ) ) ) ; } 
public static TypeToken < ? > get ( Type type ) { return new TypeToken < Object > ( type ) ; }
public static < T > TypeToken < T > get ( Class < T > type ) { return new TypeToken < T > ( type ) ; } 
public static TypeToken < ? > getParameterized ( Type rawType , Type... typeArguments ) { return new TypeToken < Object > ( $Gson$Types.newParameterizedTypeWithOwner ( null , rawType , typeArguments ) ) ; } 
public static TypeToken < ? > getArray ( Type componentType ) { return new TypeToken < Object > ( $Gson$Types.arrayOf ( componentType ) ) ; } 
public final void setLenient ( boolean lenient ) { this.lenient = lenient ; } 
public final boolean isLenient ( ) { return lenient ; } 
public void beginArray ( ) throws IOException { int p = peeked ; if ( p == PEEKED_NONE ) { p = doPeek ( ) ; } if ( p == PEEKED_BEGIN_ARRAY ) { push ( JsonScope.EMPTY_ARRAY ) ; pathIndices[stackSize - 1] = 0 ; peeked = PEEKED_NONE ; } else { throw new IllegalStateException ( " Expected BEGIN_ARRAY but was " + peek ( ) + locationString ( ) ) ; } } 
public void endArray ( ) throws IOException { int p = peeked ; if ( p == PEEKED_NONE ) { p = doPeek ( ) ; } if ( p == PEEKED_END_ARRAY ) { stackSize-- ; pathIndices[stackSize - 1]++ ; peeked = PEEKED_NONE ; } else { throw new IllegalStateException ( " Expected END_ARRAY but was " + peek ( ) + locationString ( ) ) ; } } 
public void beginObject ( ) throws IOException { int p = peeked ; if ( p == PEEKED_NONE ) { p = doPeek ( ) ; } if ( p == PEEKED_BEGIN_OBJECT ) { push ( JsonScope.EMPTY_OBJECT ) ; peeked = PEEKED_NONE ; } else { throw new IllegalStateException ( " Expected BEGIN_OBJECT but was " + peek ( ) + locationString ( ) ) ; } } 
public void endObject ( ) throws IOException { int p = peeked ; if ( p == PEEKED_NONE ) { p = doPeek ( ) ; } if ( p == PEEKED_END_OBJECT ) { stackSize-- ; pathNames[stackSize] = null ; pathIndices[stackSize - 1]++ ; peeked = PEEKED_NONE ; } else { throw new IllegalStateException ( " Expected END_OBJECT but was " + peek ( ) + locationString ( ) ) ; } } 
public boolean hasNext ( ) throws IOException { int p = peeked ; if ( p == PEEKED_NONE ) { p = doPeek ( ) ; } return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY ; } 
public void close ( ) throws IOException { peeked = PEEKED_NONE ; stack[0] = JsonScope.CLOSED ; stackSize = 1 ; in.close ( ) ; } 
private void push ( int newTop ) { if ( stackSize == stack.length ) { int[] newStack = new int[stackSize * 2] ; int[] newPathIndices = new int[stackSize * 2] ; String[] newPathNames = new String[stackSize * 2] ; System.arraycopy ( stack , 0 , newStack , 0 , stackSize ) ; System.arraycopy ( pathIndices , 0 , newPathIndices , 0 , stackSize ) ; System.arraycopy ( pathNames , 0 , newPathNames , 0 , stackSize ) ; stack = newStack ; pathIndices = newPathIndices ; pathNames = newPathNames ; } stack[stackSize++] = newTop ; } 
private void checkLenient ( ) throws IOException { if ( !lenient ) { throw syntaxError ( " Use JsonReader.setLenient ( true ) to accept malformed JSON " ) ; } } 
private void skipToEndOfLine ( ) throws IOException { while ( pos < limit || fillBuffer ( 1 ) ) { char c = buffer[pos++] ; if ( c == '\n' ) { lineNumber++ ; lineStart = pos ; break ; } else if ( c == '\r' ) { break ; } } } 
String locationString ( ) { int line = lineNumber + 1 ; int column = pos - lineStart + 1 ; return " at line " + line + " column " + column + " path " + getPath ( ) ; }
private IOException syntaxError ( String message ) throws IOException { throw new MalformedJsonException ( message + locationString ( ) ) ; } 
public final void setIndent ( String indent ) { if ( indent.length ( ) == 0 ) { this.indent = null ; this.separator = " : " ; } else { this.indent = indent ; this.separator = " : " ; } } 
public boolean isLenient ( ) { return lenient ; } 
public final void setHtmlSafe ( boolean htmlSafe ) { this.htmlSafe = htmlSafe ; } 
public final boolean isHtmlSafe ( ) { return htmlSafe ; } 
public final void setSerializeNulls ( boolean serializeNulls ) { this.serializeNulls = serializeNulls ; } 
public final boolean getSerializeNulls ( ) { return serializeNulls ; } 
public JsonWriter beginArray ( ) throws IOException { writeDeferredName ( ) ; return open ( EMPTY_ARRAY , " [ " ) ; } 
public JsonWriter endArray ( ) throws IOException { return close ( EMPTY_ARRAY , NONEMPTY_ARRAY , " ] " ) ; } 
public JsonWriter beginObject ( ) throws IOException { writeDeferredName ( ) ; return open ( EMPTY_OBJECT , " { " ) ; } 
public JsonWriter endObject ( ) throws IOException { return close ( EMPTY_OBJECT , NONEMPTY_OBJECT , " } " ) ; } 
private JsonWriter open ( int empty , String openBracket ) throws IOException { beforeValue ( ) ; push ( empty ) ; out.write ( openBracket ) ; return this ; } 
private JsonWriter close ( int empty , int nonempty , String closeBracket ) throws IOException { int context = peek ( ) ; if ( context != nonempty && context != empty ) { throw new IllegalStateException ( " Nesting problem. " ) ; } if ( deferredName != null ) { throw new IllegalStateException ( " Dangling name: " + deferredName ) ; } stackSize-- ; if ( context == nonempty ) { newline ( ) ; } out.write ( closeBracket ) ; return this ; } 
private void push ( int newTop ) { if ( stackSize == stack.length ) { int[] newStack = new int[stackSize * 2] ; System.arraycopy ( stack , 0 , newStack , 0 , stackSize ) ; stack = newStack ; } stack[stackSize++] = newTop ; } 
private int peek ( ) { if ( stackSize == 0 ) { throw new IllegalStateException ( " JsonWriter is closed. " ) ; } return stack[stackSize - 1] ; } 
private void replaceTop ( int topOfStack ) { stack[stackSize - 1] = topOfStack ; } 
public JsonWriter name ( String name ) throws IOException { if ( name == null ) { throw new NullPointerException ( " name == null " ) ; } if ( deferredName != null ) { throw new IllegalStateException ( ) ; } if ( stackSize == 0 ) { throw new IllegalStateException ( " JsonWriter is closed. " ) ; } deferredName = name ; return this ; } 
private void writeDeferredName ( ) throws IOException { if ( deferredName != null ) { beforeName ( ) ; string ( deferredName ) ; deferredName = null ; } } 
public JsonWriter nullValue ( ) throws IOException { if ( deferredName != null ) { if ( serializeNulls ) { writeDeferredName ( ) ; } else { deferredName = null ; return this ; } } beforeValue ( ) ; out.write ( " null " ) ; return this ; }
public JsonWriter value ( boolean value ) throws IOException { writeDeferredName ( ) ; beforeValue ( ) ; out.write ( value ? " true " : " false " ) ; return this ; } 
public JsonWriter value ( double value ) throws IOException { writeDeferredName ( ) ; if ( !lenient && ( Double.isNaN ( value ) || Double.isInfinite ( value ) ) ) { throw new IllegalArgumentException ( " Numeric values must be finite , but was " + value ) ; } beforeValue ( ) ; out.append ( Double.toString ( value ) ) ; return this ; }
public JsonWriter value ( long value ) throws IOException { writeDeferredName ( ) ; beforeValue ( ) ; out.write ( Long.toString ( value ) ) ; return this ; } 
public void flush ( ) throws IOException { if ( stackSize == 0 ) { throw new IllegalStateException ( " JsonWriter is closed. " ) ; } out.flush ( ) ; }
public void close ( ) throws IOException { out.close ( ) ; int size = stackSize ; if ( size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT ) { throw new IOException ( " Incomplete document " ) ; } stackSize = 0 ; } 
private void newline ( ) throws IOException { if ( indent == null ) { return ; } out.write ( " \n " ) ; for ( int i = 1 , size = stackSize ; i < size ; i++ ) { out.write ( indent ) ; } } 
private void beforeName ( ) throws IOException { int context = peek ( ) ; if ( context == NONEMPTY_OBJECT ) { out.write ( ' , ' ) ; } else if ( context != EMPTY_OBJECT ) { throw new IllegalStateException ( " Nesting problem. " ) ; } newline ( ) ; replaceTop ( DANGLING_NAME ) ; } 
public final void toJson ( Writer out , T value ) throws IOException { JsonWriter writer = new JsonWriter ( out ) ; write ( writer , value ) ; } 
public void write ( JsonWriter out , T value ) throws IOException { if ( value == null ) { out.nullValue ( ) ; } else { TypeAdapter.this.write ( out , value ) ; } } 
public final String toJson ( T value ) { StringWriter stringWriter = new StringWriter ( ) ; try { toJson ( stringWriter , value ) ; } catch ( IOException e ) { throw new AssertionError ( e ) ; } return stringWriter.toString ( ) ; }
public final JsonElement toJsonTree ( T value ) { try { JsonTreeWriter jsonWriter = new JsonTreeWriter ( ) ; write ( jsonWriter , value ) ; return jsonWriter.get ( ) ; } catch ( IOException e ) { throw new JsonIOException ( e ) ; } } 
public final T fromJson ( Reader in ) throws IOException { JsonReader reader = new JsonReader ( in ) ; return read ( reader ) ; } 
public final T fromJson ( String json ) throws IOException { return fromJson ( new StringReader ( json ) ) ; } 
public final T fromJsonTree ( JsonElement jsonTree ) { try { JsonReader jsonReader = new JsonTreeReader ( jsonTree ) ; return read ( jsonReader ) ; } catch ( IOException e ) { throw new JsonIOException ( e ) ; } } 
static < T > Optional < T > withType ( ) { return ( Optional < T > ) INSTANCE ; } 
public boolean isPresent ( ) { return false ; } 
public T or ( T defaultValue ) { return checkNotNull ( defaultValue , " use Optional.orNull ( ) instead of Optional.or ( null ) " ) ; } 
public Optional < T > or ( Optional < ? extends T > secondChoice ) { return ( Optional < T > ) checkNotNull ( secondChoice ) ; } 
public T or ( Supplier < ? extends T > supplier ) { return checkNotNull ( supplier.get ( ) , " use Optional.orNull ( ) instead of a Supplier that returns null " ) ; } 
public Set < T > asSet ( ) { return Collections.emptySet ( ) ; } 
public < V > Optional < V > transform ( Function < ? super T , V > function ) { checkNotNull ( function ) ; return Optional.absent ( ) ; } 
private Object readResolve ( ) { return INSTANCE ; }
private boolean tryToComputeNext ( ) { state = State.FAILED ; next = computeNext ( ) ; if ( state != State.DONE ) { state = State.READY ; return true ; } return false ; }
public final T next ( ) { if ( !hasNext ( ) ) { throw new NoSuchElementException ( ) ; } state = State.NOT_READY ; T result = next ; next = null ; return result ; } 
public static String toLowerCase ( CharSequence chars ) { if ( chars instanceof String ) { return toLowerCase ( ( String ) chars ) ; } char[] newChars = new char[chars.length ( ) ] ; for ( int i = 0 ; i < newChars.length ; i++ ) { newChars[i] = toLowerCase ( chars.charAt ( i ) ) ; } return String.valueOf ( newChars ) ; } 
public static char toLowerCase ( char c ) { return isUpperCase ( c ) ? ( char ) ( c ^ CASE_MASK ) : c ; } 
public static String toUpperCase ( CharSequence chars ) { if ( chars instanceof String ) { return toUpperCase ( ( String ) chars ) ; } char[] newChars = new char[chars.length ( ) ] ; for ( int i = 0 ; i < newChars.length ; i++ ) { newChars[i] = toUpperCase ( chars.charAt ( i ) ) ; } return String.valueOf ( newChars ) ; } 
public static char toUpperCase ( char c ) { return isLowerCase ( c ) ? ( char ) ( c ^ CASE_MASK ) : c ; } 
public static boolean isLowerCase ( char c ) { return ( c > = 'a' ) && ( c < = 'z' ) ; } 
public static boolean isUpperCase ( char c ) { return ( c > = 'A' ) && ( c < = 'Z' ) ; } 
public static String truncate ( CharSequence seq , int maxLength , String truncationIndicator ) { checkNotNull ( seq ) ; int truncationLength = maxLength - truncationIndicator.length ( ) ; checkArgument ( truncationLength > = 0 , " maxLength ( %s ) must be > = length of the truncation indicator ( %s ) " , maxLength , truncationIndicator.length ( ) ) ; if ( seq.length ( ) < = maxLength ) { String string = seq.toString ( ) ; if ( string.length ( ) < = maxLength ) { return string ; } seq = string ; } return new StringBuilder ( maxLength ) .append ( seq , 0 , truncationLength ) .append ( truncationIndicator ) .toString ( ) ; } 
private static int getAlphaIndex ( char c ) { return ( char ) ( ( c | CASE_MASK ) - 'a' ) ; } 
public final String to ( CaseFormat format , String str ) { checkNotNull ( format ) ; checkNotNull ( str ) ; return ( format == this ) ? str : convert ( format , str ) ; } 
public Converter < String , String > converterTo ( CaseFormat targetFormat ) { return new StringConverter ( this , targetFormat ) ; } 
protected String doForward ( String s ) { return sourceFormat.to ( targetFormat , s ) ; } 
protected String doBackward ( String s ) { return targetFormat.to ( sourceFormat , s ) ; } 
String normalizeFirstWord ( String word ) { return normalizeWord ( word ) ; }
private static String firstCharOnlyToUpper ( String word ) { return word.isEmpty ( ) ? word : Ascii.toUpperCase ( word.charAt ( 0 ) ) + Ascii.toLowerCase ( word.substring ( 1 ) ) ; } 
String normalizeWord ( String word ) { return Ascii.toLowerCase ( word ) ; } 
String convert ( CaseFormat format , String s ) { if ( format == LOWER_UNDERSCORE ) { return s.replace ( '-' , '_' ) ; } if ( format == UPPER_UNDERSCORE ) { return Ascii.toUpperCase ( s.replace ( '-' , '_' ) ) ; } return super.convert ( format , s ) ; } 
String convert ( CaseFormat format , String s ) { if ( format == LOWER_HYPHEN ) { return s.replace ( '_' , '-' ) ; } if ( format == UPPER_UNDERSCORE ) { return Ascii.toUpperCase ( s ) ; } return super.convert ( format , s ) ; } 
String normalizeWord ( String word ) { return firstCharOnlyToUpper ( word ) ; } 
String normalizeFirstWord ( String word ) { return Ascii.toLowerCase ( word ) ; } 
String normalizeWord ( String word ) { return Ascii.toUpperCase ( word ) ; } 
String convert ( CaseFormat format , String s ) { if ( format == LOWER_HYPHEN ) { return Ascii.toLowerCase ( s.replace ( '_' , '-' ) ) ; } if ( format == LOWER_UNDERSCORE ) { return Ascii.toLowerCase ( s ) ; } return super.convert ( format , s ) ; } 
public static CharMatcher any ( ) { return Any.INSTANCE ; } 
public static CharMatcher none ( ) { return None.INSTANCE ; } 
public static CharMatcher whitespace ( ) { return Whitespace.INSTANCE ; }
public static CharMatcher noneOf ( CharSequence sequence ) { return anyOf ( sequence ) .negate ( ) ; } 
public static CharMatcher inRange ( final char startInclusive , final char endInclusive ) { return new InRange ( startInclusive , endInclusive ) ; } 
public static CharMatcher forPredicate ( final Predicate < ? super Character > predicate ) { return predicate instanceof CharMatcher ? ( CharMatcher ) predicate : new ForPredicate ( predicate ) ; } 
public CharMatcher negate ( ) { return new Negated ( this ) ; } 
public CharMatcher and ( CharMatcher other ) { return new And ( this , other ) ; } 
public CharMatcher or ( CharMatcher other ) { return new Or ( this , other ) ; } 
public CharMatcher precomputed ( ) { return Platform.precomputeCharMatcher ( this ) ; } 
private static boolean isSmall ( int totalCharacters , int tableLength ) { return totalCharacters < = SmallCharMatcher.MAX_SIZE && tableLength > ( totalCharacters * 4 * Character.SIZE ) ; }
void setBits ( BitSet table ) { for ( int c = Character.MAX_VALUE ; c > = Character.MIN_VALUE ; c-- ) { if ( matches ( ( char ) c ) ) { table.set ( c ) ; } } } 
public boolean matchesAnyOf ( CharSequence sequence ) { return !matchesNoneOf ( sequence ) ; } 
public boolean matchesAllOf ( CharSequence sequence ) { for ( int i = sequence.length ( ) - 1 ; i > = 0 ; i-- ) { if ( !matches ( sequence.charAt ( i ) ) ) { return false ; } } return true ; } 
public boolean matchesNoneOf ( CharSequence sequence ) { return indexIn ( sequence ) == -1 ; } 
public int indexIn ( CharSequence sequence ) { return indexIn ( sequence , 0 ) ; } 
public int indexIn ( CharSequence sequence , int start ) { int length = sequence.length ( ) ; checkPositionIndex ( start , length ) ; for ( int i = start ; i < length ; i++ ) { if ( matches ( sequence.charAt ( i ) ) ) { return i ; } } return -1 ; } 
public int lastIndexIn ( CharSequence sequence ) { for ( int i = sequence.length ( ) - 1 ; i > = 0 ; i-- ) { if ( matches ( sequence.charAt ( i ) ) ) { return i ; } } return -1 ; } 
public int countIn ( CharSequence sequence ) { int count = 0 ; for ( int i = 0 ; i < sequence.length ( ) ; i++ ) { if ( matches ( sequence.charAt ( i ) ) ) { count++ ; } } return count ; } 
public String retainFrom ( CharSequence sequence ) { return negate ( ) .removeFrom ( sequence ) ; } 
public String replaceFrom ( CharSequence sequence , char replacement ) { String string = sequence.toString ( ) ; int pos = indexIn ( string ) ; if ( pos == -1 ) { return string ; } char[] chars = string.toCharArray ( ) ; chars[pos] = replacement ; for ( int i = pos + 1 ; i < chars.length ; i++ ) { if ( matches ( chars[i] ) ) { chars[i] = replacement ; } } return new String ( chars ) ; } 
public String trimLeadingFrom ( CharSequence sequence ) { int len = sequence.length ( ) ; for ( int first = 0 ; first < len ; first++ ) { if ( !matches ( sequence.charAt ( first ) ) ) { return sequence.subSequence ( first , len ) .toString ( ) ; } } return " " ; } 
public String trimTrailingFrom ( CharSequence sequence ) { int len = sequence.length ( ) ; for ( int last = len - 1 ; last > = 0 ; last-- ) { if ( !matches ( sequence.charAt ( last ) ) ) { return sequence.subSequence ( 0 , last + 1 ) .toString ( ) ; } } return " " ; } 
public boolean apply ( Character character ) { return matches ( character ) ; } 
private static String showCharacter ( char c ) { String hex = " 0123456789ABCDEF " ; char[] tmp = { '\\' , 'u' , '\0' , '\0' , '\0' , '\0' } ; for ( int i = 0 ; i < 4 ; i++ ) { tmp[5 - i] = hex.charAt ( c & 0xF ) ; c = ( char ) ( c > > 4 ) ; } return String.copyValueOf ( tmp ) ; }
public final CharMatcher precomputed ( ) { return this ; } 
public CharMatcher negate ( ) { return new NegatedFastMatcher ( this ) ; } 
public boolean matches ( char c ) { return table.get ( c ) ; }
void setBits ( BitSet bitSet ) { bitSet.or ( table ) ; } 
public boolean matches ( char c ) { return true ; } 
public int indexIn ( CharSequence sequence ) { return ( sequence.length ( ) == 0 ) ? -1 : 0 ; } 
public int indexIn ( CharSequence sequence , int start ) { int length = sequence.length ( ) ; checkPositionIndex ( start , length ) ; return ( start == length ) ? -1 : start ; } 
public int lastIndexIn ( CharSequence sequence ) { return sequence.length ( ) - 1 ; } 
public boolean matchesAllOf ( CharSequence sequence ) { checkNotNull ( sequence ) ; return true ; } 
public boolean matchesNoneOf ( CharSequence sequence ) { return sequence.length ( ) == 0 ; } 
public String removeFrom ( CharSequence sequence ) { checkNotNull ( sequence ) ; return " " ; } 
public String replaceFrom ( CharSequence sequence , char replacement ) { char[] array = new char[sequence.length ( ) ] ; Arrays.fill ( array , replacement ) ; return new String ( array ) ; } 
public String replaceFrom ( CharSequence sequence , CharSequence replacement ) { StringBuilder result = new StringBuilder ( sequence.length ( ) * replacement.length ( ) ) ; for ( int i = 0 ; i < sequence.length ( ) ; i++ ) { result.append ( replacement ) ; } return result.toString ( ) ; } 
public String collapseFrom ( CharSequence sequence , char replacement ) { return ( sequence.length ( ) == 0 ) ? " " : String.valueOf ( replacement ) ; } 
public String trimFrom ( CharSequence sequence ) { checkNotNull ( sequence ) ; return " " ; } 
public int countIn ( CharSequence sequence ) { return sequence.length ( ) ; } 
public CharMatcher and ( CharMatcher other ) { return checkNotNull ( other ) ; } 
public CharMatcher or ( CharMatcher other ) { checkNotNull ( other ) ; return this ; } 
public CharMatcher negate ( ) { return none ( ) ; } 
public boolean matches ( char c ) { return false ; } 
public int indexIn ( CharSequence sequence ) { checkNotNull ( sequence ) ; return -1 ; } 
public int indexIn ( CharSequence sequence , int start ) { int length = sequence.length ( ) ; checkPositionIndex ( start , length ) ; return -1 ; } 
public int lastIndexIn ( CharSequence sequence ) { checkNotNull ( sequence ) ; return -1 ; } 
public boolean matchesAllOf ( CharSequence sequence ) { return sequence.length ( ) == 0 ; } 
public boolean matchesNoneOf ( CharSequence sequence ) { checkNotNull ( sequence ) ; return true ; } 
public String removeFrom ( CharSequence sequence ) { return sequence.toString ( ) ; } 
public String replaceFrom ( CharSequence sequence , char replacement ) { return sequence.toString ( ) ; } 
public String replaceFrom ( CharSequence sequence , CharSequence replacement ) { checkNotNull ( replacement ) ; return sequence.toString ( ) ; } 
public String collapseFrom ( CharSequence sequence , char replacement ) { return sequence.toString ( ) ; } 
public String trimFrom ( CharSequence sequence ) { return sequence.toString ( ) ; } 
public String trimLeadingFrom ( CharSequence sequence ) { return sequence.toString ( ) ; } 
public String trimTrailingFrom ( CharSequence sequence ) { return sequence.toString ( ) ; } 
public int countIn ( CharSequence sequence ) { checkNotNull ( sequence ) ; return 0 ; } 
public CharMatcher and ( CharMatcher other ) { checkNotNull ( other ) ; return this ; } 
public CharMatcher or ( CharMatcher other ) { return checkNotNull ( other ) ; } 
public CharMatcher negate ( ) { return any ( ) ; } 
public boolean matches ( char c ) { return TABLE.charAt ( ( MULTIPLIER * c ) > > > SHIFT ) == c ; } 
void setBits ( BitSet table ) { for ( int i = 0 ; i < TABLE.length ( ) ; i++ ) { table.set ( TABLE.charAt ( i ) ) ; } } 
public boolean matches ( char c ) { return c < = '\u007f' ; }
public boolean matches ( char c ) { int index = Arrays.binarySearch ( rangeStarts , c ) ; if ( index > = 0 ) { return true ; } else { index = ~index - 1 ; return index > = 0 && c < = rangeEnds[index] ; } } 
private static char[] zeroes ( ) { return ZEROES.toCharArray ( ) ; } 
private static char[] nines ( ) { char[] nines = new char[ZEROES.length ( ) ] ; for ( int i = 0 ; i < ZEROES.length ( ) ; i++ ) { nines[i] = ( char ) ( ZEROES.charAt ( i ) + 9 ) ; } return nines ; } 
public boolean matches ( char c ) { return Character.isDigit ( c ) ; } 
public boolean matches ( char c ) { return Character.isLetter ( c ) ; }
public boolean matches ( char c ) { return Character.isLetterOrDigit ( c ) ; }
public boolean matches ( char c ) { return Character.isUpperCase ( c ) ; }
public boolean matches ( char c ) { return Character.isLowerCase ( c ) ; }
public boolean matches ( char c ) { return c < = '\u001f' || ( c > = '\u007f' && c < = '\u009f' ) ; }
public boolean matches ( char c ) { return !original.matches ( c ) ; } 
public boolean matchesAllOf ( CharSequence sequence ) { return original.matchesNoneOf ( sequence ) ; } 
public boolean matchesNoneOf ( CharSequence sequence ) { return original.matchesAllOf ( sequence ) ; } 
public int countIn ( CharSequence sequence ) { return sequence.length ( ) - original.countIn ( sequence ) ; } 
void setBits ( BitSet table ) { BitSet tmp = new BitSet ( ) ; original.setBits ( tmp ) ; tmp.flip ( Character.MIN_VALUE , Character.MAX_VALUE + 1 ) ; table.or ( tmp ) ; } 
public CharMatcher negate ( ) { return original ; } 
public boolean matches ( char c ) { return first.matches ( c ) && second.matches ( c ) ; }
void setBits ( BitSet table ) { BitSet tmp1 = new BitSet ( ) ; first.setBits ( tmp1 ) ; BitSet tmp2 = new BitSet ( ) ; second.setBits ( tmp2 ) ; tmp1.and ( tmp2 ) ; table.or ( tmp1 ) ; } 
void setBits ( BitSet table ) { first.setBits ( table ) ; second.setBits ( table ) ; }
public boolean matches ( char c ) { return first.matches ( c ) || second.matches ( c ) ; } 
public boolean matches ( char c ) { return c == match ; }
public String replaceFrom ( CharSequence sequence , char replacement ) { return sequence.toString ( ) .replace ( match , replacement ) ; } 
public CharMatcher and ( CharMatcher other ) { return other.matches ( match ) ? this : none ( ) ; } 
public CharMatcher or ( CharMatcher other ) { return other.matches ( match ) ? other : super.or ( other ) ; } 
public CharMatcher negate ( ) { return isNot ( match ) ; } 
void setBits ( BitSet table ) { table.set ( match ) ; } 
public boolean matches ( char c ) { return c != match ; }
public CharMatcher and ( CharMatcher other ) { return other.matches ( match ) ? super.and ( other ) : other ; } 
public CharMatcher or ( CharMatcher other ) { return other.matches ( match ) ? any ( ) : this ; } 
void setBits ( BitSet table ) { table.set ( 0 , match ) ; table.set ( match + 1 , Character.MAX_VALUE + 1 ) ; } 
public CharMatcher negate ( ) { return is ( match ) ; } 
private static CharMatcher.IsEither isEither ( char c1 , char c2 ) { return new CharMatcher.IsEither ( c1 , c2 ) ; }
public boolean matches ( char c ) { return c == match1 || c == match2 ; } 
void setBits ( BitSet table ) { table.set ( match1 ) ; table.set ( match2 ) ; } 
public boolean matches ( char c ) { return Arrays.binarySearch ( chars , c ) > = 0 ; }
void setBits ( BitSet table ) { for ( char c : chars ) { table.set ( c ) ; } } 
public boolean matches ( char c ) { return startInclusive < = c && c < = endInclusive ; }
void setBits ( BitSet table ) { table.set ( startInclusive , endInclusive + 1 ) ; } 
public boolean matches ( char c ) { return predicate.apply ( c ) ; }
public boolean apply ( Character character ) { return predicate.apply ( checkNotNull ( character ) ) ; } 
public static CommonPattern compile ( String pattern ) { return Platform.compilePattern ( pattern ) ; }
public static boolean isPcreLike ( ) { return Platform.patternCompilerIsPcreLike ( ) ; } 
public final B convert ( @Nullable A a ) { return correctedDoForward ( a ) ; } 
B correctedDoForward ( @Nullable A a ) { if ( handleNullAutomatically ) { return a == null ? null : checkNotNull ( doForward ( a ) ) ; } else { return doForward ( a ) ; } } 
A correctedDoBackward ( @Nullable B b ) { if ( handleNullAutomatically ) { return b == null ? null : checkNotNull ( doBackward ( b ) ) ; } else { return doBackward ( b ) ; } } 
public boolean hasNext ( ) { return fromIterator.hasNext ( ) ; } 
public B next ( ) { return convert ( fromIterator.next ( ) ) ; } 
public void remove ( ) { fromIterator.remove ( ) ; } 
public Converter < B , A > reverse ( ) { Converter < B , A > result = reverse ; return ( result == null ) ? reverse = new ReverseConverter < > ( this ) : result ; } 
protected A doForward ( B b ) { throw new AssertionError ( ) ; } 
protected B doBackward ( A a ) { throw new AssertionError ( ) ; } 
A correctedDoForward ( @Nullable B b ) { return original.correctedDoBackward ( b ) ; } 
B correctedDoBackward ( @Nullable A a ) { return original.correctedDoForward ( a ) ; } 
public Converter < A , B > reverse ( ) { return original ; } 
public final < C > Converter < A , C > andThen ( Converter < B , C > secondConverter ) { return doAndThen ( secondConverter ) ; }
 < C > Converter < A , C > doAndThen ( Converter < B , C > secondConverter ) { return new ConverterComposition < > ( this , checkNotNull ( secondConverter ) ) ; } 
protected C doForward ( A a ) { throw new AssertionError ( ) ; } 
protected A doBackward ( C c ) { throw new AssertionError ( ) ; } 
C correctedDoForward ( @Nullable A a ) { return second.correctedDoForward ( first.correctedDoForward ( a ) ) ; } 
A correctedDoBackward ( @Nullable C c ) { return first.correctedDoBackward ( second.correctedDoBackward ( c ) ) ; } 
public final B apply ( @Nullable A a ) { return convert ( a ) ; }
public static < A , B > Converter < A , B > from ( Function < ? super A , ? extends B > forwardFunction , Function < ? super B , ? extends A > backwardFunction ) { return new FunctionBasedConverter < > ( forwardFunction , backwardFunction ) ; }
protected B doForward ( A a ) { return forwardFunction.apply ( a ) ; } 
protected A doBackward ( B b ) { return backwardFunction.apply ( b ) ; } 
public static < T > Converter < T , T > identity ( ) { return ( IdentityConverter < T > ) IdentityConverter.INSTANCE ; }
protected T doForward ( T t ) { return t ; } 
protected T doBackward ( T t ) { return t ; } 
public IdentityConverter < T > reverse ( ) { return this ; } 
 < S > Converter < T , S > doAndThen ( Converter < T , S > otherConverter ) { return checkNotNull ( otherConverter , " otherConverter " ) ; } 
public static Field getField ( Enum < ? > enumValue ) { Class < ? > clazz = enumValue.getDeclaringClass ( ) ; try { return clazz.getDeclaredField ( enumValue.name ( ) ) ; } catch ( NoSuchFieldException impossible ) { throw new AssertionError ( impossible ) ; } }
public static < T extends Enum < T > > Optional < T > getIfPresent ( Class < T > enumClass , String value ) { checkNotNull ( enumClass ) ; checkNotNull ( value ) ; return Platform.getEnumIfPresent ( enumClass , value ) ; } 
private static < T extends Enum < T > > Map < String , WeakReference < ? extends Enum < ? > > > populateCache ( Class < T > enumClass ) { Map < String , WeakReference < ? extends Enum < ? > > > result = new HashMap < > ( ) ; for ( T enumInstance : EnumSet.allOf ( enumClass ) ) { result.put ( enumInstance.name ( ) , new WeakReference < Enum < ? > > ( enumInstance ) ) ; } enumConstantCache.put ( enumClass , result ) ; return result ; } 
static < T extends Enum < T > > Map < String , WeakReference < ? extends Enum < ? > > > getEnumConstants ( Class < T > enumClass ) { synchronized ( enumConstantCache ) { Map < String , WeakReference < ? extends Enum < ? > > > constants = enumConstantCache.get ( enumClass ) ; if ( constants == null ) { constants = populateCache ( enumClass ) ; } return constants ; } } 
public static < T extends Enum < T > > Converter < String , T > stringConverter ( final Class < T > enumClass ) { return new StringConverter < T > ( enumClass ) ; } 
protected T doForward ( String value ) { return Enum.valueOf ( enumClass , value ) ; } 
protected String doBackward ( T enumValue ) { return enumValue.name ( ) ; } 
public final boolean equivalent ( @Nullable T a , @Nullable T b ) { if ( a == b ) { return true ; } if ( a == null || b == null ) { return false ; } return doEquivalent ( a , b ) ; }
public final boolean test ( @Nullable T t , @Nullable T u ) { return equivalent ( t , u ) ; } 
public final int hash ( @Nullable T t ) { if ( t == null ) { return 0 ; } return doHash ( t ) ; } 
public final < F > Equivalence < F > onResultOf ( Function < F , ? extends T > function ) { return new FunctionalEquivalence < > ( function , this ) ; } 
public final < S extends T > Wrapper < S > wrap ( @Nullable S reference ) { return new Wrapper < S > ( this , reference ) ; } 
public T get ( ) { return reference ; } 
public final < S extends T > Equivalence < Iterable < S > > pairwise ( ) { return new PairwiseEquivalence < S > ( this ) ; }
public final Predicate < T > equivalentTo ( @Nullable T target ) { return new EquivalentToPredicate < T > ( this , target ) ; } 
public boolean apply ( @Nullable T input ) { return equivalence.equivalent ( input , target ) ; } 
public static Equivalence < Object > identity ( ) { return Identity.INSTANCE ; }
protected boolean doEquivalent ( Object a , Object b ) { return a.equals ( b ) ; } 
protected int doHash ( Object o ) { return o.hashCode ( ) ; } 
protected boolean doEquivalent ( Object a , Object b ) { return false ; } 
protected int doHash ( Object o ) { return System.identityHashCode ( o ) ; }
public void close ( ) { frqRef.enqueue ( ) ; cleanUp ( ) ; } 
private static Class < ? > loadFinalizer ( FinalizerLoader... loaders ) { for ( FinalizerLoader loader : loaders ) { Class < ? > finalizer = loader.loadFinalizer ( ) ; if ( finalizer != null ) { return finalizer ; } } throw new AssertionError ( ) ; } 
URLClassLoader newLoader ( URL base ) { return new URLClassLoader ( new URL[] { base } , null ) ; }
public Class < ? > loadFinalizer ( ) { try { return Class.forName ( FINALIZER_CLASS_NAME ) ; } catch ( ClassNotFoundException e ) { throw new AssertionError ( e ) ; } } 
static Method getStartFinalizer ( Class < ? > finalizer ) { try { return finalizer.getMethod ( " startFinalizer " , Class.class , ReferenceQueue.class , PhantomReference.class ) ; } catch ( NoSuchMethodException e ) { throw new AssertionError ( e ) ; } } 
protected boolean doEquivalent ( F a , F b ) { return resultEquivalence.equivalent ( function.apply ( a ) , function.apply ( b ) ) ; } 
protected int doHash ( F a ) { return resultEquivalence.hash ( function.apply ( a ) ) ; } 
public static Function < Object , String > toStringFunction ( ) { return ToStringFunction.INSTANCE ; }
public String apply ( Object o ) { checkNotNull ( o ) ; return o.toString ( ) ; } 
public static < E > Function < E , E > identity ( ) { return ( Function < E , E > ) IdentityFunction.INSTANCE ; }
public Object apply ( @Nullable Object o ) { return o ; } 
public static < K , V > Function < K , V > forMap ( Map < K , V > map ) { return new FunctionForMapNoDefault < > ( map ) ; }
public static < K , V > Function < K , V > forMap ( Map < K , ? extends V > map , @Nullable V defaultValue ) { return new ForMapWithDefault < > ( map , defaultValue ) ; } 
public V apply ( @Nullable K key ) { V result = map.get ( key ) ; checkArgument ( result != null || map.containsKey ( key ) , " Key '%s' not present in map " , key ) ; return result ; } 
public V apply ( @Nullable K key ) { V result = map.get ( key ) ; return ( result != null || map.containsKey ( key ) ) ? result : defaultValue ; }
public static < A , B , C > Function < A , C > compose ( Function < B , C > g , Function < A , ? extends B > f ) { return new FunctionComposition < > ( g , f ) ; }
public C apply ( @Nullable A a ) { return g.apply ( f.apply ( a ) ) ; } 
public static < T > Function < T , Boolean > forPredicate ( Predicate < T > predicate ) { return new PredicateFunction < T > ( predicate ) ; }
public Boolean apply ( @Nullable T t ) { return predicate.apply ( t ) ; } 
public static < E > Function < Object , E > constant ( @Nullable E value ) { return new ConstantFunction < E > ( value ) ; }
public E apply ( @Nullable Object from ) { return value ; } 
public static < T > Function < Object , T > forSupplier ( Supplier < T > supplier ) { return new SupplierFunction < T > ( supplier ) ; }
public T apply ( @Nullable Object input ) { return supplier.get ( ) ; } 
public void run ( ) { while ( true ) { try { if ( !cleanUp ( queue.remove ( ) ) ) { break ; } } catch ( InterruptedException e ) { } } }
public CommonMatcher matcher ( CharSequence t ) { return new JdkMatcher ( pattern.matcher ( t ) ) ; }
public String pattern ( ) { return pattern.pattern ( ) ; } 
public int flags ( ) { return pattern.flags ( ) ; } 
public boolean matches ( ) { return matcher.matches ( ) ; }
public boolean find ( ) { return matcher.find ( ) ; } 
public boolean find ( int index ) { return matcher.find ( index ) ; } 
public String replaceAll ( String replacement ) { return matcher.replaceAll ( replacement ) ; } 
public int end ( ) { return matcher.end ( ) ; } 
public int start ( ) { return matcher.start ( ) ; } 
public static Joiner on ( String separator ) { return new Joiner ( separator ) ; } 
public static Joiner on ( char separator ) { return new Joiner ( String.valueOf ( separator ) ) ; } 
public < A extends Appendable > A appendTo ( A appendable , Iterable < ? > parts ) throws IOException { return appendTo ( appendable , parts.iterator ( ) ) ; } 
public < A extends Appendable > A appendTo ( A appendable , Iterator < ? > parts ) throws IOException { checkNotNull ( appendable ) ; if ( parts.hasNext ( ) ) { appendable.append ( toString ( parts.next ( ) ) ) ; while ( parts.hasNext ( ) ) { appendable.append ( separator ) ; appendable.append ( toString ( parts.next ( ) ) ) ; } } return appendable ; } 
public final < A extends Appendable > A appendTo ( A appendable , Object[] parts ) throws IOException { return appendTo ( appendable , Arrays.asList ( parts ) ) ; } 
public final StringBuilder appendTo ( StringBuilder builder , Iterable < ? > parts ) { return appendTo ( builder , parts.iterator ( ) ) ; } 
public final StringBuilder appendTo ( StringBuilder builder , Iterator < ? > parts ) { try { appendTo ( ( Appendable ) builder , parts ) ; } catch ( IOException impossible ) { throw new AssertionError ( impossible ) ; } return builder ; } 
public final StringBuilder appendTo ( StringBuilder builder , Object[] parts ) { return appendTo ( builder , Arrays.asList ( parts ) ) ; } 
public final String join ( Iterable < ? > parts ) { return join ( parts.iterator ( ) ) ; } 
public final String join ( Iterator < ? > parts ) { return appendTo ( new StringBuilder ( ) , parts ) .toString ( ) ; } 
public final String join ( Object[] parts ) { return join ( Arrays.asList ( parts ) ) ; } 
public Joiner useForNull ( String nullText ) { throw new UnsupportedOperationException ( " already specified useForNull " ) ; }
public Joiner skipNulls ( ) { throw new UnsupportedOperationException ( " already specified useForNull " ) ; } 
public Joiner useForNull ( String nullText ) { throw new UnsupportedOperationException ( " already specified skipNulls " ) ; } 
public MapJoiner withKeyValueSeparator ( String kvs ) { throw new UnsupportedOperationException ( " can't use .skipNulls ( ) with maps " ) ; } 
public MapJoiner withKeyValueSeparator ( char keyValueSeparator ) { return withKeyValueSeparator ( String.valueOf ( keyValueSeparator ) ) ; } 
public MapJoiner withKeyValueSeparator ( String keyValueSeparator ) { return new MapJoiner ( this , keyValueSeparator ) ; } 
public < A extends Appendable > A appendTo ( A appendable , Map < ? , ? > map ) throws IOException { return appendTo ( appendable , map.entrySet ( ) ) ; } 
public StringBuilder appendTo ( StringBuilder builder , Map < ? , ? > map ) { return appendTo ( builder , map.entrySet ( ) ) ; } 
public < A extends Appendable > A appendTo ( A appendable , Iterable < ? extends Entry < ? , ? > > entries ) throws IOException { return appendTo ( appendable , entries.iterator ( ) ) ; } 
public StringBuilder appendTo ( StringBuilder builder , Iterable < ? extends Entry < ? , ? > > entries ) { return appendTo ( builder , entries.iterator ( ) ) ; } 
public StringBuilder appendTo ( StringBuilder builder , Iterator < ? extends Entry < ? , ? > > entries ) { try { appendTo ( ( Appendable ) builder , entries ) ; } catch ( IOException impossible ) { throw new AssertionError ( impossible ) ; } return builder ; } 
public String join ( Map < ? , ? > map ) { return join ( map.entrySet ( ) ) ; } 
public String join ( Iterable < ? extends Entry < ? , ? > > entries ) { return join ( entries.iterator ( ) ) ; } 
public String join ( Iterator < ? extends Entry < ? , ? > > entries ) { return appendTo ( new StringBuilder ( ) , entries ) .toString ( ) ; } 
public MapJoiner useForNull ( String nullText ) { return new MapJoiner ( joiner.useForNull ( nullText ) , keyValueSeparator ) ; } 
public int size ( ) { return rest.length + 2 ; }
public static < T > T firstNonNull ( @Nullable T first , @Nullable T second ) { if ( first != null ) { return first ; } if ( second != null ) { return second ; } throw new NullPointerException ( " Both parameters are null " ) ; } 
public static ToStringHelper toStringHelper ( Object self ) { return new ToStringHelper ( self.getClass ( ) .getSimpleName ( ) ) ; } 
public static ToStringHelper toStringHelper ( Class < ? > clazz ) { return new ToStringHelper ( clazz.getSimpleName ( ) ) ; } 
public static ToStringHelper toStringHelper ( String className ) { return new ToStringHelper ( className ) ; } 
public ToStringHelper omitNullValues ( ) { omitNullValues = true ; return this ; } 
public ToStringHelper add ( String name , @Nullable Object value ) { return addHolder ( name , value ) ; }
public ToStringHelper addValue ( @Nullable Object value ) { return addHolder ( value ) ; }
private ValueHolder addHolder ( ) { ValueHolder valueHolder = new ValueHolder ( ) ; holderTail = holderTail.next = valueHolder ; return valueHolder ; } 
private ToStringHelper addHolder ( @Nullable Object value ) { ValueHolder valueHolder = addHolder ( ) ; valueHolder.value = value ; return this ; } 
private ToStringHelper addHolder ( String name , @Nullable Object value ) { ValueHolder valueHolder = addHolder ( ) ; valueHolder.value = value ; valueHolder.name = checkNotNull ( name ) ; return this ; } 
public static boolean equal ( @Nullable Object a , @Nullable Object b ) { return a == b || ( a != null && a.equals ( b ) ) ; } 
public static < T > Optional < T > absent ( ) { return Absent.withType ( ) ; }
public static < T > Optional < T > of ( T reference ) { return new Present < T > ( checkNotNull ( reference ) ) ; } 
public static < T > Optional < T > fromNullable ( @Nullable T nullableReference ) { return ( nullableReference == null ) ? Optional. < T > absent ( ) : new Present < T > ( nullableReference ) ; } 
public static < T > Optional < T > fromJavaUtil ( java.util.@Nullable Optional < T > javaUtilOptional ) { return ( javaUtilOptional == null ) ? null : fromNullable ( javaUtilOptional.orElse ( null ) ) ; } 
public static < T > java.util.@Nullable Optional < T > toJavaUtil ( @Nullable Optional < T > googleOptional ) { return googleOptional == null ? null : googleOptional.toJavaUtil ( ) ; } 
public java.util.Optional < T > toJavaUtil ( ) { return java.util.Optional.ofNullable ( orNull ( ) ) ; } 
protected T computeNext ( ) { while ( iterator.hasNext ( ) ) { Optional < ? extends T > optional = iterator.next ( ) ; if ( optional.isPresent ( ) ) { return optional.get ( ) ; } } return endOfData ( ) ; } 
protected boolean doEquivalent ( Iterable < T > iterableA , Iterable < T > iterableB ) { Iterator < T > iteratorA = iterableA.iterator ( ) ; Iterator < T > iteratorB = iterableB.iterator ( ) ; while ( iteratorA.hasNext ( ) && iteratorB.hasNext ( ) ) { if ( !elementEquivalence.equivalent ( iteratorA.next ( ) , iteratorB.next ( ) ) ) { return false ; } } return !iteratorA.hasNext ( ) && !iteratorB.hasNext ( ) ; } 
protected int doHash ( Iterable < T > iterable ) { int hash = 78721 ; for ( T element : iterable ) { hash = hash * 24943 + elementEquivalence.hash ( element ) ; } return hash ; } 
static long systemNanoTime ( ) { return System.nanoTime ( ) ; }
static CharMatcher precomputeCharMatcher ( CharMatcher matcher ) { return matcher.precomputedInternal ( ) ; } 
static < T extends Enum < T > > Optional < T > getEnumIfPresent ( Class < T > enumClass , String value ) { WeakReference < ? extends Enum < ? > > ref = Enums.getEnumConstants ( enumClass ) .get ( value ) ; return ref == null ? Optional. < T > absent ( ) : Optional.of ( enumClass.cast ( ref.get ( ) ) ) ; } 
static String formatCompact4Digits ( double value ) { return String.format ( Locale.ROOT , " %.4g " , value ) ; } 
static boolean stringIsNullOrEmpty ( @Nullable String string ) { return string == null || string.isEmpty ( ) ; } 
static String nullToEmpty ( @Nullable String string ) { return ( string == null ) ? " " : string ; } 
static String emptyToNull ( @Nullable String string ) { return stringIsNullOrEmpty ( string ) ? null : string ; } 
static CommonPattern compilePattern ( String pattern ) { Preconditions.checkNotNull ( pattern ) ; return patternCompiler.compile ( pattern ) ; } 
static boolean patternCompilerIsPcreLike ( ) { return patternCompiler.isPcreLike ( ) ; } 
private static PatternCompiler loadPatternCompiler ( ) { return new JdkPatternCompiler ( ) ; } 
private static void logPatternCompilerError ( ServiceConfigurationError e ) { logger.log ( Level.WARNING , " Error loading regex compiler , falling back to next option " , e ) ; } 
public CommonPattern compile ( String pattern ) { return new JdkPattern ( Pattern.compile ( pattern ) ) ; } 
public boolean isPcreLike ( ) { return true ; } 
static void checkGwtRpcEnabled ( ) { if ( !parseBoolean ( System.getProperty ( GWT_RPC_PROPERTY_NAME , " true " ) ) ) { throw new UnsupportedOperationException ( lenientFormat ( " We are removing GWT-RPC support for Guava types. You can temporarily reenable " + " support by setting the system property %s to true. For more about system " + " properties , see %s. For more about Guava's GWT-RPC support , see %s. " , GWT_RPC_PROPERTY_NAME , " https://stackoverflow.com/q/5189914/28465 " , " https://groups.google.com/d/msg/guava-announce/zHZTFg7YF3o/rQNnwdHeEwAJ " ) ) ; } } 
public static void checkArgument ( boolean expression ) { if ( !expression ) { throw new IllegalArgumentException ( ) ; } } 
public static void checkArgument ( boolean expression , @Nullable Object errorMessage ) { if ( !expression ) { throw new IllegalArgumentException ( String.valueOf ( errorMessage ) ) ; } } 
public static void checkArgument ( boolean expression , @Nullable String errorMessageTemplate , @Nullable Object@Nullable ... errorMessageArgs ) { if ( !expression ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , errorMessageArgs ) ) ; } } 
public static void checkArgument ( boolean b , @Nullable String errorMessageTemplate , char p1 ) { if ( !b ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 ) ) ; } } 
public static void checkArgument ( boolean b , @Nullable String errorMessageTemplate , int p1 ) { if ( !b ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 ) ) ; } } 
public static void checkArgument ( boolean b , @Nullable String errorMessageTemplate , long p1 ) { if ( !b ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 ) ) ; } } 
public static void checkArgument ( boolean b , @Nullable String errorMessageTemplate , @Nullable Object p1 ) { if ( !b ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 ) ) ; } } 
public static void checkState ( boolean expression ) { if ( !expression ) { throw new IllegalStateException ( ) ; } } 
public static void checkState ( boolean expression , @Nullable Object errorMessage ) { if ( !expression ) { throw new IllegalStateException ( String.valueOf ( errorMessage ) ) ; } } 
public static < T extends @NonNull Object > T checkNotNull ( T reference ) { if ( reference == null ) { throw new NullPointerException ( ) ; } return reference ; } 
public static < T extends @NonNull Object > T checkNotNull ( T reference , @Nullable Object errorMessage ) { if ( reference == null ) { throw new NullPointerException ( String.valueOf ( errorMessage ) ) ; } return reference ; } 
public static int checkElementIndex ( int index , int size ) { return checkElementIndex ( index , size , " index " ) ; } 
public static int checkElementIndex ( int index , int size , @Nullable String desc ) { if ( index < 0 || index > = size ) { throw new IndexOutOfBoundsException ( badElementIndex ( index , size , desc ) ) ; } return index ; } 
public static int checkPositionIndex ( int index , int size ) { return checkPositionIndex ( index , size , " index " ) ; } 
public static int checkPositionIndex ( int index , int size , @Nullable String desc ) { if ( index < 0 || index > size ) { throw new IndexOutOfBoundsException ( badPositionIndex ( index , size , desc ) ) ; } return index ; } 
public static void checkPositionIndexes ( int start , int end , int size ) { if ( start < 0 || end < start || end > size ) { throw new IndexOutOfBoundsException ( badPositionIndexes ( start , end , size ) ) ; } } 
default boolean test ( @Nullable T input ) { return apply ( input ) ; } 
public static < T > Predicate < T > alwaysTrue ( ) { return ObjectPredicate.ALWAYS_TRUE.withNarrowedType ( ) ; } 
public static < T > Predicate < T > alwaysFalse ( ) { return ObjectPredicate.ALWAYS_FALSE.withNarrowedType ( ) ; } 
public static < T > Predicate < T > isNull ( ) { return ObjectPredicate.IS_NULL.withNarrowedType ( ) ; } 
public static < T > Predicate < T > notNull ( ) { return ObjectPredicate.NOT_NULL.withNarrowedType ( ) ; } 
public static < T > Predicate < T > not ( Predicate < T > predicate ) { return new NotPredicate < T > ( predicate ) ; } 
public static < T > Predicate < T > and ( Iterable < ? extends Predicate < ? super T > > components ) { return new AndPredicate < T > ( defensiveCopy ( components ) ) ; } 
public static < T > Predicate < T > and ( Predicate < ? super T > ... components ) { return new AndPredicate < T > ( defensiveCopy ( components ) ) ; } 
public static < T > Predicate < T > and ( Predicate < ? super T > first , Predicate < ? super T > second ) { return new AndPredicate < T > ( Predicates. < T > asList ( checkNotNull ( first ) , checkNotNull ( second ) ) ) ; } 
public static < T > Predicate < T > or ( Iterable < ? extends Predicate < ? super T > > components ) { return new OrPredicate < T > ( defensiveCopy ( components ) ) ; } 
public static < T > Predicate < T > or ( Predicate < ? super T > ... components ) { return new OrPredicate < T > ( defensiveCopy ( components ) ) ; } 
public static < T > Predicate < T > or ( Predicate < ? super T > first , Predicate < ? super T > second ) { return new OrPredicate < T > ( Predicates. < T > asList ( checkNotNull ( first ) , checkNotNull ( second ) ) ) ; } 
public static < T > Predicate < T > equalTo ( @Nullable T target ) { return ( target == null ) ? Predicates. < T > isNull ( ) : new IsEqualToPredicate < T > ( target ) ; } 
public static Predicate < Object > instanceOf ( Class < ? > clazz ) { return new InstanceOfPredicate ( clazz ) ; } 
public static Predicate < Class < ? > > subtypeOf ( Class < ? > clazz ) { return new SubtypeOfPredicate ( clazz ) ; } 
public static < T > Predicate < T > in ( Collection < ? extends T > target ) { return new InPredicate < T > ( target ) ; } 
public static < A , B > Predicate < A > compose ( Predicate < B > predicate , Function < A , ? extends B > function ) { return new CompositionPredicate < > ( predicate , function ) ; } 
public static Predicate < CharSequence > containsPattern ( String pattern ) { return new ContainsPatternFromStringPredicate ( pattern ) ; } 
public static Predicate < CharSequence > contains ( Pattern pattern ) { return new ContainsPatternPredicate ( new JdkPattern ( pattern ) ) ; } 
 < T > Predicate < T > withNarrowedType ( ) { return ( Predicate < T > ) this ; } 
public boolean apply ( @Nullable Object o ) { return true ; } 
public boolean apply ( @Nullable T t ) { return !predicate.apply ( t ) ; }
public boolean apply ( @Nullable T t ) { for ( int i = 0 ; i < components.size ( ) ; i++ ) { if ( !components.get ( i ) .apply ( t ) ) { return false ; } } return true ; }
public boolean apply ( T t ) { return target.equals ( t ) ; }
private static < T > List < Predicate < ? super T > > asList ( Predicate < ? super T > first , Predicate < ? super T > second ) { return Arrays. < Predicate < ? super T > > asList ( first , second ) ; }
private static < T > List < T > defensiveCopy ( T... array ) { return defensiveCopy ( Arrays.asList ( array ) ) ; } 
static < T > List < T > defensiveCopy ( Iterable < T > iterable ) { ArrayList < T > list = new ArrayList < T > ( ) ; for ( T element : iterable ) { list.add ( checkNotNull ( element ) ) ; } return list ; } 
public boolean isPresent ( ) { return true ; } 
public T or ( T defaultValue ) { checkNotNull ( defaultValue , " use Optional.orNull ( ) instead of Optional.or ( null ) " ) ; return reference ; } 
public Optional < T > or ( Optional < ? extends T > secondChoice ) { checkNotNull ( secondChoice ) ; return this ; } 
public T or ( Supplier < ? extends T > supplier ) { checkNotNull ( supplier ) ; return reference ; } 
public T orNull ( ) { return reference ; } 
public Set < T > asSet ( ) { return Collections.singleton ( reference ) ; } 
public < V > Optional < V > transform ( Function < ? super T , V > function ) { return new Present < V > ( checkNotNull ( function.apply ( reference ) , " the Function passed to Optional.transform ( ) must not return null. " ) ) ; } 
static int smear ( int hashCode ) { return C2 * Integer.rotateLeft ( hashCode * C1 , 15 ) ; }
private boolean checkFilter ( int c ) { return 1 == ( 1 & ( filter > > c ) ) ; } 
static int chooseTableSize ( int setSize ) { if ( setSize == 1 ) { return 2 ; } int tableSize = Integer.highestOneBit ( setSize - 1 ) < < 1 ; while ( tableSize * DESIRED_LOAD_FACTOR < setSize ) { tableSize < < = 1 ; } return tableSize ; } 
void setBits ( BitSet table ) { if ( containsZero ) { table.set ( 0 ) ; } for ( char c : this.table ) { if ( c != 0 ) { table.set ( c ) ; } } } 
public static Splitter on ( char separator ) { return on ( CharMatcher.is ( separator ) ) ; } 
int separatorStart ( int start ) { return separatorMatcher.indexIn ( toSplit , start ) ; } 
int separatorEnd ( int separatorPosition ) { return separatorPosition + 1 ; } 
public int separatorStart ( int start ) { int separatorLength = separator.length ( ) ; positions: for ( int p = start , last = toSplit.length ( ) - separatorLength ; p < = last ; p++ ) { for ( int i = 0 ; i < separatorLength ; i++ ) { if ( toSplit.charAt ( i + p ) != separator.charAt ( i ) ) { continue positions ; } } return p ; } return -1 ; } 
public int separatorEnd ( int separatorPosition ) { return separatorPosition + separator.length ( ) ; } 
public static Splitter on ( Pattern separatorPattern ) { return on ( new JdkPattern ( separatorPattern ) ) ; } 
public int separatorStart ( int start ) { return matcher.find ( start ) ? matcher.start ( ) : -1 ; } 
public int separatorEnd ( int separatorPosition ) { return matcher.end ( ) ; } 
public static Splitter onPattern ( String separatorPattern ) { return on ( Platform.compilePattern ( separatorPattern ) ) ; } 
public int separatorStart ( int start ) { int nextChunkStart = start + length ; return ( nextChunkStart < toSplit.length ( ) ? nextChunkStart : -1 ) ; } 
public int separatorEnd ( int separatorPosition ) { return separatorPosition ; } 
public Splitter omitEmptyStrings ( ) { return new Splitter ( strategy , true , trimmer , limit ) ; } 
public Splitter limit ( int maxItems ) { checkArgument ( maxItems > 0 , " must be greater than zero: %s " , maxItems ) ; return new Splitter ( strategy , omitEmptyStrings , trimmer , maxItems ) ; } 
public Splitter trimResults ( ) { return trimResults ( CharMatcher.whitespace ( ) ) ; } 
public Splitter trimResults ( CharMatcher trimmer ) { checkNotNull ( trimmer ) ; return new Splitter ( strategy , omitEmptyStrings , trimmer , limit ) ; } 
public Iterator < String > iterator ( ) { return splittingIterator ( sequence ) ; } 
private Iterator < String > splittingIterator ( CharSequence sequence ) { return strategy.iterator ( this , sequence ) ; }
public List < String > splitToList ( CharSequence sequence ) { checkNotNull ( sequence ) ; Iterator < String > iterator = splittingIterator ( sequence ) ; List < String > result = new ArrayList < > ( ) ; while ( iterator.hasNext ( ) ) { result.add ( iterator.next ( ) ) ; } return Collections.unmodifiableList ( result ) ; } 
public MapSplitter withKeyValueSeparator ( String separator ) { return withKeyValueSeparator ( on ( separator ) ) ; } 
public MapSplitter withKeyValueSeparator ( char separator ) { return withKeyValueSeparator ( on ( separator ) ) ; } 
public MapSplitter withKeyValueSeparator ( Splitter keyValueSplitter ) { return new MapSplitter ( this , keyValueSplitter ) ; }
public String key ( ) { return key ; } 
public String value ( ) { return System.getProperty ( key ) ; } 
public static Stopwatch createUnstarted ( ) { return new Stopwatch ( ) ; } 
public static Stopwatch createUnstarted ( Ticker ticker ) { return new Stopwatch ( ticker ) ; } 
public static Stopwatch createStarted ( ) { return new Stopwatch ( ) .start ( ) ; } 
public static Stopwatch createStarted ( Ticker ticker ) { return new Stopwatch ( ticker ) .start ( ) ; } 
public boolean isRunning ( ) { return isRunning ; } 
public Stopwatch start ( ) { checkState ( !isRunning , " This stopwatch is already running. " ) ; isRunning = true ; startTick = ticker.read ( ) ; return this ; } 
public Stopwatch stop ( ) { long tick = ticker.read ( ) ; checkState ( isRunning , " This stopwatch is already stopped. " ) ; isRunning = false ; elapsedNanos += tick - startTick ; return this ; } 
public Stopwatch reset ( ) { elapsedNanos = 0 ; isRunning = false ; return this ; } 
private long elapsedNanos ( ) { return isRunning ? ticker.read ( ) - startTick + elapsedNanos : elapsedNanos ; } 
public long elapsed ( TimeUnit desiredUnit ) { return desiredUnit.convert ( elapsedNanos ( ) , NANOSECONDS ) ; } 
public Duration elapsed ( ) { return Duration.ofNanos ( elapsedNanos ( ) ) ; } 
public static String nullToEmpty ( @Nullable String string ) { return Platform.nullToEmpty ( string ) ; }
public static String emptyToNull ( @Nullable String string ) { return Platform.emptyToNull ( string ) ; } 
public static boolean isNullOrEmpty ( @Nullable String string ) { return Platform.stringIsNullOrEmpty ( string ) ; } 
public static String padStart ( String string , int minLength , char padChar ) { checkNotNull ( string ) ; if ( string.length ( ) > = minLength ) { return string ; } StringBuilder sb = new StringBuilder ( minLength ) ; for ( int i = string.length ( ) ; i < minLength ; i++ ) { sb.append ( padChar ) ; } sb.append ( string ) ; return sb.toString ( ) ; } 
public static String padEnd ( String string , int minLength , char padChar ) { checkNotNull ( string ) ; if ( string.length ( ) > = minLength ) { return string ; } StringBuilder sb = new StringBuilder ( minLength ) ; sb.append ( string ) ; for ( int i = string.length ( ) ; i < minLength ; i++ ) { sb.append ( padChar ) ; } return sb.toString ( ) ; } 
public static String commonPrefix ( CharSequence a , CharSequence b ) { checkNotNull ( a ) ; checkNotNull ( b ) ; int maxPrefixLength = Math.min ( a.length ( ) , b.length ( ) ) ; int p = 0 ; while ( p < maxPrefixLength && a.charAt ( p ) == b.charAt ( p ) ) { p++ ; } if ( validSurrogatePairAt ( a , p - 1 ) || validSurrogatePairAt ( b , p - 1 ) ) { p-- ; } return a.subSequence ( 0 , p ) .toString ( ) ; } 
public static String commonSuffix ( CharSequence a , CharSequence b ) { checkNotNull ( a ) ; checkNotNull ( b ) ; int maxSuffixLength = Math.min ( a.length ( ) , b.length ( ) ) ; int s = 0 ; while ( s < maxSuffixLength && a.charAt ( a.length ( ) - s - 1 ) == b.charAt ( b.length ( ) - s - 1 ) ) { s++ ; } if ( validSurrogatePairAt ( a , a.length ( ) - s - 1 ) || validSurrogatePairAt ( b , b.length ( ) - s - 1 ) ) { s-- ; } return a.subSequence ( a.length ( ) - s , a.length ( ) ) .toString ( ) ; } 
static boolean validSurrogatePairAt ( CharSequence string , int index ) { return index > = 0 && index < = ( string.length ( ) - 2 ) && Character.isHighSurrogate ( string.charAt ( index ) ) && Character.isLowSurrogate ( string.charAt ( index + 1 ) ) ; } 
private static String lenientToString ( @Nullable Object o ) { try { return String.valueOf ( o ) ; } catch ( Exception e ) { String objectToString = o.getClass ( ) .getName ( ) + '@' + Integer.toHexString ( System.identityHashCode ( o ) ) ; Logger.getLogger ( " com.google.common.base.Strings " ) .log ( WARNING , " Exception during lenientFormat for " + objectToString , e ) ; return " < " + objectToString + " threw " + e.getClass ( ) .getName ( ) + " > " ; } } 
public static < F , T > Supplier < T > compose ( Function < ? super F , T > function , Supplier < F > supplier ) { return new SupplierComposition < > ( function , supplier ) ; } 
public T get ( ) { return function.apply ( supplier.get ( ) ) ; } 
public static < T > Supplier < T > memoize ( Supplier < T > delegate ) { if ( delegate instanceof NonSerializableMemoizingSupplier || delegate instanceof MemoizingSupplier ) { return delegate ; } return delegate instanceof Serializable ? new MemoizingSupplier < T > ( delegate ) : new NonSerializableMemoizingSupplier < T > ( delegate ) ; }
public T get ( ) { if ( !initialized ) { synchronized ( this ) { if ( !initialized ) { T t = delegate.get ( ) ; value = t ; initialized = true ; return t ; } } } return value ; } 
public static < T > Supplier < T > memoizeWithExpiration ( Supplier < T > delegate , long duration , TimeUnit unit ) { return new ExpiringMemoizingSupplier < T > ( delegate , duration , unit ) ; } 
public static < T > Supplier < T > ofInstance ( @Nullable T instance ) { return new SupplierOfInstance < T > ( instance ) ; } 
public T get ( ) { return instance ; } 
public static < T > Supplier < T > synchronizedSupplier ( Supplier < T > delegate ) { return new ThreadSafeSupplier < T > ( delegate ) ; }
public T get ( ) { synchronized ( delegate ) { return delegate.get ( ) ; } } 
public static < T > Function < Supplier < T > , T > supplierFunction ( ) { @SuppressWarnings ( " unchecked " ) SupplierFunction < T > sf = ( SupplierFunction < T > ) SupplierFunctionImpl.INSTANCE ; return sf ; } 
public Object apply ( Supplier < Object > input ) { return input.get ( ) ; } 
public static < X extends Throwable > void throwIfInstanceOf ( Throwable throwable , Class < X > declaredType ) throws X { checkNotNull ( throwable ) ; if ( declaredType.isInstance ( throwable ) ) { throw declaredType.cast ( throwable ) ; } } 
public static < X extends Throwable > void propagateIfInstanceOf ( @Nullable Throwable throwable , Class < X > declaredType ) throws X { if ( throwable != null ) { throwIfInstanceOf ( throwable , declaredType ) ; } } 
public static void throwIfUnchecked ( Throwable throwable ) { checkNotNull ( throwable ) ; if ( throwable instanceof RuntimeException ) { throw ( RuntimeException ) throwable ; } if ( throwable instanceof Error ) { throw ( Error ) throwable ; } } 
public static void propagateIfPossible ( @Nullable Throwable throwable ) { if ( throwable != null ) { throwIfUnchecked ( throwable ) ; } } 
public static < X extends Throwable > void propagateIfPossible ( @Nullable Throwable throwable , Class < X > declaredType ) throws X { propagateIfInstanceOf ( throwable , declaredType ) ; propagateIfPossible ( throwable ) ; } 
public static RuntimeException propagate ( Throwable throwable ) { throwIfUnchecked ( throwable ) ; throw new RuntimeException ( throwable ) ; } 
public static < X extends Throwable > X getCauseAs ( Throwable throwable , Class < X > expectedCauseType ) { try { return expectedCauseType.cast ( throwable.getCause ( ) ) ; } catch ( ClassCastException e ) { e.initCause ( throwable ) ; throw e ; } } 
public static String getStackTraceAsString ( Throwable throwable ) { StringWriter stringWriter = new StringWriter ( ) ; throwable.printStackTrace ( new PrintWriter ( stringWriter ) ) ; return stringWriter.toString ( ) ; } 
public static List < StackTraceElement > lazyStackTrace ( Throwable throwable ) { return lazyStackTraceIsLazy ( ) ? jlaStackTrace ( throwable ) : unmodifiableList ( asList ( throwable.getStackTrace ( ) ) ) ; } 
public static boolean lazyStackTraceIsLazy ( ) { return getStackTraceElementMethod != null && getStackTraceDepthMethod != null ; } 
public StackTraceElement get ( int n ) { return ( StackTraceElement ) invokeAccessibleNonThrowingMethod ( getStackTraceElementMethod , jla , t , n ) ; } 
public int size ( ) { return ( Integer ) invokeAccessibleNonThrowingMethod ( getStackTraceDepthMethod , jla , t ) ; } 
private static Method getGetMethod ( ) { return getJlaMethod ( " getStackTraceElement " , Throwable.class , int.class ) ; } 
public static Ticker systemTicker ( ) { return SYSTEM_TICKER ; }
public long read ( ) { return Platform.systemNanoTime ( ) ; } 
public static boolean isWellFormed ( byte[] bytes ) { return isWellFormed ( bytes , 0 , bytes.length ) ; } 
public static boolean isWellFormed ( byte[] bytes , int off , int len ) { int end = off + len ; checkPositionIndexes ( off , end , bytes.length ) ; for ( int i = off ; i < end ; i++ ) { if ( bytes[i] < 0 ) { return isWellFormedSlowPath ( bytes , i , end ) ; } } return true ; } 
private static String unpairedSurrogateMsg ( int i ) { return " Unpaired surrogate at index " + i ; } 
public static void verify ( boolean expression ) { if ( !expression ) { throw new VerifyException ( ) ; } } 
public static < T > T verifyNotNull ( @Nullable T reference ) { return verifyNotNull ( reference , " expected a non-null reference " ) ; }
public void putAll ( Map < ? extends K , ? extends V > m ) { for ( Entry < ? extends K , ? extends V > entry : m.entrySet ( ) ) { put ( entry.getKey ( ) , entry.getValue ( ) ) ; } } 
public void invalidateAll ( Iterable < ? > keys ) { for ( Object key : keys ) { invalidate ( key ) ; } } 
public void recordHits ( int count ) { hitCount.add ( count ) ; } 
public void recordMisses ( int count ) { missCount.add ( count ) ; } 
public void recordLoadSuccess ( long loadTime ) { loadSuccessCount.increment ( ) ; totalLoadTime.add ( loadTime ) ; } 
public void recordLoadException ( long loadTime ) { loadExceptionCount.increment ( ) ; totalLoadTime.add ( loadTime ) ; } 
public void recordEviction ( ) { evictionCount.increment ( ) ; } 
public CacheStats snapshot ( ) { return new CacheStats ( negativeToMaxValue ( hitCount.sum ( ) ) , negativeToMaxValue ( missCount.sum ( ) ) , negativeToMaxValue ( loadSuccessCount.sum ( ) ) , negativeToMaxValue ( loadExceptionCount.sum ( ) ) , negativeToMaxValue ( totalLoadTime.sum ( ) ) , negativeToMaxValue ( evictionCount.sum ( ) ) ) ; } 
private static long negativeToMaxValue ( long value ) { return ( value > = 0 ) ? value : Long.MAX_VALUE ; } 
public void incrementBy ( StatsCounter other ) { CacheStats otherStats = other.snapshot ( ) ; hitCount.add ( otherStats.hitCount ( ) ) ; missCount.add ( otherStats.missCount ( ) ) ; loadSuccessCount.add ( otherStats.loadSuccessCount ( ) ) ; loadExceptionCount.add ( otherStats.loadExceptionCount ( ) ) ; totalLoadTime.add ( otherStats.totalLoadTime ( ) ) ; evictionCount.add ( otherStats.evictionCount ( ) ) ; } 
public V getUnchecked ( K key ) { try { return get ( key ) ; } catch ( ExecutionException e ) { throw new UncheckedExecutionException ( e.getCause ( ) ) ; } } 
public ImmutableMap < K , V > getAll ( Iterable < ? extends K > keys ) throws ExecutionException { Map < K , V > result = Maps.newLinkedHashMap ( ) ; for ( K key : keys ) { if ( !result.containsKey ( key ) ) { result.put ( key , get ( key ) ) ; } } return ImmutableMap.copyOf ( result ) ; } 
public final V apply ( K key ) { return getUnchecked ( key ) ; }
public CacheStats snapshot ( ) { return EMPTY_STATS ; } 
public StatsCounter get ( ) { return new SimpleStatsCounter ( ) ; } 
public int weigh ( Object key , Object value ) { return 1 ; } 
public long read ( ) { return 0 ; } 
public static CacheBuilder < Object , Object > newBuilder ( ) { return new CacheBuilder < > ( ) ; } 
public static CacheBuilder < Object , Object > from ( CacheBuilderSpec spec ) { return spec.toCacheBuilder ( ) .lenientParsing ( ) ; } 
public static CacheBuilder < Object , Object > from ( String spec ) { return from ( CacheBuilderSpec.parse ( spec ) ) ; } 
CacheBuilder < K , V > lenientParsing ( ) { strictParsing = false ; return this ; } 
CacheBuilder < K , V > keyEquivalence ( Equivalence < Object > equivalence ) { checkState ( keyEquivalence == null , " key equivalence was already set to %s " , keyEquivalence ) ; keyEquivalence = checkNotNull ( equivalence ) ; return this ; } 
Equivalence < Object > getKeyEquivalence ( ) { return MoreObjects.firstNonNull ( keyEquivalence , getKeyStrength ( ) .defaultEquivalence ( ) ) ; } 
CacheBuilder < K , V > valueEquivalence ( Equivalence < Object > equivalence ) { checkState ( valueEquivalence == null , " value equivalence was already set to %s " , valueEquivalence ) ; this.valueEquivalence = checkNotNull ( equivalence ) ; return this ; } 
Equivalence < Object > getValueEquivalence ( ) { return MoreObjects.firstNonNull ( valueEquivalence , getValueStrength ( ) .defaultEquivalence ( ) ) ; } 
public CacheBuilder < K , V > initialCapacity ( int initialCapacity ) { checkState ( this.initialCapacity == UNSET_INT , " initial capacity was already set to %s " , this.initialCapacity ) ; checkArgument ( initialCapacity > = 0 ) ; this.initialCapacity = initialCapacity ; return this ; } 
int getInitialCapacity ( ) { return ( initialCapacity == UNSET_INT ) ? DEFAULT_INITIAL_CAPACITY : initialCapacity ; } 
public CacheBuilder < K , V > concurrencyLevel ( int concurrencyLevel ) { checkState ( this.concurrencyLevel == UNSET_INT , " concurrency level was already set to %s " , this.concurrencyLevel ) ; checkArgument ( concurrencyLevel > 0 ) ; this.concurrencyLevel = concurrencyLevel ; return this ; } 
int getConcurrencyLevel ( ) { return ( concurrencyLevel == UNSET_INT ) ? DEFAULT_CONCURRENCY_LEVEL : concurrencyLevel ; } 
public CacheBuilder < K , V > maximumSize ( long maximumSize ) { checkState ( this.maximumSize == UNSET_INT , " maximum size was already set to %s " , this.maximumSize ) ; checkState ( this.maximumWeight == UNSET_INT , " maximum weight was already set to %s " , this.maximumWeight ) ; checkState ( this.weigher == null , " maximum size can not be combined with weigher " ) ; checkArgument ( maximumSize > = 0 , " maximum size must not be negative " ) ; this.maximumSize = maximumSize ; return this ; } 
public CacheBuilder < K , V > maximumWeight ( long maximumWeight ) { checkState ( this.maximumWeight == UNSET_INT , " maximum weight was already set to %s " , this.maximumWeight ) ; checkState ( this.maximumSize == UNSET_INT , " maximum size was already set to %s " , this.maximumSize ) ; this.maximumWeight = maximumWeight ; checkArgument ( maximumWeight > = 0 , " maximum weight must not be negative " ) ; return this ; } 
public < K1 extends K , V1 extends V > CacheBuilder < K1 , V1 > weigher ( Weigher < ? super K1 , ? super V1 > weigher ) { checkState ( this.weigher == null ) ; if ( strictParsing ) { checkState ( this.maximumSize == UNSET_INT , " weigher can not be combined with maximum size " , this.maximumSize ) ; } @SuppressWarnings ( " unchecked " ) CacheBuilder < K1 , V1 > me = ( CacheBuilder < K1 , V1 > ) this ; me.weigher = checkNotNull ( weigher ) ; return me ; } 
long getMaximumWeight ( ) { if ( expireAfterWriteNanos == 0 || expireAfterAccessNanos == 0 ) { return 0 ; } return ( weigher == null ) ? maximumSize : maximumWeight ; } 
 < K1 extends K , V1 extends V > Weigher < K1 , V1 > getWeigher ( ) { return ( Weigher < K1 , V1 > ) MoreObjects.firstNonNull ( weigher , OneWeigher.INSTANCE ) ; } 
public CacheBuilder < K , V > weakKeys ( ) { return setKeyStrength ( Strength.WEAK ) ; } 
CacheBuilder < K , V > setKeyStrength ( Strength strength ) { checkState ( keyStrength == null , " Key strength was already set to %s " , keyStrength ) ; keyStrength = checkNotNull ( strength ) ; return this ; } 
Strength getKeyStrength ( ) { return MoreObjects.firstNonNull ( keyStrength , Strength.STRONG ) ; } 
public CacheBuilder < K , V > weakValues ( ) { return setValueStrength ( Strength.WEAK ) ; } 
public CacheBuilder < K , V > softValues ( ) { return setValueStrength ( Strength.SOFT ) ; } 
CacheBuilder < K , V > setValueStrength ( Strength strength ) { checkState ( valueStrength == null , " Value strength was already set to %s " , valueStrength ) ; valueStrength = checkNotNull ( strength ) ; return this ; } 
Strength getValueStrength ( ) { return MoreObjects.firstNonNull ( valueStrength , Strength.STRONG ) ; } 
public CacheBuilder < K , V > expireAfterWrite ( java.time.Duration duration ) { return expireAfterWrite ( saturatedToNanos ( duration ) , TimeUnit.NANOSECONDS ) ; } 
public CacheBuilder < K , V > expireAfterWrite ( long duration , TimeUnit unit ) { checkState ( expireAfterWriteNanos == UNSET_INT , " expireAfterWrite was already set to %s ns " , expireAfterWriteNanos ) ; checkArgument ( duration > = 0 , " duration cannot be negative: %s %s " , duration , unit ) ; this.expireAfterWriteNanos = unit.toNanos ( duration ) ; return this ; } 
long getExpireAfterWriteNanos ( ) { return ( expireAfterWriteNanos == UNSET_INT ) ? DEFAULT_EXPIRATION_NANOS : expireAfterWriteNanos ; } 
public CacheBuilder < K , V > expireAfterAccess ( java.time.Duration duration ) { return expireAfterAccess ( saturatedToNanos ( duration ) , TimeUnit.NANOSECONDS ) ; } 
public CacheBuilder < K , V > expireAfterAccess ( long duration , TimeUnit unit ) { checkState ( expireAfterAccessNanos == UNSET_INT , " expireAfterAccess was already set to %s ns " , expireAfterAccessNanos ) ; checkArgument ( duration > = 0 , " duration cannot be negative: %s %s " , duration , unit ) ; this.expireAfterAccessNanos = unit.toNanos ( duration ) ; return this ; } 
long getExpireAfterAccessNanos ( ) { return ( expireAfterAccessNanos == UNSET_INT ) ? DEFAULT_EXPIRATION_NANOS : expireAfterAccessNanos ; } 
public CacheBuilder < K , V > refreshAfterWrite ( java.time.Duration duration ) { return refreshAfterWrite ( saturatedToNanos ( duration ) , TimeUnit.NANOSECONDS ) ; } 
public CacheBuilder < K , V > refreshAfterWrite ( long duration , TimeUnit unit ) { checkNotNull ( unit ) ; checkState ( refreshNanos == UNSET_INT , " refresh was already set to %s ns " , refreshNanos ) ; checkArgument ( duration > 0 , " duration must be positive: %s %s " , duration , unit ) ; this.refreshNanos = unit.toNanos ( duration ) ; return this ; } 
long getRefreshNanos ( ) { return ( refreshNanos == UNSET_INT ) ? DEFAULT_REFRESH_NANOS : refreshNanos ; } 
public CacheBuilder < K , V > ticker ( Ticker ticker ) { checkState ( this.ticker == null ) ; this.ticker = checkNotNull ( ticker ) ; return this ; } 
Ticker getTicker ( boolean recordsTime ) { if ( ticker != null ) { return ticker ; } return recordsTime ? Ticker.systemTicker ( ) : NULL_TICKER ; } 
public < K1 extends K , V1 extends V > CacheBuilder < K1 , V1 > removalListener ( RemovalListener < ? super K1 , ? super V1 > listener ) { checkState ( this.removalListener == null ) ; @SuppressWarnings ( " unchecked " ) CacheBuilder < K1 , V1 > me = ( CacheBuilder < K1 , V1 > ) this ; me.removalListener = checkNotNull ( listener ) ; return me ; } 
 < K1 extends K , V1 extends V > RemovalListener < K1 , V1 > getRemovalListener ( ) { return ( RemovalListener < K1 , V1 > ) MoreObjects.firstNonNull ( removalListener , NullListener.INSTANCE ) ; } 
public CacheBuilder < K , V > recordStats ( ) { statsCounterSupplier = CACHE_STATS_COUNTER ; return this ; } 
boolean isRecordingStats ( ) { return statsCounterSupplier == CACHE_STATS_COUNTER ; } 
Supplier < ? extends StatsCounter > getStatsCounterSupplier ( ) { return statsCounterSupplier ; } 
public < K1 extends K , V1 extends V > LoadingCache < K1 , V1 > build ( CacheLoader < ? super K1 , V1 > loader ) { checkWeightWithWeigher ( ) ; return new LocalCache.LocalLoadingCache < > ( this , loader ) ; } 
public < K1 extends K , V1 extends V > Cache < K1 , V1 > build ( ) { checkWeightWithWeigher ( ) ; checkNonLoadingCache ( ) ; return new LocalCache.LocalManualCache < > ( this ) ; } 
private void checkNonLoadingCache ( ) { checkState ( refreshNanos == UNSET_INT , " refreshAfterWrite requires a LoadingCache " ) ; } 
private static long saturatedToNanos ( java.time.Duration duration ) { try { return duration.toNanos ( ) ; } catch ( ArithmeticException tooBig ) { return duration.isNegative ( ) ? Long.MIN_VALUE : Long.MAX_VALUE ; } } 
public static CacheBuilderSpec disableCaching ( ) { return CacheBuilderSpec.parse ( " maximumSize=0 " ) ; } 
public String toParsableString ( ) { return specification ; } 
private static Long durationInNanos ( long duration , @Nullable TimeUnit unit ) { return ( unit == null ) ? null : unit.toNanos ( duration ) ; }
public void parse ( CacheBuilderSpec spec , String key , String value ) { checkArgument ( value != null && !value.isEmpty ( ) , " value of key %s omitted " , key ) ; try { parseInteger ( spec , Integer.parseInt ( value ) ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( format ( " key %s value set to %s , must be integer " , key , value ) , e ) ; } } 
public void parse ( CacheBuilderSpec spec , String key , String value ) { checkArgument ( value != null && !value.isEmpty ( ) , " value of key %s omitted " , key ) ; try { parseLong ( spec , Long.parseLong ( value ) ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( format ( " key %s value set to %s , must be integer " , key , value ) , e ) ; } } 
protected void parseInteger ( CacheBuilderSpec spec , int value ) { checkArgument ( spec.initialCapacity == null , " initial capacity was already set to " , spec.initialCapacity ) ; spec.initialCapacity = value ; } 
protected void parseLong ( CacheBuilderSpec spec , long value ) { checkArgument ( spec.maximumSize == null , " maximum size was already set to " , spec.maximumSize ) ; checkArgument ( spec.maximumWeight == null , " maximum weight was already set to " , spec.maximumWeight ) ; spec.maximumSize = value ; } 
protected void parseLong ( CacheBuilderSpec spec , long value ) { checkArgument ( spec.maximumWeight == null , " maximum weight was already set to " , spec.maximumWeight ) ; checkArgument ( spec.maximumSize == null , " maximum size was already set to " , spec.maximumSize ) ; spec.maximumWeight = value ; } 
protected void parseInteger ( CacheBuilderSpec spec , int value ) { checkArgument ( spec.concurrencyLevel == null , " concurrency level was already set to " , spec.concurrencyLevel ) ; spec.concurrencyLevel = value ; } 
public void parse ( CacheBuilderSpec spec , String key , @Nullable String value ) { checkArgument ( value == null , " key %s does not take values " , key ) ; checkArgument ( spec.keyStrength == null , " %s was already set to %s " , key , spec.keyStrength ) ; spec.keyStrength = strength ; } 
public void parse ( CacheBuilderSpec spec , String key , @Nullable String value ) { checkArgument ( value == null , " key %s does not take values " , key ) ; checkArgument ( spec.valueStrength == null , " %s was already set to %s " , key , spec.valueStrength ) ; spec.valueStrength = strength ; } 
public void parse ( CacheBuilderSpec spec , String key , @Nullable String value ) { checkArgument ( value == null , " recordStats does not take values " ) ; checkArgument ( spec.recordStats == null , " recordStats already set " ) ; spec.recordStats = true ; } 
protected void parseDuration ( CacheBuilderSpec spec , long duration , TimeUnit unit ) { checkArgument ( spec.accessExpirationTimeUnit == null , " expireAfterAccess already set " ) ; spec.accessExpirationDuration = duration ; spec.accessExpirationTimeUnit = unit ; } 
protected void parseDuration ( CacheBuilderSpec spec , long duration , TimeUnit unit ) { checkArgument ( spec.writeExpirationTimeUnit == null , " expireAfterWrite already set " ) ; spec.writeExpirationDuration = duration ; spec.writeExpirationTimeUnit = unit ; } 
protected void parseDuration ( CacheBuilderSpec spec , long duration , TimeUnit unit ) { checkArgument ( spec.refreshTimeUnit == null , " refreshAfterWrite already set " ) ; spec.refreshDuration = duration ; spec.refreshTimeUnit = unit ; } 
private static String format ( String format , Object... args ) { return String.format ( Locale.ROOT , format , args ) ; } 
public ListenableFuture < V > reload ( K key , V oldValue ) throws Exception { checkNotNull ( key ) ; checkNotNull ( oldValue ) ; return Futures.immediateFuture ( load ( key ) ) ; } 
public Map < K , V > loadAll ( Iterable < ? extends K > keys ) throws Exception { throw new UnsupportedLoadingOperationException ( ) ; } 
public static < K , V > CacheLoader < K , V > from ( Function < K , V > function ) { return new FunctionToCacheLoader < > ( function ) ; } 
public static < V > CacheLoader < Object , V > from ( Supplier < V > supplier ) { return new SupplierToCacheLoader < V > ( supplier ) ; } 
public V load ( K key ) { return computingFunction.apply ( checkNotNull ( key ) ) ; } 
public V load ( K key ) throws Exception { return loader.load ( key ) ; } 
public V call ( ) throws Exception { return loader.reload ( key , oldValue ) .get ( ) ; } 
public Map < K , V > loadAll ( Iterable < ? extends K > keys ) throws Exception { return loader.loadAll ( keys ) ; } 
public V load ( Object key ) { checkNotNull ( key ) ; return computingSupplier.get ( ) ; } 
public long requestCount ( ) { return saturatedAdd ( hitCount , missCount ) ; } 
public long hitCount ( ) { return hitCount ; } 
public double hitRate ( ) { long requestCount = requestCount ( ) ; return ( requestCount == 0 ) ? 1.0 : ( double ) hitCount / requestCount ; } 
public long missCount ( ) { return missCount ; } 
public double missRate ( ) { long requestCount = requestCount ( ) ; return ( requestCount == 0 ) ? 0.0 : ( double ) missCount / requestCount ; } 
public long loadCount ( ) { return saturatedAdd ( loadSuccessCount , loadExceptionCount ) ; } 
public long loadSuccessCount ( ) { return loadSuccessCount ; } 
public long loadExceptionCount ( ) { return loadExceptionCount ; } 
public double loadExceptionRate ( ) { long totalLoadCount = saturatedAdd ( loadSuccessCount , loadExceptionCount ) ; return ( totalLoadCount == 0 ) ? 0.0 : ( double ) loadExceptionCount / totalLoadCount ; } 
public long totalLoadTime ( ) { return totalLoadTime ; } 
public double averageLoadPenalty ( ) { long totalLoadCount = saturatedAdd ( loadSuccessCount , loadExceptionCount ) ; return ( totalLoadCount == 0 ) ? 0.0 : ( double ) totalLoadTime / totalLoadCount ; } 
public long evictionCount ( ) { return evictionCount ; } 
public CacheStats minus ( CacheStats other ) { return new CacheStats ( Math.max ( 0 , saturatedSubtract ( hitCount , other.hitCount ) ) , Math.max ( 0 , saturatedSubtract ( missCount , other.missCount ) ) , Math.max ( 0 , saturatedSubtract ( loadSuccessCount , other.loadSuccessCount ) ) , Math.max ( 0 , saturatedSubtract ( loadExceptionCount , other.loadExceptionCount ) ) , Math.max ( 0 , saturatedSubtract ( totalLoadTime , other.totalLoadTime ) ) , Math.max ( 0 , saturatedSubtract ( evictionCount , other.evictionCount ) ) ) ; } 
public CacheStats plus ( CacheStats other ) { return new CacheStats ( saturatedAdd ( hitCount , other.hitCount ) , saturatedAdd ( missCount , other.missCount ) , saturatedAdd ( loadSuccessCount , other.loadSuccessCount ) , saturatedAdd ( loadExceptionCount , other.loadExceptionCount ) , saturatedAdd ( totalLoadTime , other.totalLoadTime ) , saturatedAdd ( evictionCount , other.evictionCount ) ) ; } 
public V getIfPresent ( Object key ) { return delegate ( ) .getIfPresent ( key ) ; } 
public V get ( K key , Callable < ? extends V > valueLoader ) throws ExecutionException { return delegate ( ) .get ( key , valueLoader ) ; } 
public ImmutableMap < K , V > getAllPresent ( Iterable < ? > keys ) { return delegate ( ) .getAllPresent ( keys ) ; } 
public void put ( K key , V value ) { delegate ( ) .put ( key , value ) ; } 
public void putAll ( Map < ? extends K , ? extends V > m ) { delegate ( ) .putAll ( m ) ; } 
public void invalidate ( Object key ) { delegate ( ) .invalidate ( key ) ; } 
public void invalidateAll ( Iterable < ? > keys ) { delegate ( ) .invalidateAll ( keys ) ; } 
public void invalidateAll ( ) { delegate ( ) .invalidateAll ( ) ; } 
public long size ( ) { return delegate ( ) .size ( ) ; } 
public CacheStats stats ( ) { return delegate ( ) .stats ( ) ; } 
public ConcurrentMap < K , V > asMap ( ) { return delegate ( ) .asMap ( ) ; } 
public void cleanUp ( ) { delegate ( ) .cleanUp ( ) ; } 
protected final Cache < K , V > delegate ( ) { return delegate ; } 
public V get ( K key ) throws ExecutionException { return delegate ( ) .get ( key ) ; } 
public V getUnchecked ( K key ) { return delegate ( ) .getUnchecked ( key ) ; } 
public ImmutableMap < K , V > getAll ( Iterable < ? extends K > keys ) throws ExecutionException { return delegate ( ) .getAll ( keys ) ; } 
public V apply ( K key ) { return delegate ( ) .apply ( key ) ; } 
public void refresh ( K key ) { delegate ( ) .refresh ( key ) ; } 
protected final LoadingCache < K , V > delegate ( ) { return delegate ; } 
boolean evictsBySize ( ) { return maxWeight > = 0 ; } 
boolean customWeigher ( ) { return weigher != OneWeigher.INSTANCE ; } 
boolean expires ( ) { return expiresAfterWrite ( ) || expiresAfterAccess ( ) ; } 
boolean expiresAfterWrite ( ) { return expireAfterWriteNanos > 0 ; } 
boolean expiresAfterAccess ( ) { return expireAfterAccessNanos > 0 ; } 
boolean refreshes ( ) { return refreshNanos > 0 ; } 
boolean usesAccessQueue ( ) { return expiresAfterAccess ( ) || evictsBySize ( ) ; } 
boolean usesWriteQueue ( ) { return expiresAfterWrite ( ) ; } 
boolean recordsWrite ( ) { return expiresAfterWrite ( ) || refreshes ( ) ; } 
boolean recordsAccess ( ) { return expiresAfterAccess ( ) ; } 
boolean recordsTime ( ) { return recordsWrite ( ) || recordsAccess ( ) ; } 
boolean usesWriteEntries ( ) { return usesWriteQueue ( ) || recordsWrite ( ) ; } 
boolean usesAccessEntries ( ) { return usesAccessQueue ( ) || recordsAccess ( ) ; } 
boolean usesKeyReferences ( ) { return keyStrength != Strength.STRONG ; } 
boolean usesValueReferences ( ) { return valueStrength != Strength.STRONG ; } 
Equivalence < Object > defaultEquivalence ( ) { return Equivalence.equals ( ) ; } 
Equivalence < Object > defaultEquivalence ( ) { return Equivalence.identity ( ) ; } 
static EntryFactory getFactory ( Strength keyStrength , boolean usesAccessQueue , boolean usesWriteQueue ) { int flags = ( ( keyStrength == Strength.WEAK ) ? WEAK_MASK : 0 ) | ( usesAccessQueue ? ACCESS_MASK : 0 ) | ( usesWriteQueue ? WRITE_MASK : 0 ) ; return factories[flags] ; } 
 < K , V > void copyAccessEntry ( ReferenceEntry < K , V > original , ReferenceEntry < K , V > newEntry ) { newEntry.setAccessTime ( original.getAccessTime ( ) ) ; connectAccessOrder ( original.getPreviousInAccessQueue ( ) , newEntry ) ; connectAccessOrder ( newEntry , original.getNextInAccessQueue ( ) ) ; nullifyAccessOrder ( original ) ; } 
 < K , V > void copyWriteEntry ( ReferenceEntry < K , V > original , ReferenceEntry < K , V > newEntry ) { newEntry.setWriteTime ( original.getWriteTime ( ) ) ; connectWriteOrder ( original.getPreviousInWriteQueue ( ) , newEntry ) ; connectWriteOrder ( newEntry , original.getNextInWriteQueue ( ) ) ; nullifyWriteOrder ( original ) ; } 
public int getWeight ( ) { return 0 ; }
public boolean isLoading ( ) { return false ; }
public boolean isActive ( ) { return false ; } 
static < K , V > ValueReference < K , V > unset ( ) { return ( ValueReference < K , V > ) UNSET ; }
public int getHash ( ) { return 0 ; } 
public long getAccessTime ( ) { return 0 ; } 
public ReferenceEntry < Object , Object > getNextInAccessQueue ( ) { return this ; } 
public ReferenceEntry < Object , Object > getPreviousInAccessQueue ( ) { return this ; } 
public long getWriteTime ( ) { return 0 ; } 
public ReferenceEntry < Object , Object > getNextInWriteQueue ( ) { return this ; } 
public ReferenceEntry < Object , Object > getPreviousInWriteQueue ( ) { return this ; } 
static < K , V > ReferenceEntry < K , V > nullEntry ( ) { return ( ReferenceEntry < K , V > ) NullEntry.INSTANCE ; } 
public boolean offer ( Object o ) { return true ; } 
public int size ( ) { return 0 ; } 
public Iterator < Object > iterator ( ) { return ImmutableSet.of ( ) .iterator ( ) ; } 
static < E > Queue < E > discardingQueue ( ) { return ( Queue ) DISCARDING_QUEUE ; } 
public K getKey ( ) { return this.key ; } 
public ValueReference < K , V > getValueReference ( ) { return valueReference ; } 
public void setValueReference ( ValueReference < K , V > valueReference ) { this.valueReference = valueReference ; } 
public int getHash ( ) { return hash ; } 
public ReferenceEntry < K , V > getNext ( ) { return next ; } 
public long getAccessTime ( ) { return accessTime ; } 
public void setAccessTime ( long time ) { this.accessTime = time ; } 
public ReferenceEntry < K , V > getNextInAccessQueue ( ) { return nextAccess ; } 
public void setNextInAccessQueue ( ReferenceEntry < K , V > next ) { this.nextAccess = next ; } 
public ReferenceEntry < K , V > getPreviousInAccessQueue ( ) { return previousAccess ; } 
public void setPreviousInAccessQueue ( ReferenceEntry < K , V > previous ) { this.previousAccess = previous ; } 
public long getWriteTime ( ) { return writeTime ; } 
public void setWriteTime ( long time ) { this.writeTime = time ; } 
public ReferenceEntry < K , V > getNextInWriteQueue ( ) { return nextWrite ; } 
public void setNextInWriteQueue ( ReferenceEntry < K , V > next ) { this.nextWrite = next ; } 
public ReferenceEntry < K , V > getPreviousInWriteQueue ( ) { return previousWrite ; } 
public void setPreviousInWriteQueue ( ReferenceEntry < K , V > previous ) { this.previousWrite = previous ; } 
public K getKey ( ) { return get ( ) ; } 
public int getWeight ( ) { return 1 ; } 
public ReferenceEntry < K , V > getEntry ( ) { return entry ; } 
public ValueReference < K , V > copyFor ( ReferenceQueue < V > queue , V value , ReferenceEntry < K , V > entry ) { return new WeakValueReference < > ( queue , value , entry ) ; } 
public boolean isActive ( ) { return true ; } 
public V waitForValue ( ) { return get ( ) ; } 
public ValueReference < K , V > copyFor ( ReferenceQueue < V > queue , V value , ReferenceEntry < K , V > entry ) { return new SoftValueReference < > ( queue , value , entry ) ; } 
public V get ( ) { return referent ; }
public ValueReference < K , V > copyFor ( ReferenceQueue < V > queue , V value , ReferenceEntry < K , V > entry ) { return this ; } 
public int getWeight ( ) { return weight ; } 
public ValueReference < K , V > copyFor ( ReferenceQueue < V > queue , V value , ReferenceEntry < K , V > entry ) { return new WeightedWeakValueReference < > ( queue , value , entry , weight ) ; } 
public ValueReference < K , V > copyFor ( ReferenceQueue < V > queue , V value , ReferenceEntry < K , V > entry ) { return new WeightedSoftValueReference < > ( queue , value , entry , weight ) ; } 
static int rehash ( int h ) { h += ( h < < 15 ) ^ 0xffffcd7d ; h ^= ( h > > > 10 ) ; h += ( h < < 3 ) ; h ^= ( h > > > 6 ) ; h += ( h < < 2 ) + ( h < < 14 ) ; return h ^ ( h > > > 16 ) ; } 
ReferenceEntry < K , V > newEntry ( K key , int hash , @Nullable ReferenceEntry < K , V > next ) { Segment < K , V > segment = segmentFor ( hash ) ; segment.lock ( ) ; try { return segment.newEntry ( key , hash , next ) ; } finally { segment.unlock ( ) ; } } 
ReferenceEntry < K , V > copyEntry ( ReferenceEntry < K , V > original , ReferenceEntry < K , V > newNext ) { int hash = original.getHash ( ) ; return segmentFor ( hash ) .copyEntry ( original , newNext ) ; } 
ValueReference < K , V > newValueReference ( ReferenceEntry < K , V > entry , V value , int weight ) { int hash = entry.getHash ( ) ; return valueStrength.referenceValue ( segmentFor ( hash ) , entry , checkNotNull ( value ) , weight ) ; } 
int hash ( @Nullable Object key ) { int h = keyEquivalence.hash ( key ) ; return rehash ( h ) ; } 
void reclaimValue ( ValueReference < K , V > valueReference ) { ReferenceEntry < K , V > entry = valueReference.getEntry ( ) ; int hash = entry.getHash ( ) ; segmentFor ( hash ) .reclaimValue ( entry.getKey ( ) , hash , valueReference ) ; } 
void reclaimKey ( ReferenceEntry < K , V > entry ) { int hash = entry.getHash ( ) ; segmentFor ( hash ) .reclaimKey ( entry , hash ) ; } 
boolean isLive ( ReferenceEntry < K , V > entry , long now ) { return segmentFor ( entry.getHash ( ) ) .getLiveValue ( entry , now ) != null ; } 
Segment < K , V > segmentFor ( int hash ) { return segments[ ( hash > > > segmentShift ) & segmentMask] ; } 
Segment < K , V > createSegment ( int initialCapacity , long maxSegmentWeight , StatsCounter statsCounter ) { return new Segment < > ( this , initialCapacity , maxSegmentWeight , statsCounter ) ; } 
boolean isExpired ( ReferenceEntry < K , V > entry , long now ) { checkNotNull ( entry ) ; if ( expiresAfterAccess ( ) && ( now - entry.getAccessTime ( ) > = expireAfterAccessNanos ) ) { return true ; } if ( expiresAfterWrite ( ) && ( now - entry.getWriteTime ( ) > = expireAfterWriteNanos ) ) { return true ; } return false ; } 
static < K , V > void connectAccessOrder ( ReferenceEntry < K , V > previous , ReferenceEntry < K , V > next ) { previous.setNextInAccessQueue ( next ) ; next.setPreviousInAccessQueue ( previous ) ; } 
static < K , V > void nullifyAccessOrder ( ReferenceEntry < K , V > nulled ) { ReferenceEntry < K , V > nullEntry = nullEntry ( ) ; nulled.setNextInAccessQueue ( nullEntry ) ; nulled.setPreviousInAccessQueue ( nullEntry ) ; } 
static < K , V > void connectWriteOrder ( ReferenceEntry < K , V > previous , ReferenceEntry < K , V > next ) { previous.setNextInWriteQueue ( next ) ; next.setPreviousInWriteQueue ( previous ) ; } 
static < K , V > void nullifyWriteOrder ( ReferenceEntry < K , V > nulled ) { ReferenceEntry < K , V > nullEntry = nullEntry ( ) ; nulled.setNextInWriteQueue ( nullEntry ) ; nulled.setPreviousInWriteQueue ( nullEntry ) ; } 
void processPendingNotifications ( ) { RemovalNotification < K , V > notification ; while ( ( notification = removalNotificationQueue.poll ( ) ) != null ) { try { removalListener.onRemoval ( notification ) ; } catch ( Throwable e ) { logger.log ( Level.WARNING , " Exception thrown by removal listener " , e ) ; } } } 
final Segment < K , V > [] newSegmentArray ( int ssize ) { return new Segment[ssize] ; } 
AtomicReferenceArray < ReferenceEntry < K , V > > newEntryArray ( int size ) { return new AtomicReferenceArray < > ( size ) ; } 
void initTable ( AtomicReferenceArray < ReferenceEntry < K , V > > newTable ) { this.threshold = newTable.length ( ) * 3 / 4 ; if ( !map.customWeigher ( ) && this.threshold == maxSegmentWeight ) { this.threshold++ ; } this.table = newTable ; } 
ReferenceEntry < K , V > newEntry ( K key , int hash , @Nullable ReferenceEntry < K , V > next ) { return map.entryFactory.newEntry ( this , checkNotNull ( key ) , hash , next ) ; } 
void setValue ( ReferenceEntry < K , V > entry , K key , V value , long now ) { ValueReference < K , V > previous = entry.getValueReference ( ) ; int weight = map.weigher.weigh ( key , value ) ; checkState ( weight > = 0 , " Weights must be non-negative " ) ; ValueReference < K , V > valueReference = map.valueStrength.referenceValue ( this , entry , value , weight ) ; entry.setValueReference ( valueReference ) ; recordWrite ( entry , weight , now ) ; previous.notifyNewValue ( value ) ; } 
public void run ( ) { try { getAndRecordStats ( key , hash , loadingValueReference , loadingFuture ) ; } catch ( Throwable t ) { logger.log ( Level.WARNING , " Exception thrown during refresh " , t ) ; loadingValueReference.setException ( t ) ; } } 
void tryDrainReferenceQueues ( ) { if ( tryLock ( ) ) { try { drainReferenceQueues ( ) ; } finally { unlock ( ) ; } } } 
void drainReferenceQueues ( ) { if ( map.usesKeyReferences ( ) ) { drainKeyReferenceQueue ( ) ; } if ( map.usesValueReferences ( ) ) { drainValueReferenceQueue ( ) ; } } 
void drainKeyReferenceQueue ( ) { Reference < ? extends K > ref ; int i = 0 ; while ( ( ref = keyReferenceQueue.poll ( ) ) != null ) { @SuppressWarnings ( " unchecked " ) ReferenceEntry < K , V > entry = ( ReferenceEntry < K , V > ) ref ; map.reclaimKey ( entry ) ; if ( ++i == DRAIN_MAX ) { break ; } } } 
void drainValueReferenceQueue ( ) { Reference < ? extends V > ref ; int i = 0 ; while ( ( ref = valueReferenceQueue.poll ( ) ) != null ) { @SuppressWarnings ( " unchecked " ) ValueReference < K , V > valueReference = ( ValueReference < K , V > ) ref ; map.reclaimValue ( valueReference ) ; if ( ++i == DRAIN_MAX ) { break ; } } } 
void clearReferenceQueues ( ) { if ( map.usesKeyReferences ( ) ) { clearKeyReferenceQueue ( ) ; } if ( map.usesValueReferences ( ) ) { clearValueReferenceQueue ( ) ; } } 
void recordRead ( ReferenceEntry < K , V > entry , long now ) { if ( map.recordsAccess ( ) ) { entry.setAccessTime ( now ) ; } recencyQueue.add ( entry ) ; } 
void recordLockedRead ( ReferenceEntry < K , V > entry , long now ) { if ( map.recordsAccess ( ) ) { entry.setAccessTime ( now ) ; } accessQueue.add ( entry ) ; } 
void recordWrite ( ReferenceEntry < K , V > entry , int weight , long now ) { drainRecencyQueue ( ) ; totalWeight += weight ; if ( map.recordsAccess ( ) ) { entry.setAccessTime ( now ) ; } if ( map.recordsWrite ( ) ) { entry.setWriteTime ( now ) ; } accessQueue.add ( entry ) ; writeQueue.add ( entry ) ; } 
void drainRecencyQueue ( ) { ReferenceEntry < K , V > e ; while ( ( e = recencyQueue.poll ( ) ) != null ) { if ( accessQueue.contains ( e ) ) { accessQueue.add ( e ) ; } } } 
void tryExpireEntries ( long now ) { if ( tryLock ( ) ) { try { expireEntries ( now ) ; } finally { unlock ( ) ; } } } 
ReferenceEntry < K , V > getNextEvictable ( ) { for ( ReferenceEntry < K , V > e : accessQueue ) { int weight = e.getValueReference ( ) .getWeight ( ) ; if ( weight > 0 ) { return e ; } } throw new AssertionError ( ) ; } 
ReferenceEntry < K , V > getFirst ( int hash ) { AtomicReferenceArray < ReferenceEntry < K , V > > table = this.table ; return table.get ( hash & ( table.length ( ) - 1 ) ) ; } 
boolean containsKey ( Object key , int hash ) { try { if ( count != 0 ) { long now = map.ticker.read ( ) ; ReferenceEntry < K , V > e = getLiveEntry ( key , hash , now ) ; if ( e == null ) { return false ; } return e.getValueReference ( ) .get ( ) != null ; } return false ; } finally { postReadCleanup ( ) ; } } 
void removeCollectedEntry ( ReferenceEntry < K , V > entry ) { enqueueNotification ( entry.getKey ( ) , entry.getHash ( ) , entry.getValueReference ( ) .get ( ) , entry.getValueReference ( ) .getWeight ( ) , RemovalCause.COLLECTED ) ; writeQueue.remove ( entry ) ; accessQueue.remove ( entry ) ; } 
void postReadCleanup ( ) { if ( ( readCount.incrementAndGet ( ) & DRAIN_THRESHOLD ) == 0 ) { cleanUp ( ) ; } } 
void preWriteCleanup ( long now ) { runLockedCleanup ( now ) ; } 
void postWriteCleanup ( ) { runUnlockedCleanup ( ) ; } 
void cleanUp ( ) { long now = map.ticker.read ( ) ; runLockedCleanup ( now ) ; runUnlockedCleanup ( ) ; } 
void runLockedCleanup ( long now ) { if ( tryLock ( ) ) { try { drainReferenceQueues ( ) ; expireEntries ( now ) ; readCount.set ( 0 ) ; } finally { unlock ( ) ; } } } 
void runUnlockedCleanup ( ) { if ( !isHeldByCurrentThread ( ) ) { map.processPendingNotifications ( ) ; } } 
public boolean isLoading ( ) { return true ; } 
public boolean isActive ( ) { return oldValue.isActive ( ) ; } 
public int getWeight ( ) { return oldValue.getWeight ( ) ; } 
public boolean set ( @Nullable V newValue ) { return futureValue.set ( newValue ) ; } 
public boolean setException ( Throwable t ) { return futureValue.setException ( t ) ; } 
private ListenableFuture < V > fullyFailedFuture ( Throwable t ) { return Futures.immediateFailedFuture ( t ) ; } 
public void notifyNewValue ( @Nullable V newValue ) { if ( newValue != null ) { set ( newValue ) ; } else { oldValue = unset ( ) ; } } 
public V apply ( V newValue ) { LoadingValueReference.this.set ( newValue ) ; return newValue ; } 
public long elapsedNanos ( ) { return stopwatch.elapsed ( NANOSECONDS ) ; } 
public V waitForValue ( ) throws ExecutionException { return getUninterruptibly ( futureValue ) ; } 
public V get ( ) { return oldValue.get ( ) ; } 
public ValueReference < K , V > getOldValue ( ) { return oldValue ; } 
public ValueReference < K , V > copyFor ( ReferenceQueue < V > queue , @Nullable V value , ReferenceEntry < K , V > entry ) { return this ; } 
public long getWriteTime ( ) { return Long.MAX_VALUE ; } 
public boolean offer ( ReferenceEntry < K , V > entry ) { connectWriteOrder ( entry.getPreviousInWriteQueue ( ) , entry.getNextInWriteQueue ( ) ) ; connectWriteOrder ( head.getPreviousInWriteQueue ( ) , entry ) ; connectWriteOrder ( entry , head ) ; return true ; } 
public ReferenceEntry < K , V > peek ( ) { ReferenceEntry < K , V > next = head.getNextInWriteQueue ( ) ; return ( next == head ) ? null : next ; } 
public boolean remove ( Object o ) { ReferenceEntry < K , V > e = ( ReferenceEntry ) o ; ReferenceEntry < K , V > previous = e.getPreviousInWriteQueue ( ) ; ReferenceEntry < K , V > next = e.getNextInWriteQueue ( ) ; connectWriteOrder ( previous , next ) ; nullifyWriteOrder ( e ) ; return next != NullEntry.INSTANCE ; }
public boolean contains ( Object o ) { ReferenceEntry < K , V > e = ( ReferenceEntry ) o ; return e.getNextInWriteQueue ( ) != NullEntry.INSTANCE ; } 
public boolean isEmpty ( ) { return head.getNextInWriteQueue ( ) == head ; } 
public int size ( ) { int size = 0 ; for ( ReferenceEntry < K , V > e = head.getNextInWriteQueue ( ) ; e != head ; e = e.getNextInWriteQueue ( ) ) { size++ ; } return size ; } 
public void clear ( ) { ReferenceEntry < K , V > e = head.getNextInWriteQueue ( ) ; while ( e != head ) { ReferenceEntry < K , V > next = e.getNextInWriteQueue ( ) ; nullifyWriteOrder ( e ) ; e = next ; } head.setNextInWriteQueue ( head ) ; head.setPreviousInWriteQueue ( head ) ; } 
public long getAccessTime ( ) { return Long.MAX_VALUE ; } 
public boolean offer ( ReferenceEntry < K , V > entry ) { connectAccessOrder ( entry.getPreviousInAccessQueue ( ) , entry.getNextInAccessQueue ( ) ) ; connectAccessOrder ( head.getPreviousInAccessQueue ( ) , entry ) ; connectAccessOrder ( entry , head ) ; return true ; } 
public ReferenceEntry < K , V > peek ( ) { ReferenceEntry < K , V > next = head.getNextInAccessQueue ( ) ; return ( next == head ) ? null : next ; } 
public boolean remove ( Object o ) { ReferenceEntry < K , V > e = ( ReferenceEntry ) o ; ReferenceEntry < K , V > previous = e.getPreviousInAccessQueue ( ) ; ReferenceEntry < K , V > next = e.getNextInAccessQueue ( ) ; connectAccessOrder ( previous , next ) ; nullifyAccessOrder ( e ) ; return next != NullEntry.INSTANCE ; }
public boolean contains ( Object o ) { ReferenceEntry < K , V > e = ( ReferenceEntry ) o ; return e.getNextInAccessQueue ( ) != NullEntry.INSTANCE ; } 
public boolean isEmpty ( ) { return head.getNextInAccessQueue ( ) == head ; } 
public int size ( ) { int size = 0 ; for ( ReferenceEntry < K , V > e = head.getNextInAccessQueue ( ) ; e != head ; e = e.getNextInAccessQueue ( ) ) { size++ ; } return size ; } 
public void clear ( ) { ReferenceEntry < K , V > e = head.getNextInAccessQueue ( ) ; while ( e != head ) { ReferenceEntry < K , V > next = e.getNextInAccessQueue ( ) ; nullifyAccessOrder ( e ) ; e = next ; } head.setNextInAccessQueue ( head ) ; head.setPreviousInAccessQueue ( head ) ; } 
protected ReferenceEntry < K , V > computeNext ( ReferenceEntry < K , V > previous ) { ReferenceEntry < K , V > next = previous.getNextInAccessQueue ( ) ; return ( next == head ) ? null : next ; } 
public void cleanUp ( ) { for ( Segment < ? , ? > segment : segments ) { segment.cleanUp ( ) ; } } 
long longSize ( ) { Segment < K , V > [] segments = this.segments ; long sum = 0 ; for ( int i = 0 ; i < segments.length ; ++i ) { sum += Math.max ( 0 , segments[i].count ) ; } return sum ; } 
public int size ( ) { return Ints.saturatedCast ( longSize ( ) ) ; } 
V get ( K key , CacheLoader < ? super K , V > loader ) throws ExecutionException { int hash = hash ( checkNotNull ( key ) ) ; return segmentFor ( hash ) .get ( key , hash , loader ) ; }
public V getIfPresent ( Object key ) { int hash = hash ( checkNotNull ( key ) ) ; V value = segmentFor ( hash ) .get ( key , hash ) ; if ( value == null ) { globalStatsCounter.recordMisses ( 1 ) ; } else { globalStatsCounter.recordHits ( 1 ) ; } return value ; } 
public V getOrDefault ( @Nullable Object key , @Nullable V defaultValue ) { V result = get ( key ) ; return ( result != null ) ? result : defaultValue ; } 
V getOrLoad ( K key ) throws ExecutionException { return get ( key , defaultLoader ) ; } 
void refresh ( K key ) { int hash = hash ( checkNotNull ( key ) ) ; segmentFor ( hash ) .refresh ( key , hash , defaultLoader , false ) ; } 
public boolean containsKey ( @Nullable Object key ) { if ( key == null ) { return false ; } int hash = hash ( key ) ; return segmentFor ( hash ) .containsKey ( key , hash ) ; } 
public V put ( K key , V value ) { checkNotNull ( key ) ; checkNotNull ( value ) ; int hash = hash ( key ) ; return segmentFor ( hash ) .put ( key , hash , value , false ) ; } 
public V putIfAbsent ( K key , V value ) { checkNotNull ( key ) ; checkNotNull ( value ) ; int hash = hash ( key ) ; return segmentFor ( hash ) .put ( key , hash , value , true ) ; } 
public V compute ( K key , BiFunction < ? super K , ? super V , ? extends V > function ) { checkNotNull ( key ) ; checkNotNull ( function ) ; int hash = hash ( key ) ; return segmentFor ( hash ) .compute ( key , hash , function ) ; } 
public V computeIfAbsent ( K key , Function < ? super K , ? extends V > function ) { checkNotNull ( key ) ; checkNotNull ( function ) ; return compute ( key , ( k , oldValue ) - > ( oldValue == null ) ? function.apply ( key ) : oldValue ) ; } 
public V computeIfPresent ( K key , BiFunction < ? super K , ? super V , ? extends V > function ) { checkNotNull ( key ) ; checkNotNull ( function ) ; return compute ( key , ( k , oldValue ) - > ( oldValue == null ) ? null : function.apply ( k , oldValue ) ) ; } 
public V merge ( K key , V newValue , BiFunction < ? super V , ? super V , ? extends V > function ) { checkNotNull ( key ) ; checkNotNull ( newValue ) ; checkNotNull ( function ) ; return compute ( key , ( k , oldValue ) - > ( oldValue == null ) ? newValue : function.apply ( oldValue , newValue ) ) ; } 
public void putAll ( Map < ? extends K , ? extends V > m ) { for ( Entry < ? extends K , ? extends V > e : m.entrySet ( ) ) { put ( e.getKey ( ) , e.getValue ( ) ) ; } } 
public boolean remove ( @Nullable Object key , @Nullable Object value ) { if ( key == null || value == null ) { return false ; } int hash = hash ( key ) ; return segmentFor ( hash ) .remove ( key , hash , value ) ; }
public boolean replace ( K key , @Nullable V oldValue , V newValue ) { checkNotNull ( key ) ; checkNotNull ( newValue ) ; if ( oldValue == null ) { return false ; } int hash = hash ( key ) ; return segmentFor ( hash ) .replace ( key , hash , oldValue , newValue ) ; } 
public V replace ( K key , V value ) { checkNotNull ( key ) ; checkNotNull ( value ) ; int hash = hash ( key ) ; return segmentFor ( hash ) .replace ( key , hash , value ) ; } 
public void clear ( ) { for ( Segment < K , V > segment : segments ) { segment.clear ( ) ; } } 
void invalidateAll ( Iterable < ? > keys ) { for ( Object key : keys ) { remove ( key ) ; } } 
public Set < K > keySet ( ) { Set < K > ks = keySet ; return ( ks != null ) ? ks : ( keySet = new KeySet ( this ) ) ; } 
public Collection < V > values ( ) { Collection < V > vs = values ; return ( vs != null ) ? vs : ( values = new Values ( this ) ) ; } 
public Set < Entry < K , V > > entrySet ( ) { Set < Entry < K , V > > es = entrySet ; return ( es != null ) ? es : ( entrySet = new EntrySet ( this ) ) ; } 
boolean nextInChain ( ) { if ( nextEntry != null ) { for ( nextEntry = nextEntry.getNext ( ) ; nextEntry != null ; nextEntry = nextEntry.getNext ( ) ) { if ( advanceTo ( nextEntry ) ) { return true ; } } } return false ; } 
boolean nextInTable ( ) { while ( nextTableIndex > = 0 ) { if ( ( nextEntry = currentTable.get ( nextTableIndex-- ) ) != null ) { if ( advanceTo ( nextEntry ) || nextInChain ( ) ) { return true ; } } } return false ; } 
public boolean hasNext ( ) { return nextExternal != null ; } 
WriteThroughEntry nextEntry ( ) { if ( nextExternal == null ) { throw new NoSuchElementException ( ) ; } lastReturned = nextExternal ; advance ( ) ; return lastReturned ; } 
public void remove ( ) { checkState ( lastReturned != null ) ; LocalCache.this.remove ( lastReturned.getKey ( ) ) ; lastReturned = null ; } 
public K next ( ) { return nextEntry ( ) .getKey ( ) ; } 
public V next ( ) { return nextEntry ( ) .getValue ( ) ; } 
public K getKey ( ) { return key ; } 
public V getValue ( ) { return value ; } 
public boolean equals ( @Nullable Object object ) { if ( object instanceof Entry ) { Entry < ? , ? > that = ( Entry < ? , ? > ) object ; return key.equals ( that.getKey ( ) ) && value.equals ( that.getValue ( ) ) ; } return false ; } 
public V setValue ( V newValue ) { V oldValue = put ( key , newValue ) ; value = newValue ; return oldValue ; }
public Entry < K , V > next ( ) { return nextEntry ( ) ; }
public int size ( ) { return map.size ( ) ; } 
public boolean isEmpty ( ) { return map.isEmpty ( ) ; } 
public void clear ( ) { map.clear ( ) ; } 
public Object[] toArray ( ) { return toArrayList ( this ) .toArray ( ) ; } 
public < E > E[] toArray ( E[] a ) { return toArrayList ( this ) .toArray ( a ) ; } 
private static < E > ArrayList < E > toArrayList ( Collection < E > c ) { ArrayList < E > result = new ArrayList < E > ( c.size ( ) ) ; Iterators.addAll ( result , c.iterator ( ) ) ; return result ; } 
boolean removeIf ( BiPredicate < ? super K , ? super V > filter ) { checkNotNull ( filter ) ; boolean changed = false ; for ( K key : keySet ( ) ) { while ( true ) { V value = get ( key ) ; if ( value == null || !filter.test ( key , value ) ) { break ; } else if ( LocalCache.this.remove ( key , value ) ) { changed = true ; break ; } } } return changed ; } 
public Iterator < K > iterator ( ) { return new KeyIterator ( ) ; } 
public boolean contains ( Object o ) { return map.containsKey ( o ) ; } 
public boolean remove ( Object o ) { return map.remove ( o ) != null ; } 
public Iterator < V > iterator ( ) { return new ValueIterator ( ) ; } 
public boolean removeIf ( Predicate < ? super V > filter ) { checkNotNull ( filter ) ; return LocalCache.this.removeIf ( ( k , v ) - > filter.test ( v ) ) ; } 
public boolean contains ( Object o ) { return map.containsValue ( o ) ; } 
public Iterator < Entry < K , V > > iterator ( ) { return new EntryIterator ( ) ; } 
public boolean removeIf ( Predicate < ? super Entry < K , V > > filter ) { checkNotNull ( filter ) ; return LocalCache.this.removeIf ( ( k , v ) - > filter.test ( Maps.immutableEntry ( k , v ) ) ) ; } 
public boolean remove ( Object o ) { if ( ! ( o instanceof Entry ) ) { return false ; } Entry < ? , ? > e = ( Entry < ? , ? > ) o ; Object key = e.getKey ( ) ; return key != null && LocalCache.this.remove ( key , e.getValue ( ) ) ; } 
private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { in.defaultReadObject ( ) ; CacheBuilder < K , V > builder = recreateCacheBuilder ( ) ; this.delegate = builder.build ( ) ; } 
private Object readResolve ( ) { return delegate ; } 
protected Cache < K , V > delegate ( ) { return delegate ; } 
private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { in.defaultReadObject ( ) ; CacheBuilder < K , V > builder = recreateCacheBuilder ( ) ; this.autoDelegate = builder.build ( loader ) ; } 
public V get ( K key ) throws ExecutionException { return autoDelegate.get ( key ) ; } 
public V getUnchecked ( K key ) { return autoDelegate.getUnchecked ( key ) ; } 
public ImmutableMap < K , V > getAll ( Iterable < ? extends K > keys ) throws ExecutionException { return autoDelegate.getAll ( keys ) ; } 
public final V apply ( K key ) { return autoDelegate.apply ( key ) ; } 
public void refresh ( K key ) { autoDelegate.refresh ( key ) ; } 
private Object readResolve ( ) { return autoDelegate ; } 
public V getIfPresent ( Object key ) { return localCache.getIfPresent ( key ) ; } 
public V load ( Object key ) throws Exception { return valueLoader.call ( ) ; } 
public ImmutableMap < K , V > getAllPresent ( Iterable < ? > keys ) { return localCache.getAllPresent ( keys ) ; } 
public void put ( K key , V value ) { localCache.put ( key , value ) ; } 
public void putAll ( Map < ? extends K , ? extends V > m ) { localCache.putAll ( m ) ; } 
public void invalidate ( Object key ) { checkNotNull ( key ) ; localCache.remove ( key ) ; } 
public void invalidateAll ( Iterable < ? > keys ) { localCache.invalidateAll ( keys ) ; } 
public void invalidateAll ( ) { localCache.clear ( ) ; } 
public long size ( ) { return localCache.longSize ( ) ; } 
public ConcurrentMap < K , V > asMap ( ) { return localCache ; } 
public CacheStats stats ( ) { SimpleStatsCounter aggregator = new SimpleStatsCounter ( ) ; aggregator.incrementBy ( localCache.globalStatsCounter ) ; for ( Segment < K , V > segment : localCache.segments ) { aggregator.incrementBy ( segment.statsCounter ) ; } return aggregator.snapshot ( ) ; } 
public void cleanUp ( ) { localCache.cleanUp ( ) ; } 
Object writeReplace ( ) { return new ManualSerializationProxy < > ( localCache ) ; } 
public V get ( K key ) throws ExecutionException { return localCache.getOrLoad ( key ) ; } 
public ImmutableMap < K , V > getAll ( Iterable < ? extends K > keys ) throws ExecutionException { return localCache.getAll ( keys ) ; } 
public void refresh ( K key ) { localCache.refresh ( key ) ; } 
Object writeReplace ( ) { return new LoadingSerializationProxy < > ( localCache ) ; } 
public LongAddable get ( ) { return new LongAdder ( ) ; } 
public LongAddable get ( ) { return new PureJavaLongAddable ( ) ; } 
public static LongAddable create ( ) { return SUPPLIER.get ( ) ; } 
public void increment ( ) { getAndIncrement ( ) ; } 
public void add ( long x ) { getAndAdd ( x ) ; } 
public long sum ( ) { return get ( ) ; } 
final long fn ( long v , long x ) { return v + x ; } 
public void increment ( ) { add ( 1L ) ; } 
public void decrement ( ) { add ( -1L ) ; } 
public void reset ( ) { internalReset ( 0L ) ; } 
public long longValue ( ) { return sum ( ) ; }
public int intValue ( ) { return ( int ) sum ( ) ; } 
public float floatValue ( ) { return ( float ) sum ( ) ; } 
public double doubleValue ( ) { return ( double ) sum ( ) ; } 
private void writeObject ( ObjectOutputStream s ) throws IOException { s.defaultWriteObject ( ) ; s.writeLong ( sum ( ) ) ; } 
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s.defaultReadObject ( ) ; busy = 0 ; cells = null ; base = s.readLong ( ) ; } 
boolean wasEvicted ( ) { return true ; } 
public void run ( ) { listener.onRemoval ( notification ) ; } 
public static < K , V > RemovalNotification < K , V > create ( @Nullable K key , @Nullable V value , RemovalCause cause ) { return new RemovalNotification ( key , value , cause ) ; } 
public RemovalCause getCause ( ) { return cause ; } 
public boolean wasEvicted ( ) { return cause.wasEvicted ( ) ; } 
final boolean cas ( long cmp , long val ) { return UNSAFE.compareAndSwapLong ( this , valueOffset , cmp , val ) ; } 
final boolean casBase ( long cmp , long val ) { return UNSAFE.compareAndSwapLong ( this , baseOffset , cmp , val ) ; } 
final boolean casBusy ( ) { return UNSAFE.compareAndSwapInt ( this , busyOffset , 0 , 1 ) ; } 
final void internalReset ( long initialValue ) { Cell[] as = cells ; base = initialValue ; if ( as != null ) { int n = as.length ; for ( int i = 0 ; i < n ; ++i ) { Cell a = as[i] ; if ( a != null ) a.value = initialValue ; } } } 
public sun.misc.Unsafe run ( ) throws Exception { Class < sun.misc.Unsafe > k = sun.misc.Unsafe.class ; for ( java.lang.reflect.Field f : k.getDeclaredFields ( ) ) { f.setAccessible ( true ) ; Object x = f.get ( null ) ; if ( k.isInstance ( x ) ) return k.cast ( x ) ; } throw new NoSuchFieldError ( " the Unsafe " ) ; } 
protected Map < K , V > delegate ( ) { return delegate ; }
void setDelegates ( Map < K , V > forward , Map < V , K > backward ) { checkState ( delegate == null ) ; checkState ( inverse == null ) ; checkArgument ( forward.isEmpty ( ) ) ; checkArgument ( backward.isEmpty ( ) ) ; checkArgument ( forward != backward ) ; delegate = forward ; inverse = makeInverse ( backward ) ; } 
AbstractBiMap < V , K > makeInverse ( Map < V , K > backward ) { return new Inverse < > ( backward , this ) ; } 
void setInverse ( AbstractBiMap < V , K > inverse ) { this.inverse = inverse ; } 
public boolean containsValue ( @Nullable Object value ) { return inverse.containsKey ( value ) ; } 
public V put ( @Nullable K key , @Nullable V value ) { return putInBothMaps ( key , value , false ) ; } 
public V forcePut ( @Nullable K key , @Nullable V value ) { return putInBothMaps ( key , value , true ) ; } 
private void updateInverseMap ( K key , boolean containedKey , V oldValue , V newValue ) { if ( containedKey ) { removeFromInverseMap ( oldValue ) ; } inverse.delegate.put ( newValue , key ) ; } 
public V remove ( @Nullable Object key ) { return containsKey ( key ) ? removeFromBothMaps ( key ) : null ; } 
private V removeFromBothMaps ( Object key ) { V oldValue = delegate.remove ( key ) ; removeFromInverseMap ( oldValue ) ; return oldValue ; } 
private void removeFromInverseMap ( V oldValue ) { inverse.delegate.remove ( oldValue ) ; } 
public void putAll ( Map < ? extends K , ? extends V > map ) { for ( Entry < ? extends K , ? extends V > entry : map.entrySet ( ) ) { put ( entry.getKey ( ) , entry.getValue ( ) ) ; } } 
public void clear ( ) { delegate.clear ( ) ; inverse.delegate.clear ( ) ; } 
public BiMap < V , K > inverse ( ) { return inverse ; } 
public Set < K > keySet ( ) { Set < K > result = keySet ; return ( result == null ) ? keySet = new KeySet ( ) : result ; } 
protected Set < K > delegate ( ) { return delegate.keySet ( ) ; } 
public void clear ( ) { AbstractBiMap.this.clear ( ) ; } 
public boolean remove ( Object key ) { if ( !contains ( key ) ) { return false ; } removeFromBothMaps ( key ) ; return true ; } 
public boolean removeAll ( Collection < ? > keysToRemove ) { return standardRemoveAll ( keysToRemove ) ; } 
public boolean retainAll ( Collection < ? > keysToRetain ) { return standardRetainAll ( keysToRetain ) ; } 
public Iterator < K > iterator ( ) { return Maps.keyIterator ( entrySet ( ) .iterator ( ) ) ; } 
public Set < V > values ( ) { Set < V > result = valueSet ; return ( result == null ) ? valueSet = new ValueSet ( ) : result ; } 
protected Set < V > delegate ( ) { return valuesDelegate ; } 
public Iterator < V > iterator ( ) { return Maps.valueIterator ( entrySet ( ) .iterator ( ) ) ; } 
public Object[] toArray ( ) { return standardToArray ( ) ; } 
public < T > T[] toArray ( T[] array ) { return standardToArray ( array ) ; } 
public Set < Entry < K , V > > entrySet ( ) { Set < Entry < K , V > > result = entrySet ; return ( result == null ) ? entrySet = new EntrySet ( ) : result ; }
protected Entry < K , V > delegate ( ) { return delegate ; } 
public V setValue ( V value ) { checkValue ( value ) ; checkState ( entrySet ( ) .contains ( this ) , " entry no longer in map " ) ; if ( Objects.equal ( value , getValue ( ) ) ) { return value ; } checkArgument ( !containsValue ( value ) , " value already present: %s " , value ) ; V oldValue = delegate.setValue ( value ) ; checkState ( Objects.equal ( value , get ( getKey ( ) ) ) , " entry no longer in map " ) ; updateInverseMap ( getKey ( ) , true , oldValue , value ) ; return oldValue ; } 
public boolean hasNext ( ) { return iterator.hasNext ( ) ; } 
public Entry < K , V > next ( ) { entry = iterator.next ( ) ; return new BiMapEntry ( entry ) ; } 
public void remove ( ) { checkRemove ( entry != null ) ; V value = entry.getValue ( ) ; iterator.remove ( ) ; removeFromInverseMap ( value ) ; entry = null ; } 
protected Set < Entry < K , V > > delegate ( ) { return esDelegate ; } 
public boolean remove ( Object object ) { if ( !esDelegate.contains ( object ) ) { return false ; } Entry < ? , ? > entry = ( Entry < ? , ? > ) object ; inverse.delegate.remove ( entry.getValue ( ) ) ; esDelegate.remove ( entry ) ; return true ; } 
public Iterator < Entry < K , V > > iterator ( ) { return entrySetIterator ( ) ; } 
public boolean contains ( Object o ) { return Maps.containsEntryImpl ( delegate ( ) , o ) ; } 
public boolean containsAll ( Collection < ? > c ) { return standardContainsAll ( c ) ; } 
public boolean removeAll ( Collection < ? > c ) { return standardRemoveAll ( c ) ; } 
public boolean retainAll ( Collection < ? > c ) { return standardRetainAll ( c ) ; } 
K checkKey ( K key ) { return inverse.checkValue ( key ) ; } 
V checkValue ( V value ) { return inverse.checkKey ( value ) ; } 
private void writeObject ( ObjectOutputStream stream ) throws IOException { stream.defaultWriteObject ( ) ; stream.writeObject ( inverse ( ) ) ; } 
private void readObject ( ObjectInputStream stream ) throws IOException , ClassNotFoundException { stream.defaultReadObject ( ) ; setInverse ( ( AbstractBiMap < V , K > ) stream.readObject ( ) ) ; } 
Object readResolve ( ) { return inverse ( ) .inverse ( ) ; } 
public final boolean hasNext ( ) { return position < size ; } 
public final E next ( ) { if ( !hasNext ( ) ) { throw new NoSuchElementException ( ) ; } return get ( position++ ) ; } 
public final int nextIndex ( ) { return position ; } 
public final boolean hasPrevious ( ) { return position > 0 ; } 
public final E previous ( ) { if ( !hasPrevious ( ) ) { throw new NoSuchElementException ( ) ; } return get ( --position ) ; } 
public final int previousIndex ( ) { return position - 1 ; } 
public final T peek ( ) { if ( !hasNext ( ) ) { throw new NoSuchElementException ( ) ; } return next ; } 
List < V > createUnmodifiableEmptyCollection ( ) { return Collections.emptyList ( ) ; } 
Collection < V > wrapCollection ( K key , Collection < V > collection ) { return wrapList ( key , ( List < V > ) collection , null ) ; }
public List < V > get ( @Nullable K key ) { return ( List < V > ) super.get ( key ) ; } 
public List < V > removeAll ( @Nullable Object key ) { return ( List < V > ) super.removeAll ( key ) ; } 
public List < V > replaceValues ( @Nullable K key , Iterable < ? extends V > values ) { return ( List < V > ) super.replaceValues ( key , values ) ; } 
public boolean put ( @Nullable K key , @Nullable V value ) { return super.put ( key , value ) ; } 
public Map < K , Collection < V > > asMap ( ) { return super.asMap ( ) ; } 
final void setMap ( Map < K , Collection < V > > map ) { this.map = map ; totalSize = 0 ; for ( Collection < V > values : map.values ( ) ) { checkArgument ( !values.isEmpty ( ) ) ; totalSize += values.size ( ) ; } } 
Collection < V > createUnmodifiableEmptyCollection ( ) { return unmodifiableCollectionSubclass ( createCollection ( ) ) ; } 
Collection < V > createCollection ( @Nullable K key ) { return createCollection ( ) ; } 
Map < K , Collection < V > > backingMap ( ) { return map ; } 
public int size ( ) { return totalSize ; } 
public boolean containsKey ( @Nullable Object key ) { return map.containsKey ( key ) ; } 
private Collection < V > getOrCreateCollection ( @Nullable K key ) { Collection < V > collection = map.get ( key ) ; if ( collection == null ) { collection = createCollection ( key ) ; map.put ( key , collection ) ; } return collection ; } 
public Collection < V > removeAll ( @Nullable Object key ) { Collection < V > collection = map.remove ( key ) ; if ( collection == null ) { return createUnmodifiableEmptyCollection ( ) ; } Collection < V > output = createCollection ( ) ; output.addAll ( collection ) ; totalSize -= collection.size ( ) ; collection.clear ( ) ; return unmodifiableCollectionSubclass ( output ) ; } 
 < E > Collection < E > unmodifiableCollectionSubclass ( Collection < E > collection ) { return Collections.unmodifiableCollection ( collection ) ; } 
public void clear ( ) { for ( Collection < V > collection : map.values ( ) ) { collection.clear ( ) ; } map.clear ( ) ; totalSize = 0 ; } 
public Collection < V > get ( @Nullable K key ) { Collection < V > collection = map.get ( key ) ; if ( collection == null ) { collection = createCollection ( key ) ; } return wrapCollection ( key , collection ) ; } 
Collection < V > wrapCollection ( @Nullable K key , Collection < V > collection ) { return new WrappedCollection ( key , collection , null ) ; } 
final List < V > wrapList ( @Nullable K key , List < V > list , @Nullable WrappedCollection ancestor ) { return ( list instanceof RandomAccess ) ? new RandomAccessWrappedList ( key , list , ancestor ) : new WrappedList ( key , list , ancestor ) ; } 
void refreshIfEmpty ( ) { if ( ancestor != null ) { ancestor.refreshIfEmpty ( ) ; if ( ancestor.getDelegate ( ) != ancestorDelegate ) { throw new ConcurrentModificationException ( ) ; } } else if ( delegate.isEmpty ( ) ) { Collection < V > newDelegate = map.get ( key ) ; if ( newDelegate != null ) { delegate = newDelegate ; } } } 
void removeIfEmpty ( ) { if ( ancestor != null ) { ancestor.removeIfEmpty ( ) ; } else if ( delegate.isEmpty ( ) ) { map.remove ( key ) ; } } 
K getKey ( ) { return key ; } 
void addToMap ( ) { if ( ancestor != null ) { ancestor.addToMap ( ) ; } else { map.put ( key , delegate ) ; } } 
public int size ( ) { refreshIfEmpty ( ) ; return delegate.size ( ) ; } 
public boolean equals ( @Nullable Object object ) { if ( object == this ) { return true ; } refreshIfEmpty ( ) ; return delegate.equals ( object ) ; } 
Collection < V > getDelegate ( ) { return delegate ; }
public Iterator < V > iterator ( ) { refreshIfEmpty ( ) ; return new WrappedIterator ( ) ; } 
public Spliterator < V > spliterator ( ) { refreshIfEmpty ( ) ; return delegate.spliterator ( ) ; } 
void validateIterator ( ) { refreshIfEmpty ( ) ; if ( delegate != originalDelegate ) { throw new ConcurrentModificationException ( ) ; } } 
public boolean hasNext ( ) { validateIterator ( ) ; return delegateIterator.hasNext ( ) ; } 
public V next ( ) { validateIterator ( ) ; return delegateIterator.next ( ) ; } 
public void remove ( ) { delegateIterator.remove ( ) ; totalSize-- ; removeIfEmpty ( ) ; } 
Iterator < V > getDelegateIterator ( ) { validateIterator ( ) ; return delegateIterator ; } 
public boolean add ( V value ) { refreshIfEmpty ( ) ; boolean wasEmpty = delegate.isEmpty ( ) ; boolean changed = delegate.add ( value ) ; if ( changed ) { totalSize++ ; if ( wasEmpty ) { addToMap ( ) ; } } return changed ; } 
WrappedCollection getAncestor ( ) { return ancestor ; } 
public boolean addAll ( Collection < ? extends V > collection ) { if ( collection.isEmpty ( ) ) { return false ; } int oldSize = size ( ) ; boolean changed = delegate.addAll ( collection ) ; if ( changed ) { int newSize = delegate.size ( ) ; totalSize += ( newSize - oldSize ) ; if ( oldSize == 0 ) { addToMap ( ) ; } } return changed ; } 
public boolean contains ( Object o ) { refreshIfEmpty ( ) ; return delegate.contains ( o ) ; } 
public boolean containsAll ( Collection < ? > c ) { refreshIfEmpty ( ) ; return delegate.containsAll ( c ) ; } 
public void clear ( ) { int oldSize = size ( ) ; if ( oldSize == 0 ) { return ; } delegate.clear ( ) ; totalSize -= oldSize ; removeIfEmpty ( ) ; } 
public boolean remove ( Object o ) { refreshIfEmpty ( ) ; boolean changed = delegate.remove ( o ) ; if ( changed ) { totalSize-- ; removeIfEmpty ( ) ; } return changed ; } 
public boolean removeAll ( Collection < ? > c ) { if ( c.isEmpty ( ) ) { return false ; } int oldSize = size ( ) ; boolean changed = delegate.removeAll ( c ) ; if ( changed ) { int newSize = delegate.size ( ) ; totalSize += ( newSize - oldSize ) ; removeIfEmpty ( ) ; } return changed ; } 
public boolean retainAll ( Collection < ? > c ) { checkNotNull ( c ) ; int oldSize = size ( ) ; boolean changed = delegate.retainAll ( c ) ; if ( changed ) { int newSize = delegate.size ( ) ; totalSize += ( newSize - oldSize ) ; removeIfEmpty ( ) ; } return changed ; } 
private static < E > Iterator < E > iteratorOrListIterator ( Collection < E > collection ) { return ( collection instanceof List ) ? ( ( List < E > ) collection ) .listIterator ( ) : collection.iterator ( ) ; } 
public boolean removeAll ( Collection < ? > c ) { if ( c.isEmpty ( ) ) { return false ; } int oldSize = size ( ) ; boolean changed = Sets.removeAllImpl ( ( Set < V > ) delegate , c ) ; if ( changed ) { int newSize = delegate.size ( ) ; totalSize += ( newSize - oldSize ) ; removeIfEmpty ( ) ; } return changed ; } 
SortedSet < V > getSortedSetDelegate ( ) { return ( SortedSet < V > ) getDelegate ( ) ; } 
public Comparator < ? super V > comparator ( ) { return getSortedSetDelegate ( ) .comparator ( ) ; } 
public V first ( ) { refreshIfEmpty ( ) ; return getSortedSetDelegate ( ) .first ( ) ; } 
public V last ( ) { refreshIfEmpty ( ) ; return getSortedSetDelegate ( ) .last ( ) ; } 
public SortedSet < V > headSet ( V toElement ) { refreshIfEmpty ( ) ; return new WrappedSortedSet ( getKey ( ) , getSortedSetDelegate ( ) .headSet ( toElement ) , ( getAncestor ( ) == null ) ? this : getAncestor ( ) ) ; } 
public SortedSet < V > subSet ( V fromElement , V toElement ) { refreshIfEmpty ( ) ; return new WrappedSortedSet ( getKey ( ) , getSortedSetDelegate ( ) .subSet ( fromElement , toElement ) , ( getAncestor ( ) == null ) ? this : getAncestor ( ) ) ; } 
public SortedSet < V > tailSet ( V fromElement ) { refreshIfEmpty ( ) ; return new WrappedSortedSet ( getKey ( ) , getSortedSetDelegate ( ) .tailSet ( fromElement ) , ( getAncestor ( ) == null ) ? this : getAncestor ( ) ) ; } 
NavigableSet < V > getSortedSetDelegate ( ) { return ( NavigableSet < V > ) super.getSortedSetDelegate ( ) ; } 
public V lower ( V v ) { return getSortedSetDelegate ( ) .lower ( v ) ; } 
public V floor ( V v ) { return getSortedSetDelegate ( ) .floor ( v ) ; } 
public V ceiling ( V v ) { return getSortedSetDelegate ( ) .ceiling ( v ) ; } 
public V higher ( V v ) { return getSortedSetDelegate ( ) .higher ( v ) ; } 
public V pollFirst ( ) { return Iterators.pollNext ( iterator ( ) ) ; } 
public V pollLast ( ) { return Iterators.pollNext ( descendingIterator ( ) ) ; } 
private NavigableSet < V > wrap ( NavigableSet < V > wrapped ) { return new WrappedNavigableSet ( key , wrapped , ( getAncestor ( ) == null ) ? this : getAncestor ( ) ) ; } 
public NavigableSet < V > descendingSet ( ) { return wrap ( getSortedSetDelegate ( ) .descendingSet ( ) ) ; } 
public Iterator < V > descendingIterator ( ) { return new WrappedIterator ( getSortedSetDelegate ( ) .descendingIterator ( ) ) ; } 
public NavigableSet < V > subSet ( V fromElement , boolean fromInclusive , V toElement , boolean toInclusive ) { return wrap ( getSortedSetDelegate ( ) .subSet ( fromElement , fromInclusive , toElement , toInclusive ) ) ; } 
public NavigableSet < V > headSet ( V toElement , boolean inclusive ) { return wrap ( getSortedSetDelegate ( ) .headSet ( toElement , inclusive ) ) ; } 
public NavigableSet < V > tailSet ( V fromElement , boolean inclusive ) { return wrap ( getSortedSetDelegate ( ) .tailSet ( fromElement , inclusive ) ) ; } 
List < V > getListDelegate ( ) { return ( List < V > ) getDelegate ( ) ; } 
public boolean addAll ( int index , Collection < ? extends V > c ) { if ( c.isEmpty ( ) ) { return false ; } int oldSize = size ( ) ; boolean changed = getListDelegate ( ) .addAll ( index , c ) ; if ( changed ) { int newSize = getDelegate ( ) .size ( ) ; totalSize += ( newSize - oldSize ) ; if ( oldSize == 0 ) { addToMap ( ) ; } } return changed ; } 
public V get ( int index ) { refreshIfEmpty ( ) ; return getListDelegate ( ) .get ( index ) ; } 
public V set ( int index , V element ) { refreshIfEmpty ( ) ; return getListDelegate ( ) .set ( index , element ) ; } 
public void add ( int index , V element ) { refreshIfEmpty ( ) ; boolean wasEmpty = getDelegate ( ) .isEmpty ( ) ; getListDelegate ( ) .add ( index , element ) ; totalSize++ ; if ( wasEmpty ) { addToMap ( ) ; } } 
public V remove ( int index ) { refreshIfEmpty ( ) ; V value = getListDelegate ( ) .remove ( index ) ; totalSize-- ; removeIfEmpty ( ) ; return value ; } 
public int indexOf ( Object o ) { refreshIfEmpty ( ) ; return getListDelegate ( ) .indexOf ( o ) ; } 
public int lastIndexOf ( Object o ) { refreshIfEmpty ( ) ; return getListDelegate ( ) .lastIndexOf ( o ) ; } 
public ListIterator < V > listIterator ( ) { refreshIfEmpty ( ) ; return new WrappedListIterator ( ) ; } 
public ListIterator < V > listIterator ( int index ) { refreshIfEmpty ( ) ; return new WrappedListIterator ( index ) ; } 
public List < V > subList ( int fromIndex , int toIndex ) { refreshIfEmpty ( ) ; return wrapList ( getKey ( ) , getListDelegate ( ) .subList ( fromIndex , toIndex ) , ( getAncestor ( ) == null ) ? this : getAncestor ( ) ) ; } 
private ListIterator < V > getDelegateListIterator ( ) { return ( ListIterator < V > ) getDelegateIterator ( ) ; } 
public boolean hasPrevious ( ) { return getDelegateListIterator ( ) .hasPrevious ( ) ; } 
public V previous ( ) { return getDelegateListIterator ( ) .previous ( ) ; } 
public int nextIndex ( ) { return getDelegateListIterator ( ) .nextIndex ( ) ; } 
public int previousIndex ( ) { return getDelegateListIterator ( ) .previousIndex ( ) ; } 
public void set ( V value ) { getDelegateListIterator ( ) .set ( value ) ; } 
public void add ( V value ) { boolean wasEmpty = isEmpty ( ) ; getDelegateListIterator ( ) .add ( value ) ; totalSize++ ; if ( wasEmpty ) { addToMap ( ) ; } } 
Set < K > createKeySet ( ) { return new KeySet ( map ) ; } 
final Set < K > createMaybeNavigableKeySet ( ) { if ( map instanceof NavigableMap ) { return new NavigableKeySet ( ( NavigableMap < K , Collection < V > > ) map ) ; } else if ( map instanceof SortedMap ) { return new SortedKeySet ( ( SortedMap < K , Collection < V > > ) map ) ; } else { return new KeySet ( map ) ; } } 
public boolean hasNext ( ) { return entryIterator.hasNext ( ) ; } 
public K next ( ) { entry = entryIterator.next ( ) ; return entry.getKey ( ) ; } 
public void remove ( ) { checkRemove ( entry != null ) ; Collection < V > collection = entry.getValue ( ) ; entryIterator.remove ( ) ; totalSize -= collection.size ( ) ; collection.clear ( ) ; entry = null ; } 
public Spliterator < K > spliterator ( ) { return map ( ) .keySet ( ) .spliterator ( ) ; } 
public boolean remove ( Object key ) { int count = 0 ; Collection < V > collection = map ( ) .remove ( key ) ; if ( collection != null ) { count = collection.size ( ) ; collection.clear ( ) ; totalSize -= count ; } return count > 0 ; } 
public void clear ( ) { Iterators.clear ( iterator ( ) ) ; } 
public boolean containsAll ( Collection < ? > c ) { return map ( ) .keySet ( ) .containsAll ( c ) ; } 
public boolean equals ( @Nullable Object object ) { return this == object || this.map ( ) .keySet ( ) .equals ( object ) ; } 
SortedMap < K , Collection < V > > sortedMap ( ) { return ( SortedMap < K , Collection < V > > ) super.map ( ) ; }
public Comparator < ? super K > comparator ( ) { return sortedMap ( ) .comparator ( ) ; } 
public K first ( ) { return sortedMap ( ) .firstKey ( ) ; } 
public SortedSet < K > headSet ( K toElement ) { return new SortedKeySet ( sortedMap ( ) .headMap ( toElement ) ) ; } 
public K last ( ) { return sortedMap ( ) .lastKey ( ) ; } 
public SortedSet < K > subSet ( K fromElement , K toElement ) { return new SortedKeySet ( sortedMap ( ) .subMap ( fromElement , toElement ) ) ; } 
public SortedSet < K > tailSet ( K fromElement ) { return new SortedKeySet ( sortedMap ( ) .tailMap ( fromElement ) ) ; } 
NavigableMap < K , Collection < V > > sortedMap ( ) { return ( NavigableMap < K , Collection < V > > ) super.sortedMap ( ) ; } 
public K lower ( K k ) { return sortedMap ( ) .lowerKey ( k ) ; } 
public K floor ( K k ) { return sortedMap ( ) .floorKey ( k ) ; } 
public K ceiling ( K k ) { return sortedMap ( ) .ceilingKey ( k ) ; } 
public K higher ( K k ) { return sortedMap ( ) .higherKey ( k ) ; } 
public K pollFirst ( ) { return Iterators.pollNext ( iterator ( ) ) ; } 
public K pollLast ( ) { return Iterators.pollNext ( descendingIterator ( ) ) ; } 
public NavigableSet < K > descendingSet ( ) { return new NavigableKeySet ( sortedMap ( ) .descendingMap ( ) ) ; } 
public Iterator < K > descendingIterator ( ) { return descendingSet ( ) .iterator ( ) ; }
public NavigableSet < K > tailSet ( K fromElement , boolean inclusive ) { return new NavigableKeySet ( sortedMap ( ) .tailMap ( fromElement , inclusive ) ) ; } 
private void removeValuesForKey ( Object key ) { Collection < V > collection = Maps.safeRemove ( map , key ) ; if ( collection != null ) { int count = collection.size ( ) ; collection.clear ( ) ; totalSize -= count ; } } 
public boolean hasNext ( ) { return keyIterator.hasNext ( ) || valueIterator.hasNext ( ) ; } 
public T next ( ) { if ( !valueIterator.hasNext ( ) ) { Entry < K , Collection < V > > mapEntry = keyIterator.next ( ) ; key = mapEntry.getKey ( ) ; collection = mapEntry.getValue ( ) ; valueIterator = collection.iterator ( ) ; } return output ( key , valueIterator.next ( ) ) ; } 
public void remove ( ) { valueIterator.remove ( ) ; if ( collection.isEmpty ( ) ) { keyIterator.remove ( ) ; } totalSize-- ; } 
public Collection < V > values ( ) { return super.values ( ) ; } 
Collection < V > createValues ( ) { return new Values ( ) ; } 
V output ( K key , V value ) { return value ; } 
Spliterator < V > valueSpliterator ( ) { return CollectSpliterators.flatMap ( map.values ( ) .spliterator ( ) , Collection::spliterator , Spliterator.SIZED , size ( ) ) ; } 
Multiset < K > createKeys ( ) { return new Multimaps.Keys < K , V > ( this ) ; } 
public Collection < Entry < K , V > > entries ( ) { return super.entries ( ) ; } 
Collection < Entry < K , V > > createEntries ( ) { if ( this instanceof SetMultimap ) { return new EntrySet ( ) ; } else { return new Entries ( ) ; } } 
Entry < K , V > output ( K key , V value ) { return Maps.immutableEntry ( key , value ) ; } 
Spliterator < Entry < K , V > > entrySpliterator ( ) { return CollectSpliterators.flatMap ( map.entrySet ( ) .spliterator ( ) , keyToValueCollectionEntry - > { K key = keyToValueCollectionEntry.getKey ( ) ; Collection < V > valueCollection = keyToValueCollectionEntry.getValue ( ) ; return CollectSpliterators.map ( valueCollection.spliterator ( ) , ( V value ) - > Maps.immutableEntry ( key , value ) ) ; } , Spliterator.SIZED , size ( ) ) ; } 
public void forEach ( BiConsumer < ? super K , ? super V > action ) { checkNotNull ( action ) ; map.forEach ( ( key , valueCollection ) - > valueCollection.forEach ( value - > action.accept ( key , value ) ) ) ; } 
Map < K , Collection < V > > createAsMap ( ) { return new AsMap ( map ) ; } 
final Map < K , Collection < V > > createMaybeNavigableAsMap ( ) { if ( map instanceof NavigableMap ) { return new NavigableAsMap ( ( NavigableMap < K , Collection < V > > ) map ) ; } else if ( map instanceof SortedMap ) { return new SortedAsMap ( ( SortedMap < K , Collection < V > > ) map ) ; } else { return new AsMap ( map ) ; } } 
protected Set < Entry < K , Collection < V > > > createEntrySet ( ) { return new AsMapEntries ( ) ; } 
public boolean containsKey ( Object key ) { return Maps.safeContainsKey ( submap , key ) ; } 
public Set < K > keySet ( ) { return AbstractMapBasedMultimap.this.keySet ( ) ; }
public int size ( ) { return submap.size ( ) ; } 
public void clear ( ) { if ( submap == map ) { AbstractMapBasedMultimap.this.clear ( ) ; } else { Iterators.clear ( new AsMapIterator ( ) ) ; } }
Entry < K , Collection < V > > wrapEntry ( Entry < K , Collection < V > > entry ) { K key = entry.getKey ( ) ; return Maps.immutableEntry ( key , wrapCollection ( key , entry.getValue ( ) ) ) ; } 
Map < K , Collection < V > > map ( ) { return AsMap.this ; } 
public Iterator < Entry < K , Collection < V > > > iterator ( ) { return new AsMapIterator ( ) ; } 
public Spliterator < Entry < K , Collection < V > > > spliterator ( ) { return CollectSpliterators.map ( submap.entrySet ( ) .spliterator ( ) , AsMap.this::wrapEntry ) ; } 
public boolean contains ( Object o ) { return Collections2.safeContains ( submap.entrySet ( ) , o ) ; } 
public boolean remove ( Object o ) { if ( !contains ( o ) ) { return false ; } Entry < ? , ? > entry = ( Entry < ? , ? > ) o ; removeValuesForKey ( entry.getKey ( ) ) ; return true ; } 
public boolean hasNext ( ) { return delegateIterator.hasNext ( ) ; } 
public Entry < K , Collection < V > > next ( ) { Entry < K , Collection < V > > entry = delegateIterator.next ( ) ; collection = entry.getValue ( ) ; return wrapEntry ( entry ) ; } 
public void remove ( ) { checkRemove ( collection != null ) ; delegateIterator.remove ( ) ; totalSize -= collection.size ( ) ; collection.clear ( ) ; collection = null ; } 
SortedMap < K , Collection < V > > sortedMap ( ) { return ( SortedMap < K , Collection < V > > ) submap ; } 
public K firstKey ( ) { return sortedMap ( ) .firstKey ( ) ; } 
public K lastKey ( ) { return sortedMap ( ) .lastKey ( ) ; } 
public SortedMap < K , Collection < V > > headMap ( K toKey ) { return new SortedAsMap ( sortedMap ( ) .headMap ( toKey ) ) ; } 
public SortedMap < K , Collection < V > > subMap ( K fromKey , K toKey ) { return new SortedAsMap ( sortedMap ( ) .subMap ( fromKey , toKey ) ) ; } 
public SortedMap < K , Collection < V > > tailMap ( K fromKey ) { return new SortedAsMap ( sortedMap ( ) .tailMap ( fromKey ) ) ; } 
public SortedSet < K > keySet ( ) { SortedSet < K > result = sortedKeySet ; return ( result == null ) ? sortedKeySet = createKeySet ( ) : result ; } 
SortedSet < K > createKeySet ( ) { return new SortedKeySet ( sortedMap ( ) ) ; } 
public Entry < K , Collection < V > > lowerEntry ( K key ) { Entry < K , Collection < V > > entry = sortedMap ( ) .lowerEntry ( key ) ; return ( entry == null ) ? null : wrapEntry ( entry ) ; } 
public K lowerKey ( K key ) { return sortedMap ( ) .lowerKey ( key ) ; } 
public Entry < K , Collection < V > > floorEntry ( K key ) { Entry < K , Collection < V > > entry = sortedMap ( ) .floorEntry ( key ) ; return ( entry == null ) ? null : wrapEntry ( entry ) ; } 
public K floorKey ( K key ) { return sortedMap ( ) .floorKey ( key ) ; } 
public Entry < K , Collection < V > > ceilingEntry ( K key ) { Entry < K , Collection < V > > entry = sortedMap ( ) .ceilingEntry ( key ) ; return ( entry == null ) ? null : wrapEntry ( entry ) ; } 
public K ceilingKey ( K key ) { return sortedMap ( ) .ceilingKey ( key ) ; } 
public Entry < K , Collection < V > > higherEntry ( K key ) { Entry < K , Collection < V > > entry = sortedMap ( ) .higherEntry ( key ) ; return ( entry == null ) ? null : wrapEntry ( entry ) ; } 
public K higherKey ( K key ) { return sortedMap ( ) .higherKey ( key ) ; } 
public Entry < K , Collection < V > > firstEntry ( ) { Entry < K , Collection < V > > entry = sortedMap ( ) .firstEntry ( ) ; return ( entry == null ) ? null : wrapEntry ( entry ) ; } 
public Entry < K , Collection < V > > lastEntry ( ) { Entry < K , Collection < V > > entry = sortedMap ( ) .lastEntry ( ) ; return ( entry == null ) ? null : wrapEntry ( entry ) ; } 
public Entry < K , Collection < V > > pollFirstEntry ( ) { return pollAsMapEntry ( entrySet ( ) .iterator ( ) ) ; } 
public Entry < K , Collection < V > > pollLastEntry ( ) { return pollAsMapEntry ( descendingMap ( ) .entrySet ( ) .iterator ( ) ) ; } 
public NavigableMap < K , Collection < V > > descendingMap ( ) { return new NavigableAsMap ( sortedMap ( ) .descendingMap ( ) ) ; }
public NavigableSet < K > keySet ( ) { return ( NavigableSet < K > ) super.keySet ( ) ; } 
NavigableSet < K > createKeySet ( ) { return new NavigableKeySet ( sortedMap ( ) ) ; } 
public NavigableSet < K > navigableKeySet ( ) { return keySet ( ) ; } 
public NavigableSet < K > descendingKeySet ( ) { return descendingMap ( ) .navigableKeySet ( ) ; } 
public NavigableMap < K , Collection < V > > subMap ( K fromKey , K toKey ) { return subMap ( fromKey , true , toKey , false ) ; } 
public NavigableMap < K , Collection < V > > headMap ( K toKey ) { return headMap ( toKey , false ) ; } 
public NavigableMap < K , Collection < V > > headMap ( K toKey , boolean inclusive ) { return new NavigableAsMap ( sortedMap ( ) .headMap ( toKey , inclusive ) ) ; } 
public NavigableMap < K , Collection < V > > tailMap ( K fromKey ) { return tailMap ( fromKey , true ) ; } 
public NavigableMap < K , Collection < V > > tailMap ( K fromKey , boolean inclusive ) { return new NavigableAsMap ( sortedMap ( ) .tailMap ( fromKey , inclusive ) ) ; } 
void setBackingMap ( Map < E , Count > backingMap ) { this.backingMap = backingMap ; } 
public Set < Multiset.Entry < E > > entrySet ( ) { return super.entrySet ( ) ; } 
public boolean hasNext ( ) { return backingEntries.hasNext ( ) ; } 
public E next ( ) { final Map.Entry < E , Count > mapEntry = backingEntries.next ( ) ; toRemove = mapEntry ; return mapEntry.getKey ( ) ; } 
public void remove ( ) { checkRemove ( toRemove != null ) ; size -= toRemove.getValue ( ) .getAndSet ( 0 ) ; backingEntries.remove ( ) ; toRemove = null ; } 
public E getElement ( ) { return mapEntry.getKey ( ) ; } 
public int getCount ( ) { Count count = mapEntry.getValue ( ) ; if ( count == null || count.get ( ) == 0 ) { Count frequency = backingMap.get ( getElement ( ) ) ; if ( frequency != null ) { return frequency.get ( ) ; } } return ( count == null ) ? 0 : count.get ( ) ; } 
public void forEachEntry ( ObjIntConsumer < ? super E > action ) { checkNotNull ( action ) ; backingMap.forEach ( ( element , count ) - > action.accept ( element , count.get ( ) ) ) ; } 
public void clear ( ) { for ( Count frequency : backingMap.values ( ) ) { frequency.set ( 0 ) ; } backingMap.clear ( ) ; size = 0L ; } 
int distinctElements ( ) { return backingMap.size ( ) ; } 
public int size ( ) { return Ints.saturatedCast ( size ) ; } 
public Iterator < E > iterator ( ) { return new MapBasedMultisetIterator ( ) ; } 
public boolean hasNext ( ) { return occurrencesLeft > 0 || entryIterator.hasNext ( ) ; } 
public E next ( ) { if ( occurrencesLeft == 0 ) { currentEntry = entryIterator.next ( ) ; occurrencesLeft = currentEntry.getValue ( ) .get ( ) ; } occurrencesLeft-- ; canRemove = true ; return currentEntry.getKey ( ) ; } 
public void remove ( ) { checkRemove ( canRemove ) ; int frequency = currentEntry.getValue ( ) .get ( ) ; if ( frequency < = 0 ) { throw new ConcurrentModificationException ( ) ; } if ( currentEntry.getValue ( ) .addAndGet ( -1 ) == 0 ) { entryIterator.remove ( ) ; } size-- ; canRemove = false ; } 
public int count ( @Nullable Object element ) { Count frequency = Maps.safeGet ( backingMap , element ) ; return ( frequency == null ) ? 0 : frequency.get ( ) ; } 
private void readObjectNoData ( ) throws ObjectStreamException { throw new InvalidObjectException ( " Stream data required " ) ; }
public V setValue ( V value ) { throw new UnsupportedOperationException ( ) ; } 
public boolean isEmpty ( ) { return size ( ) == 0 ; } 
public boolean containsValue ( @Nullable Object value ) { for ( Collection < V > collection : asMap ( ) .values ( ) ) { if ( collection.contains ( value ) ) { return true ; } } return false ; } 
public boolean containsEntry ( @Nullable Object key , @Nullable Object value ) { Collection < V > collection = asMap ( ) .get ( key ) ; return collection != null && collection.contains ( value ) ; } 
public boolean remove ( @Nullable Object key , @Nullable Object value ) { Collection < V > collection = asMap ( ) .get ( key ) ; return collection != null && collection.remove ( value ) ; } 
public boolean put ( @Nullable K key , @Nullable V value ) { return get ( key ) .add ( value ) ; } 
public boolean putAll ( @Nullable K key , Iterable < ? extends V > values ) { checkNotNull ( values ) ; if ( values instanceof Collection ) { Collection < ? extends V > valueCollection = ( Collection < ? extends V > ) values ; return !valueCollection.isEmpty ( ) && get ( key ) .addAll ( valueCollection ) ; } else { Iterator < ? extends V > valueItr = values.iterator ( ) ; return valueItr.hasNext ( ) && Iterators.addAll ( get ( key ) , valueItr ) ; } } 
public boolean putAll ( Multimap < ? extends K , ? extends V > multimap ) { boolean changed = false ; for ( Entry < ? extends K , ? extends V > entry : multimap.entries ( ) ) { changed |= put ( entry.getKey ( ) , entry.getValue ( ) ) ; } return changed ; } 
public Collection < V > replaceValues ( @Nullable K key , Iterable < ? extends V > values ) { checkNotNull ( values ) ; Collection < V > result = removeAll ( key ) ; putAll ( key , values ) ; return result ; } 
public Collection < Entry < K , V > > entries ( ) { Collection < Entry < K , V > > result = entries ; return ( result == null ) ? entries = createEntries ( ) : result ; } 
Multimap < K , V > multimap ( ) { return AbstractMultimap.this ; } 
public Iterator < Entry < K , V > > iterator ( ) { return entryIterator ( ) ; } 
public Spliterator < Entry < K , V > > spliterator ( ) { return entrySpliterator ( ) ; } 
public boolean equals ( @Nullable Object obj ) { return Sets.equalsImpl ( this , obj ) ; }
Spliterator < Entry < K , V > > entrySpliterator ( ) { return Spliterators.spliterator ( entryIterator ( ) , size ( ) , ( this instanceof SetMultimap ) ? Spliterator.DISTINCT : 0 ) ; } 
public Set < K > keySet ( ) { Set < K > result = keySet ; return ( result == null ) ? keySet = createKeySet ( ) : result ; } 
public Multiset < K > keys ( ) { Multiset < K > result = keys ; return ( result == null ) ? keys = createKeys ( ) : result ; } 
public Collection < V > values ( ) { Collection < V > result = values ; return ( result == null ) ? values = createValues ( ) : result ; } 
public Iterator < V > iterator ( ) { return valueIterator ( ) ; } 
public Spliterator < V > spliterator ( ) { return valueSpliterator ( ) ; } 
public int size ( ) { return AbstractMultimap.this.size ( ) ; } 
public boolean contains ( @Nullable Object o ) { return AbstractMultimap.this.containsValue ( o ) ; } 
public void clear ( ) { AbstractMultimap.this.clear ( ) ; } 
Iterator < V > valueIterator ( ) { return Maps.valueIterator ( entries ( ) .iterator ( ) ) ; } 
Spliterator < V > valueSpliterator ( ) { return Spliterators.spliterator ( valueIterator ( ) , size ( ) , 0 ) ; } 
public Map < K , Collection < V > > asMap ( ) { Map < K , Collection < V > > result = asMap ; return ( result == null ) ? asMap = createAsMap ( ) : result ; } 
public boolean equals ( @Nullable Object object ) { return Multimaps.equalsImpl ( this , object ) ; } 
public boolean isEmpty ( ) { return entrySet ( ) .isEmpty ( ) ; }
public boolean contains ( @Nullable Object element ) { return count ( element ) > 0 ; } 
public final boolean add ( @Nullable E element ) { add ( element , 1 ) ; return true ; } 
public int add ( @Nullable E element , int occurrences ) { throw new UnsupportedOperationException ( ) ; } 
public final boolean remove ( @Nullable Object element ) { return remove ( element , 1 ) > 0 ; } 
public int remove ( @Nullable Object element , int occurrences ) { throw new UnsupportedOperationException ( ) ; } 
public int setCount ( @Nullable E element , int count ) { return setCountImpl ( this , element , count ) ; } 
public boolean setCount ( @Nullable E element , int oldCount , int newCount ) { return setCountImpl ( this , element , oldCount , newCount ) ; } 
public final boolean addAll ( Collection < ? extends E > elementsToAdd ) { return Multisets.addAllImpl ( this , elementsToAdd ) ; } 
public final boolean removeAll ( Collection < ? > elementsToRemove ) { return Multisets.removeAllImpl ( this , elementsToRemove ) ; } 
public final boolean retainAll ( Collection < ? > elementsToRetain ) { return Multisets.retainAllImpl ( this , elementsToRetain ) ; } 
public Set < E > elementSet ( ) { Set < E > result = elementSet ; if ( result == null ) { elementSet = result = createElementSet ( ) ; } return result ; } 
Set < E > createElementSet ( ) { return new ElementSet ( ) ; } 
Multiset < E > multiset ( ) { return AbstractMultiset.this ; } 
public Iterator < E > iterator ( ) { return elementIterator ( ) ; } 
public Set < Entry < E > > entrySet ( ) { Set < Entry < E > > result = entrySet ; if ( result == null ) { entrySet = result = createEntrySet ( ) ; } return result ; } 
public Iterator < Entry < E > > iterator ( ) { return entryIterator ( ) ; } 
public int size ( ) { return distinctElements ( ) ; } 
Set < Entry < E > > createEntrySet ( ) { return new EntrySet ( ) ; } 
public final boolean equals ( @Nullable Object object ) { return Multisets.equalsImpl ( this , object ) ; } 
public Entry < K , V > firstEntry ( ) { return Iterators.getNext ( entryIterator ( ) , null ) ; }
public Entry < K , V > lastEntry ( ) { return Iterators.getNext ( descendingEntryIterator ( ) , null ) ; } 
public Entry < K , V > pollFirstEntry ( ) { return Iterators.pollNext ( entryIterator ( ) ) ; } 
public Entry < K , V > pollLastEntry ( ) { return Iterators.pollNext ( descendingEntryIterator ( ) ) ; } 
public K firstKey ( ) { Entry < K , V > entry = firstEntry ( ) ; if ( entry == null ) { throw new NoSuchElementException ( ) ; } else { return entry.getKey ( ) ; } } 
public K lastKey ( ) { Entry < K , V > entry = lastEntry ( ) ; if ( entry == null ) { throw new NoSuchElementException ( ) ; } else { return entry.getKey ( ) ; } } 
public Entry < K , V > lowerEntry ( K key ) { return headMap ( key , false ) .lastEntry ( ) ; } 
public Entry < K , V > floorEntry ( K key ) { return headMap ( key , true ) .lastEntry ( ) ; } 
public Entry < K , V > ceilingEntry ( K key ) { return tailMap ( key , true ) .firstEntry ( ) ; } 
public Entry < K , V > higherEntry ( K key ) { return tailMap ( key , false ) .firstEntry ( ) ; } 
public K lowerKey ( K key ) { return Maps.keyOrNull ( lowerEntry ( key ) ) ; } 
public K floorKey ( K key ) { return Maps.keyOrNull ( floorEntry ( key ) ) ; } 
public K ceilingKey ( K key ) { return Maps.keyOrNull ( ceilingEntry ( key ) ) ; } 
public K higherKey ( K key ) { return Maps.keyOrNull ( higherEntry ( key ) ) ; } 
public SortedMap < K , V > subMap ( K fromKey , K toKey ) { return subMap ( fromKey , true , toKey , false ) ; } 
public SortedMap < K , V > headMap ( K toKey ) { return headMap ( toKey , false ) ; } 
public SortedMap < K , V > tailMap ( K fromKey ) { return tailMap ( fromKey , true ) ; } 
public NavigableSet < K > navigableKeySet ( ) { return new Maps.NavigableKeySet < > ( this ) ; } 
public Set < K > keySet ( ) { return navigableKeySet ( ) ; } 
public NavigableMap < K , V > descendingMap ( ) { return new DescendingMap ( ) ; } 
NavigableMap < K , V > forward ( ) { return AbstractNavigableMap.this ; } 
Iterator < Entry < K , V > > entryIterator ( ) { return descendingEntryIterator ( ) ; } 
public boolean contains ( C value ) { return rangeContaining ( value ) != null ; } 
public boolean isEmpty ( ) { return asRanges ( ) .isEmpty ( ) ; } 
public void add ( Range < C > range ) { throw new UnsupportedOperationException ( ) ; } 
public void remove ( Range < C > range ) { throw new UnsupportedOperationException ( ) ; } 
public void clear ( ) { remove ( Range. < C > all ( ) ) ; } 
public boolean enclosesAll ( RangeSet < C > other ) { return enclosesAll ( other.asRanges ( ) ) ; } 
public void addAll ( RangeSet < C > other ) { addAll ( other.asRanges ( ) ) ; } 
public void removeAll ( RangeSet < C > other ) { removeAll ( other.asRanges ( ) ) ; } 
public boolean intersects ( Range < C > otherRange ) { return !subRangeSet ( otherRange ) .isEmpty ( ) ; } 
public boolean equals ( @Nullable Object obj ) { if ( obj == this ) { return true ; } else if ( obj instanceof RangeSet ) { RangeSet < ? > other = ( RangeSet < ? > ) obj ; return this.asRanges ( ) .equals ( other.asRanges ( ) ) ; } return false ; } 
public final boolean hasNext ( ) { return nextOrNull != null ; }
public final T next ( ) { if ( !hasNext ( ) ) { throw new NoSuchElementException ( ) ; } try { return nextOrNull ; } finally { nextOrNull = computeNext ( nextOrNull ) ; } } 
Set < V > createUnmodifiableEmptyCollection ( ) { return Collections.emptySet ( ) ; } 
 < E > Collection < E > unmodifiableCollectionSubclass ( Collection < E > collection ) { return Collections.unmodifiableSet ( ( Set < E > ) collection ) ; } 
Collection < V > wrapCollection ( K key , Collection < V > collection ) { return new WrappedSet ( key , ( Set < V > ) collection ) ; } 
public Set < V > get ( @Nullable K key ) { return ( Set < V > ) super.get ( key ) ; } 
public Set < Entry < K , V > > entries ( ) { return ( Set < Entry < K , V > > ) super.entries ( ) ; } 
public Set < V > removeAll ( @Nullable Object key ) { return ( Set < V > ) super.removeAll ( key ) ; } 
public Set < V > replaceValues ( @Nullable K key , Iterable < ? extends V > values ) { return ( Set < V > ) super.replaceValues ( key , values ) ; } 
public SortedMap < K , Collection < V > > asMap ( ) { return ( SortedMap < K , Collection < V > > ) super.asMap ( ) ; } 
SortedMap < K , Collection < V > > backingMap ( ) { return ( SortedMap < K , Collection < V > > ) super.backingMap ( ) ; } 
public SortedSet < K > keySet ( ) { return ( SortedSet < K > ) super.keySet ( ) ; } 
Set < K > createKeySet ( ) { return createMaybeNavigableKeySet ( ) ; } 
public NavigableSet < E > elementSet ( ) { return ( NavigableSet < E > ) super.elementSet ( ) ; } 
NavigableSet < E > createElementSet ( ) { return new SortedMultisets.NavigableElementSet < E > ( this ) ; } 
public Comparator < ? super E > comparator ( ) { return comparator ; } 
public Entry < E > firstEntry ( ) { Iterator < Entry < E > > entryIterator = entryIterator ( ) ; return entryIterator.hasNext ( ) ? entryIterator.next ( ) : null ; } 
public Entry < E > lastEntry ( ) { Iterator < Entry < E > > entryIterator = descendingEntryIterator ( ) ; return entryIterator.hasNext ( ) ? entryIterator.next ( ) : null ; } 
Iterator < E > descendingIterator ( ) { return Multisets.iteratorImpl ( descendingMultiset ( ) ) ; }
public SortedMultiset < E > descendingMultiset ( ) { SortedMultiset < E > result = descendingMultiset ; return ( result == null ) ? descendingMultiset = createDescendingMultiset ( ) : result ; } 
SortedMultiset < E > forwardMultiset ( ) { return AbstractSortedMultiset.this ; } 
Iterator < Entry < E > > entryIterator ( ) { return descendingEntryIterator ( ) ; } 
public Iterator < E > iterator ( ) { return descendingIterator ( ) ; } 
SortedSet < V > createUnmodifiableEmptyCollection ( ) { return unmodifiableCollectionSubclass ( createCollection ( ) ) ; } 
 < E > SortedSet < E > unmodifiableCollectionSubclass ( Collection < E > collection ) { if ( collection instanceof NavigableSet ) { return Sets.unmodifiableNavigableSet ( ( NavigableSet < E > ) collection ) ; } else { return Collections.unmodifiableSortedSet ( ( SortedSet < E > ) collection ) ; } } 
Collection < V > wrapCollection ( K key , Collection < V > collection ) { if ( collection instanceof NavigableSet ) { return new WrappedNavigableSet ( key , ( NavigableSet < V > ) collection , null ) ; } else { return new WrappedSortedSet ( key , ( SortedSet < V > ) collection , null ) ; } } 
public SortedSet < V > get ( @Nullable K key ) { return ( SortedSet < V > ) super.get ( key ) ; } 
public SortedSet < V > removeAll ( @Nullable Object key ) { return ( SortedSet < V > ) super.removeAll ( key ) ; } 
public SortedSet < V > replaceValues ( @Nullable K key , Iterable < ? extends V > values ) { return ( SortedSet < V > ) super.replaceValues ( key , values ) ; } 
public boolean containsRow ( @Nullable Object rowKey ) { return Maps.safeContainsKey ( rowMap ( ) , rowKey ) ; } 
public boolean containsColumn ( @Nullable Object columnKey ) { return Maps.safeContainsKey ( columnMap ( ) , columnKey ) ; } 
public Set < R > rowKeySet ( ) { return rowMap ( ) .keySet ( ) ; } 
public Set < C > columnKeySet ( ) { return columnMap ( ) .keySet ( ) ; } 
public boolean containsValue ( @Nullable Object value ) { for ( Map < C , V > row : rowMap ( ) .values ( ) ) { if ( row.containsValue ( value ) ) { return true ; } } return false ; } 
public boolean contains ( @Nullable Object rowKey , @Nullable Object columnKey ) { Map < C , V > row = Maps.safeGet ( rowMap ( ) , rowKey ) ; return row != null && Maps.safeContainsKey ( row , columnKey ) ; } 
public V get ( @Nullable Object rowKey , @Nullable Object columnKey ) { Map < C , V > row = Maps.safeGet ( rowMap ( ) , rowKey ) ; return ( row == null ) ? null : Maps.safeGet ( row , columnKey ) ; } 
public void clear ( ) { Iterators.clear ( cellSet ( ) .iterator ( ) ) ; } 
public V remove ( @Nullable Object rowKey , @Nullable Object columnKey ) { Map < C , V > row = Maps.safeGet ( rowMap ( ) , rowKey ) ; return ( row == null ) ? null : Maps.safeRemove ( row , columnKey ) ; } 
public V put ( R rowKey , C columnKey , V value ) { return row ( rowKey ) .put ( columnKey , value ) ; } 
public void putAll ( Table < ? extends R , ? extends C , ? extends V > table ) { for ( Table.Cell < ? extends R , ? extends C , ? extends V > cell : table.cellSet ( ) ) { put ( cell.getRowKey ( ) , cell.getColumnKey ( ) , cell.getValue ( ) ) ; } } 
public Set < Cell < R , C , V > > cellSet ( ) { Set < Cell < R , C , V > > result = cellSet ; return ( result == null ) ? cellSet = createCellSet ( ) : result ; } 
Set < Cell < R , C , V > > createCellSet ( ) { return new CellSet ( ) ; } 
public boolean contains ( Object o ) { if ( o instanceof Cell ) { Cell < ? , ? , ? > cell = ( Cell < ? , ? , ? > ) o ; Map < C , V > row = Maps.safeGet ( rowMap ( ) , cell.getRowKey ( ) ) ; return row != null && Collections2.safeContains ( row.entrySet ( ) , Maps.immutableEntry ( cell.getColumnKey ( ) , cell.getValue ( ) ) ) ; } return false ; } 
public boolean remove ( @Nullable Object o ) { if ( o instanceof Cell ) { Cell < ? , ? , ? > cell = ( Cell < ? , ? , ? > ) o ; Map < C , V > row = Maps.safeGet ( rowMap ( ) , cell.getRowKey ( ) ) ; return row != null && Collections2.safeRemove ( row.entrySet ( ) , Maps.immutableEntry ( cell.getColumnKey ( ) , cell.getValue ( ) ) ) ; } return false ; } 
public void clear ( ) { AbstractTable.this.clear ( ) ; } 
public Iterator < Table.Cell < R , C , V > > iterator ( ) { return cellIterator ( ) ; } 
public Spliterator < Cell < R , C , V > > spliterator ( ) { return cellSpliterator ( ) ; } 
public int size ( ) { return AbstractTable.this.size ( ) ; } 

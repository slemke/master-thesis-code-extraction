public Date read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } Date date = deserializeToDate ( in.nextString ( ) ) ; if ( dateType == Date.class ) { return date ; } else if ( dateType == Timestamp.class ) { return new Timestamp ( date.getTime ( ) ) ; } else if ( dateType == java.sql.Date.class ) { return new java.sql.Date ( date.getTime ( ) ) ; } else { throw new AssertionError ( ) ; } } 
private Date deserializeToDate ( String s ) { synchronized ( dateFormats ) { for ( DateFormat dateFormat : dateFormats ) { try { return dateFormat.parse ( s ) ; } catch ( ParseException ignored ) { } } try { return ISO8601Utils.parse ( s , new ParsePosition ( 0 ) ) ; } catch ( ParseException e ) { throw new JsonSyntaxException ( s , e ) ; } } } 
static String upperCaseFirstLetter ( String name ) { StringBuilder fieldNameBuilder = new StringBuilder ( ) ; int index = 0 ; char firstCharacter = name.charAt ( index ) ; int length = name.length ( ) ; while ( index < length - 1 ) { if ( Character.isLetter ( firstCharacter ) ) { break ; } fieldNameBuilder.append ( firstCharacter ) ; firstCharacter = name.charAt ( ++index ) ; } if ( !Character.isUpperCase ( firstCharacter ) ) { String modifiedTarget = modifyString ( Character.toUpperCase ( firstCharacter ) , name , ++index ) ; return fieldNameBuilder.append ( modifiedTarget ) .toString ( ) ; } else { return name ; } } 
private TypeAdapter < Number > doubleAdapter ( boolean serializeSpecialFloatingPointValues ) { if ( serializeSpecialFloatingPointValues ) { return TypeAdapters.DOUBLE ; } return new TypeAdapter < Number > ( ) { @Override public Double read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } return in.nextDouble ( ) ; } @Override public void write ( JsonWriter out , Number value ) throws IOException { if ( value == null ) { out.nullValue ( ) ; return ; } double doubleValue = value.doubleValue ( ) ; checkValidFloatingPoint ( doubleValue ) ; out.value ( value ) ; } } ; } 
private TypeAdapter < Number > floatAdapter ( boolean serializeSpecialFloatingPointValues ) { if ( serializeSpecialFloatingPointValues ) { return TypeAdapters.FLOAT ; } return new TypeAdapter < Number > ( ) { @Override public Float read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } return ( float ) in.nextDouble ( ) ; } @Override public void write ( JsonWriter out , Number value ) throws IOException { if ( value == null ) { out.nullValue ( ) ; return ; } float floatValue = value.floatValue ( ) ; checkValidFloatingPoint ( floatValue ) ; out.value ( value ) ; } } ; } 
private static TypeAdapter < Number > longAdapter ( LongSerializationPolicy longSerializationPolicy ) { if ( longSerializationPolicy == LongSerializationPolicy.DEFAULT ) { return TypeAdapters.LONG ; } return new TypeAdapter < Number > ( ) { @Override public Number read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } return in.nextLong ( ) ; } @Override public void write ( JsonWriter out , Number value ) throws IOException { if ( value == null ) { out.nullValue ( ) ; return ; } out.value ( value.toString ( ) ) ; } } ; } 
private static TypeAdapter < AtomicLong > atomicLongAdapter ( final TypeAdapter < Number > longAdapter ) { return new TypeAdapter < AtomicLong > ( ) { @Override public void write ( JsonWriter out , AtomicLong value ) throws IOException { longAdapter.write ( out , value.get ( ) ) ; } @Override public AtomicLong read ( JsonReader in ) throws IOException { Number value = longAdapter.read ( in ) ; return new AtomicLong ( value.longValue ( ) ) ; } } .nullSafe ( ) ; } 
private static TypeAdapter < AtomicLongArray > atomicLongArrayAdapter ( final TypeAdapter < Number > longAdapter ) { return new TypeAdapter < AtomicLongArray > ( ) { @Override public void write ( JsonWriter out , AtomicLongArray value ) throws IOException { out.beginArray ( ) ; for ( int i = 0 , length = value.length ( ) ; i < length ; i++ ) { longAdapter.write ( out , value.get ( i ) ) ; } out.endArray ( ) ; } @Override public AtomicLongArray read ( JsonReader in ) throws IOException { List < Long > list = new ArrayList < Long > ( ) ; in.beginArray ( ) ; while ( in.hasNext ( ) ) { long value = longAdapter.read ( in ) .longValue ( ) ; list.add ( value ) ; } in.endArray ( ) ; int length = list.size ( ) ; AtomicLongArray array = new AtomicLongArray ( length ) ; for ( int i = 0 ; i < length ; ++i ) { array.set ( i , list.get ( i ) ) ; } return array ; } } .nullSafe ( ) ; } 
public < T > TypeAdapter < T > getAdapter ( TypeToken < T > type ) { TypeAdapter < ? > cached = typeTokenCache.get ( type == null ? NULL_KEY_SURROGATE : type ) ; if ( cached != null ) { return ( TypeAdapter < T > ) cached ; } Map < TypeToken < ? > , FutureTypeAdapter < ? > > threadCalls = calls.get ( ) ; boolean requiresThreadLocalCleanup = false ; if ( threadCalls == null ) { threadCalls = new HashMap < TypeToken < ? > , FutureTypeAdapter < ? > > ( ) ; calls.set ( threadCalls ) ; requiresThreadLocalCleanup = true ; } FutureTypeAdapter < T > ongoingCall = ( FutureTypeAdapter < T > ) threadCalls.get ( type ) ; if ( ongoingCall != null ) { return ongoingCall ; } try { FutureTypeAdapter < T > call = new FutureTypeAdapter < T > ( ) ; threadCalls.put ( type , call ) ; for ( TypeAdapterFactory factory : factories ) { TypeAdapter < T > candidate = factory.create ( this , type ) ; if ( candidate != null ) { call.setDelegate ( candidate ) ; typeTokenCache.put ( type , candidate ) ; return candidate ; } } throw new IllegalArgumentException ( " GSON ( " + GsonBuildConfig.VERSION + " ) cannot handle " + type ) ; } finally { threadCalls.remove ( type ) ; if ( requiresThreadLocalCleanup ) { calls.remove ( ) ; } } } 
public < T > TypeAdapter < T > getDelegateAdapter ( TypeAdapterFactory skipPast , TypeToken < T > type ) { if ( !factories.contains ( skipPast ) ) { skipPast = jsonAdapterFactory ; } boolean skipPastFound = false ; for ( TypeAdapterFactory factory : factories ) { if ( !skipPastFound ) { if ( factory == skipPast ) { skipPastFound = true ; } continue ; } TypeAdapter < T > candidate = factory.create ( this , type ) ; if ( candidate != null ) { return candidate ; } } throw new IllegalArgumentException ( " GSON cannot serialize " + type ) ; } 
public void toJson ( Object src , Type typeOfSrc , JsonWriter writer ) throws JsonIOException { TypeAdapter < ? > adapter = getAdapter ( TypeToken.get ( typeOfSrc ) ) ; boolean oldLenient = writer.isLenient ( ) ; writer.setLenient ( true ) ; boolean oldHtmlSafe = writer.isHtmlSafe ( ) ; writer.setHtmlSafe ( htmlSafe ) ; boolean oldSerializeNulls = writer.getSerializeNulls ( ) ; writer.setSerializeNulls ( serializeNulls ) ; try { ( ( TypeAdapter < Object > ) adapter ) .write ( writer , src ) ; } catch ( IOException e ) { throw new JsonIOException ( e ) ; } catch ( AssertionError e ) { throw new AssertionError ( " AssertionError ( GSON " + GsonBuildConfig.VERSION + " ) : " + e.getMessage ( ) , e ) ; } finally { writer.setLenient ( oldLenient ) ; writer.setHtmlSafe ( oldHtmlSafe ) ; writer.setSerializeNulls ( oldSerializeNulls ) ; } } 
public void toJson ( JsonElement jsonElement , JsonWriter writer ) throws JsonIOException { boolean oldLenient = writer.isLenient ( ) ; writer.setLenient ( true ) ; boolean oldHtmlSafe = writer.isHtmlSafe ( ) ; writer.setHtmlSafe ( htmlSafe ) ; boolean oldSerializeNulls = writer.getSerializeNulls ( ) ; writer.setSerializeNulls ( serializeNulls ) ; try { Streams.write ( jsonElement , writer ) ; } catch ( IOException e ) { throw new JsonIOException ( e ) ; } catch ( AssertionError e ) { throw new AssertionError ( " AssertionError ( GSON " + GsonBuildConfig.VERSION + " ) : " + e.getMessage ( ) , e ) ; } finally { writer.setLenient ( oldLenient ) ; writer.setHtmlSafe ( oldHtmlSafe ) ; writer.setSerializeNulls ( oldSerializeNulls ) ; } } 
public < T > T fromJson ( JsonReader reader , Type typeOfT ) throws JsonIOException , JsonSyntaxException { boolean isEmpty = true ; boolean oldLenient = reader.isLenient ( ) ; reader.setLenient ( true ) ; try { reader.peek ( ) ; isEmpty = false ; TypeToken < T > typeToken = ( TypeToken < T > ) TypeToken.get ( typeOfT ) ; TypeAdapter < T > typeAdapter = getAdapter ( typeToken ) ; T object = typeAdapter.read ( reader ) ; return object ; } catch ( EOFException e ) { if ( isEmpty ) { return null ; } throw new JsonSyntaxException ( e ) ; } catch ( IllegalStateException e ) { throw new JsonSyntaxException ( e ) ; } catch ( IOException e ) { throw new JsonSyntaxException ( e ) ; } catch ( AssertionError e ) { throw new AssertionError ( " AssertionError ( GSON " + GsonBuildConfig.VERSION + " ) : " + e.getMessage ( ) , e ) ; } finally { reader.setLenient ( oldLenient ) ; } } 
public GsonBuilder registerTypeAdapter ( Type type , Object typeAdapter ) { $Gson$Preconditions.checkArgument ( typeAdapter instanceof JsonSerializer < ? > || typeAdapter instanceof JsonDeserializer < ? > || typeAdapter instanceof InstanceCreator < ? > || typeAdapter instanceof TypeAdapter < ? > ) ; if ( typeAdapter instanceof InstanceCreator < ? > ) { instanceCreators.put ( type , ( InstanceCreator ) typeAdapter ) ; } if ( typeAdapter instanceof JsonSerializer < ? > || typeAdapter instanceof JsonDeserializer < ? > ) { TypeToken < ? > typeToken = TypeToken.get ( type ) ; factories.add ( TreeTypeAdapter.newFactoryWithMatchRawType ( typeToken , typeAdapter ) ) ; } if ( typeAdapter instanceof TypeAdapter < ? > ) { factories.add ( TypeAdapters.newFactory ( TypeToken.get ( type ) , ( TypeAdapter ) typeAdapter ) ) ; } return this ; } 
public GsonBuilder registerTypeHierarchyAdapter ( Class < ? > baseType , Object typeAdapter ) { $Gson$Preconditions.checkArgument ( typeAdapter instanceof JsonSerializer < ? > || typeAdapter instanceof JsonDeserializer < ? > || typeAdapter instanceof TypeAdapter < ? > ) ; if ( typeAdapter instanceof JsonDeserializer || typeAdapter instanceof JsonSerializer ) { hierarchyFactories.add ( TreeTypeAdapter.newTypeHierarchyFactory ( baseType , typeAdapter ) ) ; } if ( typeAdapter instanceof TypeAdapter < ? > ) { factories.add ( TypeAdapters.newTypeHierarchyFactory ( baseType , ( TypeAdapter ) typeAdapter ) ) ; } return this ; } 
private void addTypeAdaptersForDate ( String datePattern , int dateStyle , int timeStyle , List < TypeAdapterFactory > factories ) { DefaultDateTypeAdapter dateTypeAdapter ; TypeAdapter < Timestamp > timestampTypeAdapter ; TypeAdapter < java.sql.Date > javaSqlDateTypeAdapter ; if ( datePattern != null && ! " " .equals ( datePattern.trim ( ) ) ) { dateTypeAdapter = new DefaultDateTypeAdapter ( Date.class , datePattern ) ; timestampTypeAdapter = ( TypeAdapter ) new DefaultDateTypeAdapter ( Timestamp.class , datePattern ) ; javaSqlDateTypeAdapter = ( TypeAdapter ) new DefaultDateTypeAdapter ( java.sql.Date.class , datePattern ) ; } else if ( dateStyle != DateFormat.DEFAULT && timeStyle != DateFormat.DEFAULT ) { dateTypeAdapter = new DefaultDateTypeAdapter ( Date.class , dateStyle , timeStyle ) ; timestampTypeAdapter = ( TypeAdapter ) new DefaultDateTypeAdapter ( Timestamp.class , dateStyle , timeStyle ) ; javaSqlDateTypeAdapter = ( TypeAdapter ) new DefaultDateTypeAdapter ( java.sql.Date.class , dateStyle , timeStyle ) ; } else { return ; } factories.add ( TypeAdapters.newFactory ( Date.class , dateTypeAdapter ) ) ; factories.add ( TypeAdapters.newFactory ( Timestamp.class , timestampTypeAdapter ) ) ; factories.add ( TypeAdapters.newFactory ( java.sql.Date.class , javaSqlDateTypeAdapter ) ) ; } 
public static Type canonicalize ( Type type ) { if ( type instanceof Class ) { Class < ? > c = ( Class < ? > ) type ; return c.isArray ( ) ? new GenericArrayTypeImpl ( canonicalize ( c.getComponentType ( ) ) ) : c ; } else if ( type instanceof ParameterizedType ) { ParameterizedType p = ( ParameterizedType ) type ; return new ParameterizedTypeImpl ( p.getOwnerType ( ) , p.getRawType ( ) , p.getActualTypeArguments ( ) ) ; } else if ( type instanceof GenericArrayType ) { GenericArrayType g = ( GenericArrayType ) type ; return new GenericArrayTypeImpl ( g.getGenericComponentType ( ) ) ; } else if ( type instanceof WildcardType ) { WildcardType w = ( WildcardType ) type ; return new WildcardTypeImpl ( w.getUpperBounds ( ) , w.getLowerBounds ( ) ) ; } else { return type ; } } 
public static Class < ? > getRawType ( Type type ) { if ( type instanceof Class < ? > ) { return ( Class < ? > ) type ; } else if ( type instanceof ParameterizedType ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ; Type rawType = parameterizedType.getRawType ( ) ; checkArgument ( rawType instanceof Class ) ; return ( Class < ? > ) rawType ; } else if ( type instanceof GenericArrayType ) { Type componentType = ( ( GenericArrayType ) type ) .getGenericComponentType ( ) ; return Array.newInstance ( getRawType ( componentType ) , 0 ) .getClass ( ) ; } else if ( type instanceof TypeVariable ) { return Object.class ; } else if ( type instanceof WildcardType ) { return getRawType ( ( ( WildcardType ) type ) .getUpperBounds ( ) [0] ) ; } else { String className = type == null ? " null " : type.getClass ( ) .getName ( ) ; throw new IllegalArgumentException ( " Expected a Class , ParameterizedType , or " + " GenericArrayType , but < " + type + " > is of type " + className ) ; } } 
public static boolean equals ( Type a , Type b ) { if ( a == b ) { return true ; } else if ( a instanceof Class ) { return a.equals ( b ) ; } else if ( a instanceof ParameterizedType ) { if ( ! ( b instanceof ParameterizedType ) ) { return false ; } ParameterizedType pa = ( ParameterizedType ) a ; ParameterizedType pb = ( ParameterizedType ) b ; return equal ( pa.getOwnerType ( ) , pb.getOwnerType ( ) ) && pa.getRawType ( ) .equals ( pb.getRawType ( ) ) && Arrays.equals ( pa.getActualTypeArguments ( ) , pb.getActualTypeArguments ( ) ) ; } else if ( a instanceof GenericArrayType ) { if ( ! ( b instanceof GenericArrayType ) ) { return false ; } GenericArrayType ga = ( GenericArrayType ) a ; GenericArrayType gb = ( GenericArrayType ) b ; return equals ( ga.getGenericComponentType ( ) , gb.getGenericComponentType ( ) ) ; } else if ( a instanceof WildcardType ) { if ( ! ( b instanceof WildcardType ) ) { return false ; } WildcardType wa = ( WildcardType ) a ; WildcardType wb = ( WildcardType ) b ; return Arrays.equals ( wa.getUpperBounds ( ) , wb.getUpperBounds ( ) ) && Arrays.equals ( wa.getLowerBounds ( ) , wb.getLowerBounds ( ) ) ; } else if ( a instanceof TypeVariable ) { if ( ! ( b instanceof TypeVariable ) ) { return false ; } TypeVariable < ? > va = ( TypeVariable < ? > ) a ; TypeVariable < ? > vb = ( TypeVariable < ? > ) b ; return va.getGenericDeclaration ( ) == vb.getGenericDeclaration ( ) && va.getName ( ) .equals ( vb.getName ( ) ) ; } else { return false ; } } 
static Type getGenericSupertype ( Type context , Class < ? > rawType , Class < ? > toResolve ) { if ( toResolve == rawType ) { return context ; } if ( toResolve.isInterface ( ) ) { Class < ? > [] interfaces = rawType.getInterfaces ( ) ; for ( int i = 0 , length = interfaces.length ; i < length ; i++ ) { if ( interfaces[i] == toResolve ) { return rawType.getGenericInterfaces ( ) [i] ; } else if ( toResolve.isAssignableFrom ( interfaces[i] ) ) { return getGenericSupertype ( rawType.getGenericInterfaces ( ) [i] , interfaces[i] , toResolve ) ; } } } if ( !rawType.isInterface ( ) ) { while ( rawType != Object.class ) { Class < ? > rawSupertype = rawType.getSuperclass ( ) ; if ( rawSupertype == toResolve ) { return rawType.getGenericSuperclass ( ) ; } else if ( toResolve.isAssignableFrom ( rawSupertype ) ) { return getGenericSupertype ( rawType.getGenericSuperclass ( ) , rawSupertype , toResolve ) ; } rawType = rawSupertype ; } } return toResolve ; } 
private static Type resolve ( Type context , Class < ? > contextRawType , Type toResolve , Collection < TypeVariable > visitedTypeVariables ) { while ( true ) { if ( toResolve instanceof TypeVariable ) { TypeVariable < ? > typeVariable = ( TypeVariable < ? > ) toResolve ; if ( visitedTypeVariables.contains ( typeVariable ) ) { return toResolve ; } else { visitedTypeVariables.add ( typeVariable ) ; } toResolve = resolveTypeVariable ( context , contextRawType , typeVariable ) ; if ( toResolve == typeVariable ) { return toResolve ; } } else if ( toResolve instanceof Class && ( ( Class < ? > ) toResolve ) .isArray ( ) ) { Class < ? > original = ( Class < ? > ) toResolve ; Type componentType = original.getComponentType ( ) ; Type newComponentType = resolve ( context , contextRawType , componentType , visitedTypeVariables ) ; return componentType == newComponentType ? original : arrayOf ( newComponentType ) ; } else if ( toResolve instanceof GenericArrayType ) { GenericArrayType original = ( GenericArrayType ) toResolve ; Type componentType = original.getGenericComponentType ( ) ; Type newComponentType = resolve ( context , contextRawType , componentType , visitedTypeVariables ) ; return componentType == newComponentType ? original : arrayOf ( newComponentType ) ; } else if ( toResolve instanceof ParameterizedType ) { ParameterizedType original = ( ParameterizedType ) toResolve ; Type ownerType = original.getOwnerType ( ) ; Type newOwnerType = resolve ( context , contextRawType , ownerType , visitedTypeVariables ) ; boolean changed = newOwnerType != ownerType ; Type[] args = original.getActualTypeArguments ( ) ; for ( int t = 0 , length = args.length ; t < length ; t++ ) { Type resolvedTypeArgument = resolve ( context , contextRawType , args[t] , visitedTypeVariables ) ; if ( resolvedTypeArgument != args[t] ) { if ( !changed ) { args = args.clone ( ) ; changed = true ; } args[t] = resolvedTypeArgument ; } } return changed ? newParameterizedTypeWithOwner ( newOwnerType , original.getRawType ( ) , args ) : original ; } else if ( toResolve instanceof WildcardType ) { WildcardType original = ( WildcardType ) toResolve ; Type[] originalLowerBound = original.getLowerBounds ( ) ; Type[] originalUpperBound = original.getUpperBounds ( ) ; if ( originalLowerBound.length == 1 ) { Type lowerBound = resolve ( context , contextRawType , originalLowerBound[0] , visitedTypeVariables ) ; if ( lowerBound != originalLowerBound[0] ) { return supertypeOf ( lowerBound ) ; } } else if ( originalUpperBound.length == 1 ) { Type upperBound = resolve ( context , contextRawType , originalUpperBound[0] , visitedTypeVariables ) ; if ( upperBound != originalUpperBound[0] ) { return subtypeOf ( upperBound ) ; } } return original ; } else { return toResolve ; } } } 
public Object read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } List < E > list = new ArrayList < E > ( ) ; in.beginArray ( ) ; while ( in.hasNext ( ) ) { E instance = componentTypeAdapter.read ( in ) ; list.add ( instance ) ; } in.endArray ( ) ; int size = list.size ( ) ; Object array = Array.newInstance ( componentType , size ) ; for ( int i = 0 ; i < size ; i++ ) { Array.set ( array , i , list.get ( i ) ) ; } return array ; } 
private synchronized Date deserializeToDate ( String json ) { for ( DateFormat dateFormat : dateFormats ) { try { return dateFormat.parse ( json ) ; } catch ( ParseException ignored ) { } } try { return ISO8601Utils.parse ( json , new ParsePosition ( 0 ) ) ; } catch ( ParseException e ) { throw new JsonSyntaxException ( json , e ) ; } } 
TypeAdapter < ? > getTypeAdapter ( ConstructorConstructor constructorConstructor , Gson gson , TypeToken < ? > type , JsonAdapter annotation ) { Object instance = constructorConstructor.get ( TypeToken.get ( annotation.value ( ) ) ) .construct ( ) ; TypeAdapter < ? > typeAdapter ; if ( instance instanceof TypeAdapter ) { typeAdapter = ( TypeAdapter < ? > ) instance ; } else if ( instance instanceof TypeAdapterFactory ) { typeAdapter = ( ( TypeAdapterFactory ) instance ) .create ( gson , type ) ; } else if ( instance instanceof JsonSerializer || instance instanceof JsonDeserializer ) { JsonSerializer < ? > serializer = instance instanceof JsonSerializer ? ( JsonSerializer ) instance : null ; JsonDeserializer < ? > deserializer = instance instanceof JsonDeserializer ? ( JsonDeserializer ) instance : null ; typeAdapter = new TreeTypeAdapter ( serializer , deserializer , gson , type , null ) ; } else { throw new IllegalArgumentException ( " Invalid attempt to bind an instance of " + instance.getClass ( ) .getName ( ) + " as a @JsonAdapter for " + type.toString ( ) + " . @JsonAdapter value must be a TypeAdapter , TypeAdapterFactory , " + " JsonSerializer or JsonDeserializer. " ) ; } if ( typeAdapter != null && annotation.nullSafe ( ) ) { typeAdapter = typeAdapter.nullSafe ( ) ; } return typeAdapter ; } 
public JsonToken peek ( ) throws IOException { if ( stackSize == 0 ) { return JsonToken.END_DOCUMENT ; } Object o = peekStack ( ) ; if ( o instanceof Iterator ) { boolean isObject = stack[stackSize - 2] instanceof JsonObject ; Iterator < ? > iterator = ( Iterator < ? > ) o ; if ( iterator.hasNext ( ) ) { if ( isObject ) { return JsonToken.NAME ; } else { push ( iterator.next ( ) ) ; return peek ( ) ; } } else { return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY ; } } else if ( o instanceof JsonObject ) { return JsonToken.BEGIN_OBJECT ; } else if ( o instanceof JsonArray ) { return JsonToken.BEGIN_ARRAY ; } else if ( o instanceof JsonPrimitive ) { JsonPrimitive primitive = ( JsonPrimitive ) o ; if ( primitive.isString ( ) ) { return JsonToken.STRING ; } else if ( primitive.isBoolean ( ) ) { return JsonToken.BOOLEAN ; } else if ( primitive.isNumber ( ) ) { return JsonToken.NUMBER ; } else { throw new AssertionError ( ) ; } } else if ( o instanceof JsonNull ) { return JsonToken.NULL ; } else if ( o == SENTINEL_CLOSED ) { throw new IllegalStateException ( " JsonReader is closed " ) ; } else { throw new AssertionError ( ) ; } } 
private void push ( Object newTop ) { if ( stackSize == stack.length ) { Object[] newStack = new Object[stackSize * 2] ; int[] newPathIndices = new int[stackSize * 2] ; String[] newPathNames = new String[stackSize * 2] ; System.arraycopy ( stack , 0 , newStack , 0 , stackSize ) ; System.arraycopy ( pathIndices , 0 , newPathIndices , 0 , stackSize ) ; System.arraycopy ( pathNames , 0 , newPathNames , 0 , stackSize ) ; stack = newStack ; pathIndices = newPathIndices ; pathNames = newPathNames ; } stack[stackSize++] = newTop ; } 
public String getPath ( ) { StringBuilder result = new StringBuilder ( ) .append ( '$' ) ; for ( int i = 0 ; i < stackSize ; i++ ) { if ( stack[i] instanceof JsonArray ) { if ( stack[++i] instanceof Iterator ) { result.append ( '[' ) .append ( pathIndices[i] ) .append ( ']' ) ; } } else if ( stack[i] instanceof JsonObject ) { if ( stack[++i] instanceof Iterator ) { result.append ( '.' ) ; if ( pathNames[i] != null ) { result.append ( pathNames[i] ) ; } } } } return result.toString ( ) ; } 
private void put ( JsonElement value ) { if ( pendingName != null ) { if ( !value.isJsonNull ( ) || getSerializeNulls ( ) ) { JsonObject object = ( JsonObject ) peek ( ) ; object.add ( pendingName , value ) ; } pendingName = null ; } else if ( stack.isEmpty ( ) ) { product = value ; } else { JsonElement element = peek ( ) ; if ( element instanceof JsonArray ) { ( ( JsonArray ) element ) .add ( value ) ; } else { throw new IllegalStateException ( ) ; } } } 
public void flush ( ) throws IOException { } 
public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > typeToken ) { Type type = typeToken.getType ( ) ; Class < ? super T > rawType = typeToken.getRawType ( ) ; if ( !Map.class.isAssignableFrom ( rawType ) ) { return null ; } Class < ? > rawTypeOfSrc = $Gson$Types.getRawType ( type ) ; Type[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes ( type , rawTypeOfSrc ) ; TypeAdapter < ? > keyAdapter = getKeyAdapter ( gson , keyAndValueTypes[0] ) ; TypeAdapter < ? > valueAdapter = gson.getAdapter ( TypeToken.get ( keyAndValueTypes[1] ) ) ; ObjectConstructor < T > constructor = constructorConstructor.get ( typeToken ) ; @SuppressWarnings ( { " unchecked " , " rawtypes " } ) TypeAdapter < T > result = new Adapter ( gson , keyAndValueTypes[0] , keyAdapter , keyAndValueTypes[1] , valueAdapter , constructor ) ; return result ; } 
public Map < K , V > read ( JsonReader in ) throws IOException { JsonToken peek = in.peek ( ) ; if ( peek == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } Map < K , V > map = constructor.construct ( ) ; if ( peek == JsonToken.BEGIN_ARRAY ) { in.beginArray ( ) ; while ( in.hasNext ( ) ) { in.beginArray ( ) ; K key = keyTypeAdapter.read ( in ) ; V value = valueTypeAdapter.read ( in ) ; V replaced = map.put ( key , value ) ; if ( replaced != null ) { throw new JsonSyntaxException ( " duplicate key: " + key ) ; } in.endArray ( ) ; } in.endArray ( ) ; } else { in.beginObject ( ) ; while ( in.hasNext ( ) ) { JsonReaderInternalAccess.INSTANCE.promoteNameToValue ( in ) ; K key = keyTypeAdapter.read ( in ) ; V value = valueTypeAdapter.read ( in ) ; V replaced = map.put ( key , value ) ; if ( replaced != null ) { throw new JsonSyntaxException ( " duplicate key: " + key ) ; } } in.endObject ( ) ; } return map ; } 
public void write ( JsonWriter out , Map < K , V > map ) throws IOException { if ( map == null ) { out.nullValue ( ) ; return ; } if ( !complexMapKeySerialization ) { out.beginObject ( ) ; for ( Map.Entry < K , V > entry : map.entrySet ( ) ) { out.name ( String.valueOf ( entry.getKey ( ) ) ) ; valueTypeAdapter.write ( out , entry.getValue ( ) ) ; } out.endObject ( ) ; return ; } boolean hasComplexKeys = false ; List < JsonElement > keys = new ArrayList < JsonElement > ( map.size ( ) ) ; List < V > values = new ArrayList < V > ( map.size ( ) ) ; for ( Map.Entry < K , V > entry : map.entrySet ( ) ) { JsonElement keyElement = keyTypeAdapter.toJsonTree ( entry.getKey ( ) ) ; keys.add ( keyElement ) ; values.add ( entry.getValue ( ) ) ; hasComplexKeys |= keyElement.isJsonArray ( ) || keyElement.isJsonObject ( ) ; } if ( hasComplexKeys ) { out.beginArray ( ) ; for ( int i = 0 , size = keys.size ( ) ; i < size ; i++ ) { out.beginArray ( ) ; Streams.write ( keys.get ( i ) , out ) ; valueTypeAdapter.write ( out , values.get ( i ) ) ; out.endArray ( ) ; } out.endArray ( ) ; } else { out.beginObject ( ) ; for ( int i = 0 , size = keys.size ( ) ; i < size ; i++ ) { JsonElement keyElement = keys.get ( i ) ; out.name ( keyToString ( keyElement ) ) ; valueTypeAdapter.write ( out , values.get ( i ) ) ; } out.endObject ( ) ; } } 
private String keyToString ( JsonElement keyElement ) { if ( keyElement.isJsonPrimitive ( ) ) { JsonPrimitive primitive = keyElement.getAsJsonPrimitive ( ) ; if ( primitive.isNumber ( ) ) { return String.valueOf ( primitive.getAsNumber ( ) ) ; } else if ( primitive.isBoolean ( ) ) { return Boolean.toString ( primitive.getAsBoolean ( ) ) ; } else if ( primitive.isString ( ) ) { return primitive.getAsString ( ) ; } else { throw new AssertionError ( ) ; } } else if ( keyElement.isJsonNull ( ) ) { return " null " ; } else { throw new AssertionError ( ) ; } } 
public Object read ( JsonReader in ) throws IOException { JsonToken token = in.peek ( ) ; switch ( token ) { case BEGIN_ARRAY: List < Object > list = new ArrayList < Object > ( ) ; in.beginArray ( ) ; while ( in.hasNext ( ) ) { list.add ( read ( in ) ) ; } in.endArray ( ) ; return list ; case BEGIN_OBJECT: Map < String , Object > map = new LinkedTreeMap < String , Object > ( ) ; in.beginObject ( ) ; while ( in.hasNext ( ) ) { map.put ( in.nextName ( ) , read ( in ) ) ; } in.endObject ( ) ; return map ; case STRING: return in.nextString ( ) ; case NUMBER: return in.nextDouble ( ) ; case BOOLEAN: return in.nextBoolean ( ) ; case NULL: in.nextNull ( ) ; return null ; default: throw new IllegalStateException ( ) ; } } 
private List < String > getFieldNames ( Field f ) { SerializedName annotation = f.getAnnotation ( SerializedName.class ) ; if ( annotation == null ) { String name = fieldNamingPolicy.translateName ( f ) ; return Collections.singletonList ( name ) ; } String serializedName = annotation.value ( ) ; String[] alternates = annotation.alternate ( ) ; if ( alternates.length == 0 ) { return Collections.singletonList ( serializedName ) ; } List < String > fieldNames = new ArrayList < String > ( alternates.length + 1 ) ; fieldNames.add ( serializedName ) ; for ( String alternate : alternates ) { fieldNames.add ( alternate ) ; } return fieldNames ; } 
private ReflectiveTypeAdapterFactory.BoundField createBoundField ( final Gson context , final Field field , final String name , final TypeToken < ? > fieldType , boolean serialize , boolean deserialize ) { final boolean isPrimitive = Primitives.isPrimitive ( fieldType.getRawType ( ) ) ; JsonAdapter annotation = field.getAnnotation ( JsonAdapter.class ) ; TypeAdapter < ? > mapped = null ; if ( annotation != null ) { mapped = jsonAdapterFactory.getTypeAdapter ( constructorConstructor , context , fieldType , annotation ) ; } final boolean jsonAdapterPresent = mapped != null ; if ( mapped == null ) mapped = context.getAdapter ( fieldType ) ; final TypeAdapter < ? > typeAdapter = mapped ; return new ReflectiveTypeAdapterFactory.BoundField ( name , serialize , deserialize ) { @SuppressWarnings ( { " unchecked " , " rawtypes " } ) @Override void write ( JsonWriter writer , Object value ) throws IOException , IllegalAccessException { Object fieldValue = field.get ( value ) ; TypeAdapter t = jsonAdapterPresent ? typeAdapter : new TypeAdapterRuntimeTypeWrapper ( context , typeAdapter , fieldType.getType ( ) ) ; t.write ( writer , fieldValue ) ; } @Override void read ( JsonReader reader , Object value ) throws IOException , IllegalAccessException { Object fieldValue = typeAdapter.read ( reader ) ; if ( fieldValue != null || !isPrimitive ) { field.set ( value , fieldValue ) ; } } @Override public boolean writeField ( Object value ) throws IOException , IllegalAccessException { if ( !serialized ) return false ; Object fieldValue = field.get ( value ) ; return fieldValue != value ; } } ; } 
private Map < String , BoundField > getBoundFields ( Gson context , TypeToken < ? > type , Class < ? > raw ) { Map < String , BoundField > result = new LinkedHashMap < String , BoundField > ( ) ; if ( raw.isInterface ( ) ) { return result ; } Type declaredType = type.getType ( ) ; while ( raw != Object.class ) { Field[] fields = raw.getDeclaredFields ( ) ; for ( Field field : fields ) { boolean serialize = excludeField ( field , true ) ; boolean deserialize = excludeField ( field , false ) ; if ( !serialize && !deserialize ) { continue ; } accessor.makeAccessible ( field ) ; Type fieldType = $Gson$Types.resolve ( type.getType ( ) , raw , field.getGenericType ( ) ) ; List < String > fieldNames = getFieldNames ( field ) ; BoundField previous = null ; for ( int i = 0 , size = fieldNames.size ( ) ; i < size ; ++i ) { String name = fieldNames.get ( i ) ; if ( i != 0 ) serialize = false ; BoundField boundField = createBoundField ( context , field , name , TypeToken.get ( fieldType ) , serialize , deserialize ) ; BoundField replaced = result.put ( name , boundField ) ; if ( previous == null ) previous = replaced ; } if ( previous != null ) { throw new IllegalArgumentException ( declaredType + " declares multiple JSON fields named " + previous.name ) ; } } type = TypeToken.get ( $Gson$Types.resolve ( type.getType ( ) , raw , raw.getGenericSuperclass ( ) ) ) ; raw = type.getRawType ( ) ; } return result ; } 
public T read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } T instance = constructor.construct ( ) ; try { in.beginObject ( ) ; while ( in.hasNext ( ) ) { String name = in.nextName ( ) ; BoundField field = boundFields.get ( name ) ; if ( field == null || !field.deserialized ) { in.skipValue ( ) ; } else { field.read ( in , instance ) ; } } } catch ( IllegalStateException e ) { throw new JsonSyntaxException ( e ) ; } catch ( IllegalAccessException e ) { throw new AssertionError ( e ) ; } in.endObject ( ) ; return instance ; } 
public void write ( JsonWriter out , T value ) throws IOException { if ( value == null ) { out.nullValue ( ) ; return ; } out.beginObject ( ) ; try { for ( BoundField boundField : boundFields.values ( ) ) { if ( boundField.writeField ( value ) ) { out.name ( boundField.name ) ; boundField.write ( out , value ) ; } } } catch ( IllegalAccessException e ) { throw new AssertionError ( e ) ; } out.endObject ( ) ; } 
public static TypeAdapterFactory newFactory ( TypeToken < ? > exactType , Object typeAdapter ) { return new SingleTypeFactory ( typeAdapter , exactType , false , null ) ; } 
public void write ( JsonWriter out , T value ) throws IOException { TypeAdapter chosen = delegate ; Type runtimeType = getRuntimeTypeIfMoreSpecific ( type , value ) ; if ( runtimeType != type ) { TypeAdapter runtimeTypeAdapter = context.getAdapter ( TypeToken.get ( runtimeType ) ) ; if ( ! ( runtimeTypeAdapter instanceof ReflectiveTypeAdapterFactory.Adapter ) ) { chosen = runtimeTypeAdapter ; } else if ( ! ( delegate instanceof ReflectiveTypeAdapterFactory.Adapter ) ) { chosen = delegate ; } else { chosen = runtimeTypeAdapter ; } } chosen.write ( out , value ) ; } 
public BitSet read ( JsonReader in ) throws IOException { BitSet bitset = new BitSet ( ) ; in.beginArray ( ) ; int i = 0 ; JsonToken tokenType = in.peek ( ) ; while ( tokenType != JsonToken.END_ARRAY ) { boolean set ; switch ( tokenType ) { case NUMBER: set = in.nextInt ( ) != 0 ; break ; case BOOLEAN: set = in.nextBoolean ( ) ; break ; case STRING: String stringValue = in.nextString ( ) ; try { set = Integer.parseInt ( stringValue ) != 0 ; } catch ( NumberFormatException e ) { throw new JsonSyntaxException ( " Error: Expecting: bitset number value ( 1 , 0 ) , Found: " + stringValue ) ; } break ; default: throw new JsonSyntaxException ( " Invalid bitset value type: " + tokenType ) ; } if ( set ) { bitset.set ( i ) ; } ++i ; tokenType = in.peek ( ) ; } in.endArray ( ) ; return bitset ; } 
public AtomicIntegerArray read ( JsonReader in ) throws IOException { List < Integer > list = new ArrayList < Integer > ( ) ; in.beginArray ( ) ; while ( in.hasNext ( ) ) { try { int integer = in.nextInt ( ) ; list.add ( integer ) ; } catch ( NumberFormatException e ) { throw new JsonSyntaxException ( e ) ; } } in.endArray ( ) ; int length = list.size ( ) ; AtomicIntegerArray array = new AtomicIntegerArray ( length ) ; for ( int i = 0 ; i < length ; ++i ) { array.set ( i , list.get ( i ) ) ; } return array ; } 
public Number read ( JsonReader in ) throws IOException { JsonToken jsonToken = in.peek ( ) ; switch ( jsonToken ) { case NULL: in.nextNull ( ) ; return null ; case NUMBER: case STRING: return new LazilyParsedNumber ( in.nextString ( ) ) ; default: throw new JsonSyntaxException ( " Expecting number , got: " + jsonToken ) ; } } 
public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > typeToken ) { if ( typeToken.getRawType ( ) != Timestamp.class ) { return null ; } final TypeAdapter < Date > dateTypeAdapter = gson.getAdapter ( Date.class ) ; return ( TypeAdapter < T > ) new TypeAdapter < Timestamp > ( ) { @Override public Timestamp read ( JsonReader in ) throws IOException { Date date = dateTypeAdapter.read ( in ) ; return date != null ? new Timestamp ( date.getTime ( ) ) : null ; } @Override public void write ( JsonWriter out , Timestamp value ) throws IOException { dateTypeAdapter.write ( out , value ) ; } } ; } 
public Calendar read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } in.beginObject ( ) ; int year = 0 ; int month = 0 ; int dayOfMonth = 0 ; int hourOfDay = 0 ; int minute = 0 ; int second = 0 ; while ( in.peek ( ) != JsonToken.END_OBJECT ) { String name = in.nextName ( ) ; int value = in.nextInt ( ) ; if ( YEAR.equals ( name ) ) { year = value ; } else if ( MONTH.equals ( name ) ) { month = value ; } else if ( DAY_OF_MONTH.equals ( name ) ) { dayOfMonth = value ; } else if ( HOUR_OF_DAY.equals ( name ) ) { hourOfDay = value ; } else if ( MINUTE.equals ( name ) ) { minute = value ; } else if ( SECOND.equals ( name ) ) { second = value ; } } in.endObject ( ) ; return new GregorianCalendar ( year , month , dayOfMonth , hourOfDay , minute , second ) ; } 
public void write ( JsonWriter out , Calendar value ) throws IOException { if ( value == null ) { out.nullValue ( ) ; return ; } out.beginObject ( ) ; out.name ( YEAR ) ; out.value ( value.get ( Calendar.YEAR ) ) ; out.name ( MONTH ) ; out.value ( value.get ( Calendar.MONTH ) ) ; out.name ( DAY_OF_MONTH ) ; out.value ( value.get ( Calendar.DAY_OF_MONTH ) ) ; out.name ( HOUR_OF_DAY ) ; out.value ( value.get ( Calendar.HOUR_OF_DAY ) ) ; out.name ( MINUTE ) ; out.value ( value.get ( Calendar.MINUTE ) ) ; out.name ( SECOND ) ; out.value ( value.get ( Calendar.SECOND ) ) ; out.endObject ( ) ; } 
public Locale read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } String locale = in.nextString ( ) ; StringTokenizer tokenizer = new StringTokenizer ( locale , " _ " ) ; String language = null ; String country = null ; String variant = null ; if ( tokenizer.hasMoreElements ( ) ) { language = tokenizer.nextToken ( ) ; } if ( tokenizer.hasMoreElements ( ) ) { country = tokenizer.nextToken ( ) ; } if ( tokenizer.hasMoreElements ( ) ) { variant = tokenizer.nextToken ( ) ; } if ( country == null && variant == null ) { return new Locale ( language ) ; } else if ( variant == null ) { return new Locale ( language , country ) ; } else { return new Locale ( language , country , variant ) ; } } 
public JsonElement read ( JsonReader in ) throws IOException { switch ( in.peek ( ) ) { case STRING: return new JsonPrimitive ( in.nextString ( ) ) ; case NUMBER: String number = in.nextString ( ) ; return new JsonPrimitive ( new LazilyParsedNumber ( number ) ) ; case BOOLEAN: return new JsonPrimitive ( in.nextBoolean ( ) ) ; case NULL: in.nextNull ( ) ; return JsonNull.INSTANCE ; case BEGIN_ARRAY: JsonArray array = new JsonArray ( ) ; in.beginArray ( ) ; while ( in.hasNext ( ) ) { array.add ( read ( in ) ) ; } in.endArray ( ) ; return array ; case BEGIN_OBJECT: JsonObject object = new JsonObject ( ) ; in.beginObject ( ) ; while ( in.hasNext ( ) ) { object.add ( in.nextName ( ) , read ( in ) ) ; } in.endObject ( ) ; return object ; case END_DOCUMENT: case NAME: case END_OBJECT: case END_ARRAY: default: throw new IllegalArgumentException ( ) ; } } 
public void write ( JsonWriter out , JsonElement value ) throws IOException { if ( value == null || value.isJsonNull ( ) ) { out.nullValue ( ) ; } else if ( value.isJsonPrimitive ( ) ) { JsonPrimitive primitive = value.getAsJsonPrimitive ( ) ; if ( primitive.isNumber ( ) ) { out.value ( primitive.getAsNumber ( ) ) ; } else if ( primitive.isBoolean ( ) ) { out.value ( primitive.getAsBoolean ( ) ) ; } else { out.value ( primitive.getAsString ( ) ) ; } } else if ( value.isJsonArray ( ) ) { out.beginArray ( ) ; for ( JsonElement e : value.getAsJsonArray ( ) ) { write ( out , e ) ; } out.endArray ( ) ; } else if ( value.isJsonObject ( ) ) { out.beginObject ( ) ; for ( Map.Entry < String , JsonElement > e : value.getAsJsonObject ( ) .entrySet ( ) ) { out.name ( e.getKey ( ) ) ; write ( out , e.getValue ( ) ) ; } out.endObject ( ) ; } else { throw new IllegalArgumentException ( " Couldn't write " + value.getClass ( ) ) ; } } 
public static < TT > TypeAdapterFactory newFactory ( final TypeToken < TT > type , final TypeAdapter < TT > typeAdapter ) { return new TypeAdapterFactory ( ) { @SuppressWarnings ( " unchecked " ) @Override public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > typeToken ) { return typeToken.equals ( type ) ? ( TypeAdapter < T > ) typeAdapter : null ; } } ; } 
public static < TT > TypeAdapterFactory newFactory ( final Class < TT > type , final TypeAdapter < TT > typeAdapter ) { return new TypeAdapterFactory ( ) { @SuppressWarnings ( " unchecked " ) @Override public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > typeToken ) { return typeToken.getRawType ( ) == type ? ( TypeAdapter < T > ) typeAdapter : null ; } @Override public String toString ( ) { return " Factory[type= " + type.getName ( ) + " , adapter= " + typeAdapter + " ] " ; } } ; } 
public static < TT > TypeAdapterFactory newFactory ( final Class < TT > unboxed , final Class < TT > boxed , final TypeAdapter < ? super TT > typeAdapter ) { return new TypeAdapterFactory ( ) { @SuppressWarnings ( " unchecked " ) @Override public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > typeToken ) { Class < ? super T > rawType = typeToken.getRawType ( ) ; return ( rawType == unboxed || rawType == boxed ) ? ( TypeAdapter < T > ) typeAdapter : null ; } @Override public String toString ( ) { return " Factory[type= " + boxed.getName ( ) + " + " + unboxed.getName ( ) + " , adapter= " + typeAdapter + " ] " ; } } ; } 
public static < TT > TypeAdapterFactory newFactoryForMultipleTypes ( final Class < TT > base , final Class < ? extends TT > sub , final TypeAdapter < ? super TT > typeAdapter ) { return new TypeAdapterFactory ( ) { @SuppressWarnings ( " unchecked " ) @Override public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > typeToken ) { Class < ? super T > rawType = typeToken.getRawType ( ) ; return ( rawType == base || rawType == sub ) ? ( TypeAdapter < T > ) typeAdapter : null ; } @Override public String toString ( ) { return " Factory[type= " + base.getName ( ) + " + " + sub.getName ( ) + " , adapter= " + typeAdapter + " ] " ; } } ; } 
public static < T1 > TypeAdapterFactory newTypeHierarchyFactory ( final Class < T1 > clazz , final TypeAdapter < T1 > typeAdapter ) { return new TypeAdapterFactory ( ) { @SuppressWarnings ( " unchecked " ) @Override public < T2 > TypeAdapter < T2 > create ( Gson gson , TypeToken < T2 > typeToken ) { final Class < ? super T2 > requestedType = typeToken.getRawType ( ) ; if ( !clazz.isAssignableFrom ( requestedType ) ) { return null ; } return ( TypeAdapter < T2 > ) new TypeAdapter < T1 > ( ) { @Override public void write ( JsonWriter out , T1 value ) throws IOException { typeAdapter.write ( out , value ) ; } @Override public T1 read ( JsonReader in ) throws IOException { T1 result = typeAdapter.read ( in ) ; if ( result != null && !requestedType.isInstance ( result ) ) { throw new JsonSyntaxException ( " Expected a " + requestedType.getName ( ) + " but was " + result.getClass ( ) .getName ( ) ) ; } return result ; } } ; } @Override public String toString ( ) { return " Factory[typeHierarchy= " + clazz.getName ( ) + " , adapter= " + typeAdapter + " ] " ; } } ; } 
public < T2 > TypeAdapter < T2 > create ( Gson gson , TypeToken < T2 > typeToken ) { final Class < ? super T2 > requestedType = typeToken.getRawType ( ) ; if ( !clazz.isAssignableFrom ( requestedType ) ) { return null ; } return ( TypeAdapter < T2 > ) new TypeAdapter < T1 > ( ) { @Override public void write ( JsonWriter out , T1 value ) throws IOException { typeAdapter.write ( out , value ) ; } @Override public T1 read ( JsonReader in ) throws IOException { T1 result = typeAdapter.read ( in ) ; if ( result != null && !requestedType.isInstance ( result ) ) { throw new JsonSyntaxException ( " Expected a " + requestedType.getName ( ) + " but was " + result.getClass ( ) .getName ( ) ) ; } return result ; } } ; } 
public static String format ( Date date , boolean millis , TimeZone tz ) { Calendar calendar = new GregorianCalendar ( tz , Locale.US ) ; calendar.setTime ( date ) ; int capacity = " yyyy-MM-ddThh:mm:ss " .length ( ) ; capacity += millis ? " .sss " .length ( ) : 0 ; capacity += tz.getRawOffset ( ) == 0 ? " Z " .length ( ) : " +hh:mm " .length ( ) ; StringBuilder formatted = new StringBuilder ( capacity ) ; padInt ( formatted , calendar.get ( Calendar.YEAR ) , " yyyy " .length ( ) ) ; formatted.append ( '-' ) ; padInt ( formatted , calendar.get ( Calendar.MONTH ) + 1 , " MM " .length ( ) ) ; formatted.append ( '-' ) ; padInt ( formatted , calendar.get ( Calendar.DAY_OF_MONTH ) , " dd " .length ( ) ) ; formatted.append ( 'T' ) ; padInt ( formatted , calendar.get ( Calendar.HOUR_OF_DAY ) , " hh " .length ( ) ) ; formatted.append ( ':' ) ; padInt ( formatted , calendar.get ( Calendar.MINUTE ) , " mm " .length ( ) ) ; formatted.append ( ':' ) ; padInt ( formatted , calendar.get ( Calendar.SECOND ) , " ss " .length ( ) ) ; if ( millis ) { formatted.append ( '.' ) ; padInt ( formatted , calendar.get ( Calendar.MILLISECOND ) , " sss " .length ( ) ) ; } int offset = tz.getOffset ( calendar.getTimeInMillis ( ) ) ; if ( offset != 0 ) { int hours = Math.abs ( ( offset / ( 60 * 1000 ) ) / 60 ) ; int minutes = Math.abs ( ( offset / ( 60 * 1000 ) ) % 60 ) ; formatted.append ( offset < 0 ? '-' : '+' ) ; padInt ( formatted , hours , " hh " .length ( ) ) ; formatted.append ( ':' ) ; padInt ( formatted , minutes , " mm " .length ( ) ) ; } else { formatted.append ( 'Z' ) ; } return formatted.toString ( ) ; } 
public static Date parse ( String date , ParsePosition pos ) throws ParseException { Exception fail = null ; try { int offset = pos.getIndex ( ) ; int year = parseInt ( date , offset , offset += 4 ) ; if ( checkOffset ( date , offset , '-' ) ) { offset += 1 ; } int month = parseInt ( date , offset , offset += 2 ) ; if ( checkOffset ( date , offset , '-' ) ) { offset += 1 ; } int day = parseInt ( date , offset , offset += 2 ) ; int hour = 0 ; int minutes = 0 ; int seconds = 0 ; int milliseconds = 0 ; boolean hasT = checkOffset ( date , offset , 'T' ) ; if ( !hasT && ( date.length ( ) < = offset ) ) { Calendar calendar = new GregorianCalendar ( year , month - 1 , day ) ; pos.setIndex ( offset ) ; return calendar.getTime ( ) ; } if ( hasT ) { hour = parseInt ( date , offset += 1 , offset += 2 ) ; if ( checkOffset ( date , offset , ':' ) ) { offset += 1 ; } minutes = parseInt ( date , offset , offset += 2 ) ; if ( checkOffset ( date , offset , ':' ) ) { offset += 1 ; } if ( date.length ( ) > offset ) { char c = date.charAt ( offset ) ; if ( c != 'Z' && c != '+' && c != '-' ) { seconds = parseInt ( date , offset , offset += 2 ) ; if ( seconds > 59 && seconds < 63 ) seconds = 59 ; if ( checkOffset ( date , offset , '.' ) ) { offset += 1 ; int endOffset = indexOfNonDigit ( date , offset + 1 ) ; int parseEndOffset = Math.min ( endOffset , offset + 3 ) ; int fraction = parseInt ( date , offset , parseEndOffset ) ; switch ( parseEndOffset - offset ) { case 2: milliseconds = fraction * 10 ; break ; case 1: milliseconds = fraction * 100 ; break ; default: milliseconds = fraction ; } offset = endOffset ; } } } } if ( date.length ( ) < = offset ) { throw new IllegalArgumentException ( " No time zone indicator " ) ; } TimeZone timezone = null ; char timezoneIndicator = date.charAt ( offset ) ; if ( timezoneIndicator == 'Z' ) { timezone = TIMEZONE_UTC ; offset += 1 ; } else if ( timezoneIndicator == '+' || timezoneIndicator == '-' ) { String timezoneOffset = date.substring ( offset ) ; timezoneOffset = timezoneOffset.length ( ) > = 5 ? timezoneOffset : timezoneOffset + " 00 " ; offset += timezoneOffset.length ( ) ; if ( " +0000 " .equals ( timezoneOffset ) || " +00:00 " .equals ( timezoneOffset ) ) { timezone = TIMEZONE_UTC ; } else { String timezoneId = " GMT " + timezoneOffset ; timezone = TimeZone.getTimeZone ( timezoneId ) ; String act = timezone.getID ( ) ; if ( !act.equals ( timezoneId ) ) { String cleaned = act.replace ( " : " , " " ) ; if ( !cleaned.equals ( timezoneId ) ) { throw new IndexOutOfBoundsException ( " Mismatching time zone indicator: " + timezoneId + " given , resolves to " + timezone.getID ( ) ) ; } } } } else { throw new IndexOutOfBoundsException ( " Invalid time zone indicator ' " + timezoneIndicator + " ' " ) ; } Calendar calendar = new GregorianCalendar ( timezone ) ; calendar.setLenient ( false ) ; calendar.set ( Calendar.YEAR , year ) ; calendar.set ( Calendar.MONTH , month - 1 ) ; calendar.set ( Calendar.DAY_OF_MONTH , day ) ; calendar.set ( Calendar.HOUR_OF_DAY , hour ) ; calendar.set ( Calendar.MINUTE , minutes ) ; calendar.set ( Calendar.SECOND , seconds ) ; calendar.set ( Calendar.MILLISECOND , milliseconds ) ; pos.setIndex ( offset ) ; return calendar.getTime ( ) ; } catch ( IndexOutOfBoundsException e ) { fail = e ; } catch ( NumberFormatException e ) { fail = e ; } catch ( IllegalArgumentException e ) { fail = e ; } String input = ( date == null ) ? null : ( ' " ' + date + ' " ' ) ; String msg = fail.getMessage ( ) ; if ( msg == null || msg.isEmpty ( ) ) { msg = " ( " + fail.getClass ( ) .getName ( ) + " ) " ; } ParseException ex = new ParseException ( " Failed to parse date [ " + input + " ]: " + msg , pos.getIndex ( ) ) ; ex.initCause ( fail ) ; throw ex ; } 
private static int parseInt ( String value , int beginIndex , int endIndex ) throws NumberFormatException { if ( beginIndex < 0 || endIndex > value.length ( ) || beginIndex > endIndex ) { throw new NumberFormatException ( value ) ; } int i = beginIndex ; int result = 0 ; int digit ; if ( i < endIndex ) { digit = Character.digit ( value.charAt ( i++ ) , 10 ) ; if ( digit < 0 ) { throw new NumberFormatException ( " Invalid number: " + value.substring ( beginIndex , endIndex ) ) ; } result = -digit ; } while ( i < endIndex ) { digit = Character.digit ( value.charAt ( i++ ) , 10 ) ; if ( digit < 0 ) { throw new NumberFormatException ( " Invalid number: " + value.substring ( beginIndex , endIndex ) ) ; } result *= 10 ; result -= digit ; } return -result ; } 
public < T > ObjectConstructor < T > get ( TypeToken < T > typeToken ) { final Type type = typeToken.getType ( ) ; final Class < ? super T > rawType = typeToken.getRawType ( ) ; @SuppressWarnings ( " unchecked " ) final InstanceCreator < T > typeCreator = ( InstanceCreator < T > ) instanceCreators.get ( type ) ; if ( typeCreator != null ) { return new ObjectConstructor < T > ( ) { @Override public T construct ( ) { return typeCreator.createInstance ( type ) ; } } ; } @SuppressWarnings ( " unchecked " ) final InstanceCreator < T > rawTypeCreator = ( InstanceCreator < T > ) instanceCreators.get ( rawType ) ; if ( rawTypeCreator != null ) { return new ObjectConstructor < T > ( ) { @Override public T construct ( ) { return rawTypeCreator.createInstance ( type ) ; } } ; } ObjectConstructor < T > defaultConstructor = newDefaultConstructor ( rawType ) ; if ( defaultConstructor != null ) { return defaultConstructor ; } ObjectConstructor < T > defaultImplementation = newDefaultImplementationConstructor ( type , rawType ) ; if ( defaultImplementation != null ) { return defaultImplementation ; } return newUnsafeAllocator ( type , rawType ) ; } 
private < T > ObjectConstructor < T > newDefaultConstructor ( Class < ? super T > rawType ) { try { final Constructor < ? super T > constructor = rawType.getDeclaredConstructor ( ) ; if ( !constructor.isAccessible ( ) ) { accessor.makeAccessible ( constructor ) ; } return new ObjectConstructor < T > ( ) { @SuppressWarnings ( " unchecked " ) @Override public T construct ( ) { try { Object[] args = null ; return ( T ) constructor.newInstance ( args ) ; } catch ( InstantiationException e ) { throw new RuntimeException ( " Failed to invoke " + constructor + " with no args " , e ) ; } catch ( InvocationTargetException e ) { throw new RuntimeException ( " Failed to invoke " + constructor + " with no args " , e.getTargetException ( ) ) ; } catch ( IllegalAccessException e ) { throw new AssertionError ( e ) ; } } } ; } catch ( NoSuchMethodException e ) { return null ; } } 
private < T > ObjectConstructor < T > newDefaultImplementationConstructor ( final Type type , Class < ? super T > rawType ) { if ( Collection.class.isAssignableFrom ( rawType ) ) { if ( SortedSet.class.isAssignableFrom ( rawType ) ) { return new ObjectConstructor < T > ( ) { @Override public T construct ( ) { return ( T ) new TreeSet < Object > ( ) ; } } ; } else if ( EnumSet.class.isAssignableFrom ( rawType ) ) { return new ObjectConstructor < T > ( ) { @SuppressWarnings ( " rawtypes " ) @Override public T construct ( ) { if ( type instanceof ParameterizedType ) { Type elementType = ( ( ParameterizedType ) type ) .getActualTypeArguments ( ) [0] ; if ( elementType instanceof Class ) { return ( T ) EnumSet.noneOf ( ( Class ) elementType ) ; } else { throw new JsonIOException ( " Invalid EnumSet type: " + type.toString ( ) ) ; } } else { throw new JsonIOException ( " Invalid EnumSet type: " + type.toString ( ) ) ; } } } ; } else if ( Set.class.isAssignableFrom ( rawType ) ) { return new ObjectConstructor < T > ( ) { @Override public T construct ( ) { return ( T ) new LinkedHashSet < Object > ( ) ; } } ; } else if ( Queue.class.isAssignableFrom ( rawType ) ) { return new ObjectConstructor < T > ( ) { @Override public T construct ( ) { return ( T ) new ArrayDeque < Object > ( ) ; } } ; } else { return new ObjectConstructor < T > ( ) { @Override public T construct ( ) { return ( T ) new ArrayList < Object > ( ) ; } } ; } } if ( Map.class.isAssignableFrom ( rawType ) ) { if ( ConcurrentNavigableMap.class.isAssignableFrom ( rawType ) ) { return new ObjectConstructor < T > ( ) { @Override public T construct ( ) { return ( T ) new ConcurrentSkipListMap < Object , Object > ( ) ; } } ; } else if ( ConcurrentMap.class.isAssignableFrom ( rawType ) ) { return new ObjectConstructor < T > ( ) { @Override public T construct ( ) { return ( T ) new ConcurrentHashMap < Object , Object > ( ) ; } } ; } else if ( SortedMap.class.isAssignableFrom ( rawType ) ) { return new ObjectConstructor < T > ( ) { @Override public T construct ( ) { return ( T ) new TreeMap < Object , Object > ( ) ; } } ; } else if ( type instanceof ParameterizedType && ! ( String.class.isAssignableFrom ( TypeToken.get ( ( ( ParameterizedType ) type ) .getActualTypeArguments ( ) [0] ) .getRawType ( ) ) ) ) { return new ObjectConstructor < T > ( ) { @Override public T construct ( ) { return ( T ) new LinkedHashMap < Object , Object > ( ) ; } } ; } else { return new ObjectConstructor < T > ( ) { @Override public T construct ( ) { return ( T ) new LinkedTreeMap < String , Object > ( ) ; } } ; } } return null ; } 
private < T > ObjectConstructor < T > newUnsafeAllocator ( final Type type , final Class < ? super T > rawType ) { return new ObjectConstructor < T > ( ) { private final UnsafeAllocator unsafeAllocator = UnsafeAllocator.create ( ) ; @SuppressWarnings ( " unchecked " ) @Override public T construct ( ) { try { Object newInstance = unsafeAllocator.newInstance ( rawType ) ; return ( T ) newInstance ; } catch ( Exception e ) { throw new RuntimeException ( ( " Unable to invoke no-args constructor for " + type + " . " + " Registering an InstanceCreator with Gson for this type may fix this problem. " ) , e ) ; } } } ; } 
public < T > TypeAdapter < T > create ( final Gson gson , final TypeToken < T > type ) { Class < ? > rawType = type.getRawType ( ) ; boolean excludeClass = excludeClassChecks ( rawType ) ; final boolean skipSerialize = excludeClass || excludeClassInStrategy ( rawType , true ) ; final boolean skipDeserialize = excludeClass || excludeClassInStrategy ( rawType , false ) ; if ( !skipSerialize && !skipDeserialize ) { return null ; } return new TypeAdapter < T > ( ) { private TypeAdapter < T > delegate ; @Override public T read ( JsonReader in ) throws IOException { if ( skipDeserialize ) { in.skipValue ( ) ; return null ; } return delegate ( ) .read ( in ) ; } @Override public void write ( JsonWriter out , T value ) throws IOException { if ( skipSerialize ) { out.nullValue ( ) ; return ; } delegate ( ) .write ( out , value ) ; } private TypeAdapter < T > delegate ( ) { TypeAdapter < T > d = delegate ; return d != null ? d : ( delegate = gson.getDelegateAdapter ( Excluder.this , type ) ) ; } } ; } 
public boolean excludeField ( Field field , boolean serialize ) { if ( ( modifiers & field.getModifiers ( ) ) != 0 ) { return true ; } if ( version != Excluder.IGNORE_VERSIONS && !isValidVersion ( field.getAnnotation ( Since.class ) , field.getAnnotation ( Until.class ) ) ) { return true ; } if ( field.isSynthetic ( ) ) { return true ; } if ( requireExpose ) { Expose annotation = field.getAnnotation ( Expose.class ) ; if ( annotation == null || ( serialize ? !annotation.serialize ( ) : !annotation.deserialize ( ) ) ) { return true ; } } if ( !serializeInnerClasses && isInnerClass ( field.getType ( ) ) ) { return true ; } if ( isAnonymousOrLocal ( field.getType ( ) ) ) { return true ; } List < ExclusionStrategy > list = serialize ? serializationStrategies : deserializationStrategies ; if ( !list.isEmpty ( ) ) { FieldAttributes fieldAttributes = new FieldAttributes ( field ) ; for ( ExclusionStrategy exclusionStrategy : list ) { if ( exclusionStrategy.shouldSkipField ( fieldAttributes ) ) { return true ; } } } return false ; } 
public boolean excludeClass ( Class < ? > clazz , boolean serialize ) { return excludeClassChecks ( clazz ) || excludeClassInStrategy ( clazz , serialize ) ; } 
private boolean excludeClassInStrategy ( Class < ? > clazz , boolean serialize ) { List < ExclusionStrategy > list = serialize ? serializationStrategies : deserializationStrategies ; for ( ExclusionStrategy exclusionStrategy : list ) { if ( exclusionStrategy.shouldSkipClass ( clazz ) ) { return true ; } } return false ; } 
private static int extractBeginningInt ( String javaVersion ) { try { StringBuilder num = new StringBuilder ( ) ; for ( int i = 0 ; i < javaVersion.length ( ) ; ++i ) { char c = javaVersion.charAt ( i ) ; if ( Character.isDigit ( c ) ) { num.append ( c ) ; } else { break ; } } return Integer.parseInt ( num.toString ( ) ) ; } catch ( NumberFormatException e ) { return -1 ; } } 
Node < K , V > find ( K key , boolean create ) { Comparator < ? super K > comparator = this.comparator ; Node < K , V > [] table = this.table ; int hash = secondaryHash ( key.hashCode ( ) ) ; int index = hash & ( table.length - 1 ) ; Node < K , V > nearest = table[index] ; int comparison = 0 ; if ( nearest != null ) { @SuppressWarnings ( " unchecked " ) Comparable < Object > comparableKey = ( comparator == NATURAL_ORDER ) ? ( Comparable < Object > ) key : null ; while ( true ) { comparison = ( comparableKey != null ) ? comparableKey.compareTo ( nearest.key ) : comparator.compare ( key , nearest.key ) ; if ( comparison == 0 ) { return nearest ; } Node < K , V > child = ( comparison < 0 ) ? nearest.left : nearest.right ; if ( child == null ) { break ; } nearest = child ; } } if ( !create ) { return null ; } Node < K , V > header = this.header ; Node < K , V > created ; if ( nearest == null ) { if ( comparator == NATURAL_ORDER && ! ( key instanceof Comparable ) ) { throw new ClassCastException ( key.getClass ( ) .getName ( ) + " is not Comparable " ) ; } created = new Node < K , V > ( nearest , key , hash , header , header.prev ) ; table[index] = created ; } else { created = new Node < K , V > ( nearest , key , hash , header , header.prev ) ; if ( comparison < 0 ) { nearest.left = created ; } else { nearest.right = created ; } rebalance ( nearest , true ) ; } if ( size++ > threshold ) { doubleCapacity ( ) ; } modCount++ ; return created ; } 
void removeInternal ( Node < K , V > node , boolean unlink ) { if ( unlink ) { node.prev.next = node.next ; node.next.prev = node.prev ; node.next = node.prev = null ; } Node < K , V > left = node.left ; Node < K , V > right = node.right ; Node < K , V > originalParent = node.parent ; if ( left != null && right != null ) { Node < K , V > adjacent = ( left.height > right.height ) ? left.last ( ) : right.first ( ) ; removeInternal ( adjacent , false ) ; int leftHeight = 0 ; left = node.left ; if ( left != null ) { leftHeight = left.height ; adjacent.left = left ; left.parent = adjacent ; node.left = null ; } int rightHeight = 0 ; right = node.right ; if ( right != null ) { rightHeight = right.height ; adjacent.right = right ; right.parent = adjacent ; node.right = null ; } adjacent.height = Math.max ( leftHeight , rightHeight ) + 1 ; replaceInParent ( node , adjacent ) ; return ; } else if ( left != null ) { replaceInParent ( node , left ) ; node.left = null ; } else if ( right != null ) { replaceInParent ( node , right ) ; node.right = null ; } else { replaceInParent ( node , null ) ; } rebalance ( originalParent , false ) ; size-- ; modCount++ ; } 
private void replaceInParent ( Node < K , V > node , Node < K , V > replacement ) { Node < K , V > parent = node.parent ; node.parent = null ; if ( replacement != null ) { replacement.parent = parent ; } if ( parent != null ) { if ( parent.left == node ) { parent.left = replacement ; } else { assert ( parent.right == node ) ; parent.right = replacement ; } } else { int index = node.hash & ( table.length - 1 ) ; table[index] = replacement ; } } 
private void rebalance ( Node < K , V > unbalanced , boolean insert ) { for ( Node < K , V > node = unbalanced ; node != null ; node = node.parent ) { Node < K , V > left = node.left ; Node < K , V > right = node.right ; int leftHeight = left != null ? left.height : 0 ; int rightHeight = right != null ? right.height : 0 ; int delta = leftHeight - rightHeight ; if ( delta == -2 ) { Node < K , V > rightLeft = right.left ; Node < K , V > rightRight = right.right ; int rightRightHeight = rightRight != null ? rightRight.height : 0 ; int rightLeftHeight = rightLeft != null ? rightLeft.height : 0 ; int rightDelta = rightLeftHeight - rightRightHeight ; if ( rightDelta == -1 || ( rightDelta == 0 && !insert ) ) { rotateLeft ( node ) ; } else { assert ( rightDelta == 1 ) ; rotateRight ( right ) ; rotateLeft ( node ) ; } if ( insert ) { break ; } } else if ( delta == 2 ) { Node < K , V > leftLeft = left.left ; Node < K , V > leftRight = left.right ; int leftRightHeight = leftRight != null ? leftRight.height : 0 ; int leftLeftHeight = leftLeft != null ? leftLeft.height : 0 ; int leftDelta = leftLeftHeight - leftRightHeight ; if ( leftDelta == 1 || ( leftDelta == 0 && !insert ) ) { rotateRight ( node ) ; } else { assert ( leftDelta == -1 ) ; rotateLeft ( left ) ; rotateRight ( node ) ; } if ( insert ) { break ; } } else if ( delta == 0 ) { node.height = leftHeight + 1 ; if ( insert ) { break ; } } else { assert ( delta == -1 || delta == 1 ) ; node.height = Math.max ( leftHeight , rightHeight ) + 1 ; if ( !insert ) { break ; } } } } 
private void rotateLeft ( Node < K , V > root ) { Node < K , V > left = root.left ; Node < K , V > pivot = root.right ; Node < K , V > pivotLeft = pivot.left ; Node < K , V > pivotRight = pivot.right ; root.right = pivotLeft ; if ( pivotLeft != null ) { pivotLeft.parent = root ; } replaceInParent ( root , pivot ) ; pivot.left = root ; root.parent = pivot ; root.height = Math.max ( left != null ? left.height : 0 , pivotLeft != null ? pivotLeft.height : 0 ) + 1 ; pivot.height = Math.max ( root.height , pivotRight != null ? pivotRight.height : 0 ) + 1 ; } 
private void rotateRight ( Node < K , V > root ) { Node < K , V > pivot = root.left ; Node < K , V > right = root.right ; Node < K , V > pivotLeft = pivot.left ; Node < K , V > pivotRight = pivot.right ; root.left = pivotRight ; if ( pivotRight != null ) { pivotRight.parent = root ; } replaceInParent ( root , pivot ) ; pivot.right = root ; root.parent = pivot ; root.height = Math.max ( right != null ? right.height : 0 , pivotRight != null ? pivotRight.height : 0 ) + 1 ; pivot.height = Math.max ( root.height , pivotLeft != null ? pivotLeft.height : 0 ) + 1 ; } 
static < K , V > Node < K , V > [] doubleCapacity ( Node < K , V > [] oldTable ) { int oldCapacity = oldTable.length ; @SuppressWarnings ( " unchecked " ) Node < K , V > [] newTable = new Node[oldCapacity * 2] ; AvlIterator < K , V > iterator = new AvlIterator < K , V > ( ) ; AvlBuilder < K , V > leftBuilder = new AvlBuilder < K , V > ( ) ; AvlBuilder < K , V > rightBuilder = new AvlBuilder < K , V > ( ) ; for ( int i = 0 ; i < oldCapacity ; i++ ) { Node < K , V > root = oldTable[i] ; if ( root == null ) { continue ; } iterator.reset ( root ) ; int leftSize = 0 ; int rightSize = 0 ; for ( Node < K , V > node ; ( node = iterator.next ( ) ) != null ; ) { if ( ( node.hash & oldCapacity ) == 0 ) { leftSize++ ; } else { rightSize++ ; } } leftBuilder.reset ( leftSize ) ; rightBuilder.reset ( rightSize ) ; iterator.reset ( root ) ; for ( Node < K , V > node ; ( node = iterator.next ( ) ) != null ; ) { if ( ( node.hash & oldCapacity ) == 0 ) { leftBuilder.add ( node ) ; } else { rightBuilder.add ( node ) ; } } newTable[i] = leftSize > 0 ? leftBuilder.root ( ) : null ; newTable[i + oldCapacity] = rightSize > 0 ? rightBuilder.root ( ) : null ; } return newTable ; } 
public Node < K , V > next ( ) { Node < K , V > stackTop = this.stackTop ; if ( stackTop == null ) { return null ; } Node < K , V > result = stackTop ; stackTop = result.parent ; result.parent = null ; for ( Node < K , V > n = result.right ; n != null ; n = n.left ) { n.parent = stackTop ; stackTop = n ; } this.stackTop = stackTop ; return result ; } 
void add ( Node < K , V > node ) { node.left = node.parent = node.right = null ; node.height = 1 ; if ( leavesToSkip > 0 && ( size & 1 ) == 0 ) { size++ ; leavesToSkip-- ; leavesSkipped++ ; } node.parent = stack ; stack = node ; size++ ; if ( leavesToSkip > 0 && ( size & 1 ) == 0 ) { size++ ; leavesToSkip-- ; leavesSkipped++ ; } for ( int scale = 4 ; ( size & scale - 1 ) == scale - 1 ; scale *= 2 ) { if ( leavesSkipped == 0 ) { Node < K , V > right = stack ; Node < K , V > center = right.parent ; Node < K , V > left = center.parent ; center.parent = left.parent ; stack = center ; center.left = left ; center.right = right ; center.height = right.height + 1 ; left.parent = center ; right.parent = center ; } else if ( leavesSkipped == 1 ) { Node < K , V > right = stack ; Node < K , V > center = right.parent ; stack = center ; center.right = right ; center.height = right.height + 1 ; right.parent = center ; leavesSkipped = 0 ; } else if ( leavesSkipped == 2 ) { leavesSkipped = 0 ; } } } 
public Iterator < Entry < K , V > > iterator ( ) { return new LinkedTreeMapIterator < Entry < K , V > > ( ) { public Entry < K , V > next ( ) { return nextNode ( ) ; } } ; } 
public Iterator < K > iterator ( ) { return new LinkedTreeMapIterator < K > ( ) { public K next ( ) { return nextNode ( ) .key ; } } ; } 
Node < K , V > find ( K key , boolean create ) { Comparator < ? super K > comparator = this.comparator ; Node < K , V > nearest = root ; int comparison = 0 ; if ( nearest != null ) { @SuppressWarnings ( " unchecked " ) Comparable < Object > comparableKey = ( comparator == NATURAL_ORDER ) ? ( Comparable < Object > ) key : null ; while ( true ) { comparison = ( comparableKey != null ) ? comparableKey.compareTo ( nearest.key ) : comparator.compare ( key , nearest.key ) ; if ( comparison == 0 ) { return nearest ; } Node < K , V > child = ( comparison < 0 ) ? nearest.left : nearest.right ; if ( child == null ) { break ; } nearest = child ; } } if ( !create ) { return null ; } Node < K , V > header = this.header ; Node < K , V > created ; if ( nearest == null ) { if ( comparator == NATURAL_ORDER && ! ( key instanceof Comparable ) ) { throw new ClassCastException ( key.getClass ( ) .getName ( ) + " is not Comparable " ) ; } created = new Node < K , V > ( nearest , key , header , header.prev ) ; root = created ; } else { created = new Node < K , V > ( nearest , key , header , header.prev ) ; if ( comparison < 0 ) { nearest.left = created ; } else { nearest.right = created ; } rebalance ( nearest , true ) ; } size++ ; modCount++ ; return created ; } 
void removeInternal ( Node < K , V > node , boolean unlink ) { if ( unlink ) { node.prev.next = node.next ; node.next.prev = node.prev ; } Node < K , V > left = node.left ; Node < K , V > right = node.right ; Node < K , V > originalParent = node.parent ; if ( left != null && right != null ) { Node < K , V > adjacent = ( left.height > right.height ) ? left.last ( ) : right.first ( ) ; removeInternal ( adjacent , false ) ; int leftHeight = 0 ; left = node.left ; if ( left != null ) { leftHeight = left.height ; adjacent.left = left ; left.parent = adjacent ; node.left = null ; } int rightHeight = 0 ; right = node.right ; if ( right != null ) { rightHeight = right.height ; adjacent.right = right ; right.parent = adjacent ; node.right = null ; } adjacent.height = Math.max ( leftHeight , rightHeight ) + 1 ; replaceInParent ( node , adjacent ) ; return ; } else if ( left != null ) { replaceInParent ( node , left ) ; node.left = null ; } else if ( right != null ) { replaceInParent ( node , right ) ; node.right = null ; } else { replaceInParent ( node , null ) ; } rebalance ( originalParent , false ) ; size-- ; modCount++ ; } 
private void replaceInParent ( Node < K , V > node , Node < K , V > replacement ) { Node < K , V > parent = node.parent ; node.parent = null ; if ( replacement != null ) { replacement.parent = parent ; } if ( parent != null ) { if ( parent.left == node ) { parent.left = replacement ; } else { assert ( parent.right == node ) ; parent.right = replacement ; } } else { root = replacement ; } } 
private static String getDateFormatPattern ( int style ) { switch ( style ) { case DateFormat.SHORT: return " M/d/yy " ; case DateFormat.MEDIUM: return " MMM d , y " ; case DateFormat.LONG: return " MMMM d , y " ; case DateFormat.FULL: return " EEEE , MMMM d , y " ; default: throw new IllegalArgumentException ( " Unknown DateFormat style: " + style ) ; } } 
private static String getDatePartOfDateTimePattern ( int dateStyle ) { switch ( dateStyle ) { case DateFormat.SHORT: return " M/d/yy " ; case DateFormat.MEDIUM: return " MMM d , yyyy " ; case DateFormat.LONG: return " MMMM d , yyyy " ; case DateFormat.FULL: return " EEEE , MMMM d , yyyy " ; default: throw new IllegalArgumentException ( " Unknown DateFormat style: " + dateStyle ) ; } } 
private static String getTimePartOfDateTimePattern ( int timeStyle ) { switch ( timeStyle ) { case DateFormat.SHORT: return " h:mm a " ; case DateFormat.MEDIUM: return " h:mm:ss a " ; case DateFormat.FULL: case DateFormat.LONG: return " h:mm:ss a z " ; default: throw new IllegalArgumentException ( " Unknown DateFormat style: " + timeStyle ) ; } } 
boolean makeAccessibleWithUnsafe ( AccessibleObject ao ) { if ( theUnsafe != null && overrideField != null ) { try { Method method = unsafeClass.getMethod ( " objectFieldOffset " , Field.class ) ; long overrideOffset = ( Long ) method.invoke ( theUnsafe , overrideField ) ; Method putBooleanMethod = unsafeClass.getMethod ( " putBoolean " , Object.class , long.class , boolean.class ) ; putBooleanMethod.invoke ( theUnsafe , ao , overrideOffset , true ) ; return true ; } catch ( Exception ignored ) { } } return false ; } 
public static JsonElement parse ( JsonReader reader ) throws JsonParseException { boolean isEmpty = true ; try { reader.peek ( ) ; isEmpty = false ; return TypeAdapters.JSON_ELEMENT.read ( reader ) ; } catch ( EOFException e ) { if ( isEmpty ) { return JsonNull.INSTANCE ; } throw new JsonSyntaxException ( e ) ; } catch ( MalformedJsonException e ) { throw new JsonSyntaxException ( e ) ; } catch ( IOException e ) { throw new JsonIOException ( e ) ; } catch ( NumberFormatException e ) { throw new JsonSyntaxException ( e ) ; } } 
public void flush ( ) { } 
public void close ( ) { } 
public static UnsafeAllocator create ( ) { try { Class < ? > unsafeClass = Class.forName ( " sun.misc.Unsafe " ) ; Field f = unsafeClass.getDeclaredField ( " theUnsafe " ) ; f.setAccessible ( true ) ; final Object unsafe = f.get ( null ) ; final Method allocateInstance = unsafeClass.getMethod ( " allocateInstance " , Class.class ) ; return new UnsafeAllocator ( ) { @Override @SuppressWarnings ( " unchecked " ) public < T > T newInstance ( Class < T > c ) throws Exception { assertInstantiable ( c ) ; return ( T ) allocateInstance.invoke ( unsafe , c ) ; } } ; } catch ( Exception ignored ) { } try { Method getConstructorId = ObjectStreamClass.class.getDeclaredMethod ( " getConstructorId " , Class.class ) ; getConstructorId.setAccessible ( true ) ; final int constructorId = ( Integer ) getConstructorId.invoke ( null , Object.class ) ; final Method newInstance = ObjectStreamClass.class.getDeclaredMethod ( " newInstance " , Class.class , int.class ) ; newInstance.setAccessible ( true ) ; return new UnsafeAllocator ( ) { @Override @SuppressWarnings ( " unchecked " ) public < T > T newInstance ( Class < T > c ) throws Exception { assertInstantiable ( c ) ; return ( T ) newInstance.invoke ( null , c , constructorId ) ; } } ; } catch ( Exception ignored ) { } try { final Method newInstance = ObjectInputStream.class.getDeclaredMethod ( " newInstance " , Class.class , Class.class ) ; newInstance.setAccessible ( true ) ; return new UnsafeAllocator ( ) { @Override @SuppressWarnings ( " unchecked " ) public < T > T newInstance ( Class < T > c ) throws Exception { assertInstantiable ( c ) ; return ( T ) newInstance.invoke ( null , c , Object.class ) ; } } ; } catch ( Exception ignored ) { } return new UnsafeAllocator ( ) { @Override public < T > T newInstance ( Class < T > c ) { throw new UnsupportedOperationException ( " Cannot allocate " + c ) ; } } ; } 
public void add ( Boolean bool ) { elements.add ( bool == null ? JsonNull.INSTANCE : new JsonPrimitive ( bool ) ) ; } 
public JsonElement parse ( Reader json ) throws JsonIOException , JsonSyntaxException { try { JsonReader jsonReader = new JsonReader ( json ) ; JsonElement element = parse ( jsonReader ) ; if ( !element.isJsonNull ( ) && jsonReader.peek ( ) != JsonToken.END_DOCUMENT ) { throw new JsonSyntaxException ( " Did not consume the entire document. " ) ; } return element ; } catch ( MalformedJsonException e ) { throw new JsonSyntaxException ( e ) ; } catch ( IOException e ) { throw new JsonIOException ( e ) ; } catch ( NumberFormatException e ) { throw new JsonSyntaxException ( e ) ; } } 
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj.getClass ( ) ) { return false ; } JsonPrimitive other = ( JsonPrimitive ) obj ; if ( value == null ) { return other.value == null ; } if ( isIntegral ( this ) && isIntegral ( other ) ) { return getAsNumber ( ) .longValue ( ) == other.getAsNumber ( ) .longValue ( ) ; } if ( value instanceof Number && other.value instanceof Number ) { double a = getAsNumber ( ) .doubleValue ( ) ; double b = other.getAsNumber ( ) .doubleValue ( ) ; return a == b || ( Double.isNaN ( a ) && Double.isNaN ( b ) ) ; } return value.equals ( other.value ) ; } 
public void remove ( ) { throw new UnsupportedOperationException ( ) ; } 
public boolean getAsBoolean ( ) { throw new UnsupportedOperationException ( getClass ( ) .getSimpleName ( ) ) ; }
Boolean getAsBooleanWrapper ( ) { throw new UnsupportedOperationException ( getClass ( ) .getSimpleName ( ) ) ; }
public Number getAsNumber ( ) { throw new UnsupportedOperationException ( getClass ( ) .getSimpleName ( ) ) ; }
public String getAsString ( ) { throw new UnsupportedOperationException ( getClass ( ) .getSimpleName ( ) ) ; }
public double getAsDouble ( ) { throw new UnsupportedOperationException ( getClass ( ) .getSimpleName ( ) ) ; }
public float getAsFloat ( ) { throw new UnsupportedOperationException ( getClass ( ) .getSimpleName ( ) ) ; }
public long getAsLong ( ) { throw new UnsupportedOperationException ( getClass ( ) .getSimpleName ( ) ) ; }
public int getAsInt ( ) { throw new UnsupportedOperationException ( getClass ( ) .getSimpleName ( ) ) ; }
public byte getAsByte ( ) { throw new UnsupportedOperationException ( getClass ( ) .getSimpleName ( ) ) ; }
public char getAsCharacter ( ) { throw new UnsupportedOperationException ( getClass ( ) .getSimpleName ( ) ) ; }
public BigDecimal getAsBigDecimal ( ) { throw new UnsupportedOperationException ( getClass ( ) .getSimpleName ( ) ) ; }
public BigInteger getAsBigInteger ( ) { throw new UnsupportedOperationException ( getClass ( ) .getSimpleName ( ) ) ; }
public short getAsShort ( ) { throw new UnsupportedOperationException ( getClass ( ) .getSimpleName ( ) ) ; }
public void write ( JsonWriter out , Class value ) throws IOException { throw new UnsupportedOperationException ( " Attempted to serialize java.lang.Class: " + value.getName ( ) + " . Forgot to register a type adapter? " ) ; }
public Class read ( JsonReader in ) throws IOException { throw new UnsupportedOperationException ( " Attempted to deserialize a java.lang.Class. Forgot to register a type adapter? " ) ; }
public < T > T newInstance ( Class < T > c ) { throw new UnsupportedOperationException ( " Cannot allocate " + c ) ; }
static void assertInstantiable ( Class < ? > c ) { int modifiers = c.getModifiers ( ) ; if ( Modifier.isInterface ( modifiers ) ) { throw new UnsupportedOperationException ( " Interface can't be instantiated! Interface name: " + c.getName ( ) ) ; } if ( Modifier.isAbstract ( modifiers ) ) { throw new UnsupportedOperationException ( " Abstract class can't be instantiated! Class name: " + c.getName ( ) ) ; } }
public boolean isAssignableFrom ( Type from ) { if ( from == null ) { return false ; } if ( type.equals ( from ) ) { return true ; } if ( type instanceof Class < ? > ) { return rawType.isAssignableFrom ( $Gson$Types.getRawType ( from ) ) ; } else if ( type instanceof ParameterizedType ) { return isAssignableFrom ( from , ( ParameterizedType ) type , new HashMap < String , Type > ( ) ) ; } else if ( type instanceof GenericArrayType ) { return rawType.isAssignableFrom ( $Gson$Types.getRawType ( from ) ) && isAssignableFrom ( from , ( GenericArrayType ) type ) ; } else { throw buildUnexpectedTypeError ( type , Class.class , ParameterizedType.class , GenericArrayType.class ) ; } } 
private static boolean isAssignableFrom ( Type from , GenericArrayType to ) { Type toGenericComponentType = to.getGenericComponentType ( ) ; if ( toGenericComponentType instanceof ParameterizedType ) { Type t = from ; if ( from instanceof GenericArrayType ) { t = ( ( GenericArrayType ) from ) .getGenericComponentType ( ) ; } else if ( from instanceof Class < ? > ) { Class < ? > classType = ( Class < ? > ) from ; while ( classType.isArray ( ) ) { classType = classType.getComponentType ( ) ; } t = classType ; } return isAssignableFrom ( t , ( ParameterizedType ) toGenericComponentType , new HashMap < String , Type > ( ) ) ; } return true ; } 
private static boolean isAssignableFrom ( Type from , ParameterizedType to , Map < String , Type > typeVarMap ) { if ( from == null ) { return false ; } if ( to.equals ( from ) ) { return true ; } Class < ? > clazz = $Gson$Types.getRawType ( from ) ; ParameterizedType ptype = null ; if ( from instanceof ParameterizedType ) { ptype = ( ParameterizedType ) from ; } if ( ptype != null ) { Type[] tArgs = ptype.getActualTypeArguments ( ) ; TypeVariable < ? > [] tParams = clazz.getTypeParameters ( ) ; for ( int i = 0 ; i < tArgs.length ; i++ ) { Type arg = tArgs[i] ; TypeVariable < ? > var = tParams[i] ; while ( arg instanceof TypeVariable < ? > ) { TypeVariable < ? > v = ( TypeVariable < ? > ) arg ; arg = typeVarMap.get ( v.getName ( ) ) ; } typeVarMap.put ( var.getName ( ) , arg ) ; } if ( typeEquals ( ptype , to , typeVarMap ) ) { return true ; } } for ( Type itype : clazz.getGenericInterfaces ( ) ) { if ( isAssignableFrom ( itype , to , new HashMap < String , Type > ( typeVarMap ) ) ) { return true ; } } Type sType = clazz.getGenericSuperclass ( ) ; return isAssignableFrom ( sType , to , new HashMap < String , Type > ( typeVarMap ) ) ; } 
private static AssertionError buildUnexpectedTypeError ( Type token , Class < ? > ... expected ) { StringBuilder exceptionMessage = new StringBuilder ( " Unexpected type. Expected one of: " ) ; for ( Class < ? > clazz : expected ) { exceptionMessage.append ( clazz.getName ( ) ) .append ( " , " ) ; } exceptionMessage.append ( " but got: " ) .append ( token.getClass ( ) .getName ( ) ) .append ( " , for type token: " ) .append ( token.toString ( ) ) .append ( '.' ) ; return new AssertionError ( exceptionMessage.toString ( ) ) ; } 
public JsonToken peek ( ) throws IOException { int p = peeked ; if ( p == PEEKED_NONE ) { p = doPeek ( ) ; } switch ( p ) { case PEEKED_BEGIN_OBJECT: return JsonToken.BEGIN_OBJECT ; case PEEKED_END_OBJECT: return JsonToken.END_OBJECT ; case PEEKED_BEGIN_ARRAY: return JsonToken.BEGIN_ARRAY ; case PEEKED_END_ARRAY: return JsonToken.END_ARRAY ; case PEEKED_SINGLE_QUOTED_NAME: case PEEKED_DOUBLE_QUOTED_NAME: case PEEKED_UNQUOTED_NAME: return JsonToken.NAME ; case PEEKED_TRUE: case PEEKED_FALSE: return JsonToken.BOOLEAN ; case PEEKED_NULL: return JsonToken.NULL ; case PEEKED_SINGLE_QUOTED: case PEEKED_DOUBLE_QUOTED: case PEEKED_UNQUOTED: case PEEKED_BUFFERED: return JsonToken.STRING ; case PEEKED_LONG: case PEEKED_NUMBER: return JsonToken.NUMBER ; case PEEKED_EOF: return JsonToken.END_DOCUMENT ; default: throw new AssertionError ( ) ; } } 
int doPeek ( ) throws IOException { int peekStack = stack[stackSize - 1] ; if ( peekStack == JsonScope.EMPTY_ARRAY ) { stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY ; } else if ( peekStack == JsonScope.NONEMPTY_ARRAY ) { int c = nextNonWhitespace ( true ) ; switch ( c ) { case ']': return peeked = PEEKED_END_ARRAY ; case ' ; ': checkLenient ( ) ; case ' , ': break ; default: throw syntaxError ( " Unterminated array " ) ; } } else if ( peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT ) { stack[stackSize - 1] = JsonScope.DANGLING_NAME ; if ( peekStack == JsonScope.NONEMPTY_OBJECT ) { int c = nextNonWhitespace ( true ) ; switch ( c ) { case ' } ': return peeked = PEEKED_END_OBJECT ; case ' ; ': checkLenient ( ) ; case ' , ': break ; default: throw syntaxError ( " Unterminated object " ) ; } } int c = nextNonWhitespace ( true ) ; switch ( c ) { case ' " ': return peeked = PEEKED_DOUBLE_QUOTED_NAME ; case '\'': checkLenient ( ) ; return peeked = PEEKED_SINGLE_QUOTED_NAME ; case ' } ': if ( peekStack != JsonScope.NONEMPTY_OBJECT ) { return peeked = PEEKED_END_OBJECT ; } else { throw syntaxError ( " Expected name " ) ; } default: checkLenient ( ) ; pos-- ; if ( isLiteral ( ( char ) c ) ) { return peeked = PEEKED_UNQUOTED_NAME ; } else { throw syntaxError ( " Expected name " ) ; } } } else if ( peekStack == JsonScope.DANGLING_NAME ) { stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT ; int c = nextNonWhitespace ( true ) ; switch ( c ) { case ':': break ; case '=': checkLenient ( ) ; if ( ( pos < limit || fillBuffer ( 1 ) ) && buffer[pos] == ' > ' ) { pos++ ; } break ; default: throw syntaxError ( " Expected ':' " ) ; } } else if ( peekStack == JsonScope.EMPTY_DOCUMENT ) { if ( lenient ) { consumeNonExecutePrefix ( ) ; } stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT ; } else if ( peekStack == JsonScope.NONEMPTY_DOCUMENT ) { int c = nextNonWhitespace ( false ) ; if ( c == -1 ) { return peeked = PEEKED_EOF ; } else { checkLenient ( ) ; pos-- ; } } else if ( peekStack == JsonScope.CLOSED ) { throw new IllegalStateException ( " JsonReader is closed " ) ; } int c = nextNonWhitespace ( true ) ; switch ( c ) { case ']': if ( peekStack == JsonScope.EMPTY_ARRAY ) { return peeked = PEEKED_END_ARRAY ; } case ' ; ': case ' , ': if ( peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY ) { checkLenient ( ) ; pos-- ; return peeked = PEEKED_NULL ; } else { throw syntaxError ( " Unexpected value " ) ; } case '\'': checkLenient ( ) ; return peeked = PEEKED_SINGLE_QUOTED ; case ' " ': return peeked = PEEKED_DOUBLE_QUOTED ; case '[': return peeked = PEEKED_BEGIN_ARRAY ; case ' { ': return peeked = PEEKED_BEGIN_OBJECT ; default: pos-- ; } int result = peekKeyword ( ) ; if ( result != PEEKED_NONE ) { return result ; } result = peekNumber ( ) ; if ( result != PEEKED_NONE ) { return result ; } if ( !isLiteral ( buffer[pos] ) ) { throw syntaxError ( " Expected value " ) ; } checkLenient ( ) ; return peeked = PEEKED_UNQUOTED ; } 
private int peekKeyword ( ) throws IOException { char c = buffer[pos] ; String keyword ; String keywordUpper ; int peeking ; if ( c == 't' || c == 'T' ) { keyword = " true " ; keywordUpper = " TRUE " ; peeking = PEEKED_TRUE ; } else if ( c == 'f' || c == 'F' ) { keyword = " false " ; keywordUpper = " FALSE " ; peeking = PEEKED_FALSE ; } else if ( c == 'n' || c == 'N' ) { keyword = " null " ; keywordUpper = " NULL " ; peeking = PEEKED_NULL ; } else { return PEEKED_NONE ; } int length = keyword.length ( ) ; for ( int i = 1 ; i < length ; i++ ) { if ( pos + i > = limit && !fillBuffer ( i + 1 ) ) { return PEEKED_NONE ; } c = buffer[pos + i] ; if ( c != keyword.charAt ( i ) && c != keywordUpper.charAt ( i ) ) { return PEEKED_NONE ; } } if ( ( pos + length < limit || fillBuffer ( length + 1 ) ) && isLiteral ( buffer[pos + length] ) ) { return PEEKED_NONE ; } pos += length ; return peeked = peeking ; } 
private int peekNumber ( ) throws IOException { char[] buffer = this.buffer ; int p = pos ; int l = limit ; long value = 0 ; boolean negative = false ; boolean fitsInLong = true ; int last = NUMBER_CHAR_NONE ; int i = 0 ; charactersOfNumber: for ( ; true ; i++ ) { if ( p + i == l ) { if ( i == buffer.length ) { return PEEKED_NONE ; } if ( !fillBuffer ( i + 1 ) ) { break ; } p = pos ; l = limit ; } char c = buffer[p + i] ; switch ( c ) { case '-': if ( last == NUMBER_CHAR_NONE ) { negative = true ; last = NUMBER_CHAR_SIGN ; continue ; } else if ( last == NUMBER_CHAR_EXP_E ) { last = NUMBER_CHAR_EXP_SIGN ; continue ; } return PEEKED_NONE ; case '+': if ( last == NUMBER_CHAR_EXP_E ) { last = NUMBER_CHAR_EXP_SIGN ; continue ; } return PEEKED_NONE ; case 'e': case 'E': if ( last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT ) { last = NUMBER_CHAR_EXP_E ; continue ; } return PEEKED_NONE ; case '.': if ( last == NUMBER_CHAR_DIGIT ) { last = NUMBER_CHAR_DECIMAL ; continue ; } return PEEKED_NONE ; default: if ( c < '0' || c > '9' ) { if ( !isLiteral ( c ) ) { break charactersOfNumber ; } return PEEKED_NONE ; } if ( last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE ) { value = - ( c - '0' ) ; last = NUMBER_CHAR_DIGIT ; } else if ( last == NUMBER_CHAR_DIGIT ) { if ( value == 0 ) { return PEEKED_NONE ; } long newValue = value * 10 - ( c - '0' ) ; fitsInLong &= value > MIN_INCOMPLETE_INTEGER || ( value == MIN_INCOMPLETE_INTEGER && newValue < value ) ; value = newValue ; } else if ( last == NUMBER_CHAR_DECIMAL ) { last = NUMBER_CHAR_FRACTION_DIGIT ; } else if ( last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN ) { last = NUMBER_CHAR_EXP_DIGIT ; } } } if ( last == NUMBER_CHAR_DIGIT && fitsInLong && ( value != Long.MIN_VALUE || negative ) && ( value != 0 || false == negative ) ) { peekedLong = negative ? value : -value ; pos += i ; return peeked = PEEKED_LONG ; } else if ( last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT ) { peekedNumberLength = i ; return peeked = PEEKED_NUMBER ; } else { return PEEKED_NONE ; } } 
private boolean isLiteral ( char c ) throws IOException { switch ( c ) { case '/': case '\\': case ' ; ': case '#': case '=': checkLenient ( ) ; case ' { ': case ' } ': case '[': case ']': case ':': case ' , ': case ' ': case '\t': case '\f': case '\r': case '\n': return false ; default: return true ; } } 
public String nextName ( ) throws IOException { int p = peeked ; if ( p == PEEKED_NONE ) { p = doPeek ( ) ; } String result ; if ( p == PEEKED_UNQUOTED_NAME ) { result = nextUnquotedValue ( ) ; } else if ( p == PEEKED_SINGLE_QUOTED_NAME ) { result = nextQuotedValue ( '\'' ) ; } else if ( p == PEEKED_DOUBLE_QUOTED_NAME ) { result = nextQuotedValue ( ' " ' ) ; } else { throw new IllegalStateException ( " Expected a name but was " + peek ( ) + locationString ( ) ) ; } peeked = PEEKED_NONE ; pathNames[stackSize - 1] = result ; return result ; } 
public String nextString ( ) throws IOException { int p = peeked ; if ( p == PEEKED_NONE ) { p = doPeek ( ) ; } String result ; if ( p == PEEKED_UNQUOTED ) { result = nextUnquotedValue ( ) ; } else if ( p == PEEKED_SINGLE_QUOTED ) { result = nextQuotedValue ( '\'' ) ; } else if ( p == PEEKED_DOUBLE_QUOTED ) { result = nextQuotedValue ( ' " ' ) ; } else if ( p == PEEKED_BUFFERED ) { result = peekedString ; peekedString = null ; } else if ( p == PEEKED_LONG ) { result = Long.toString ( peekedLong ) ; } else if ( p == PEEKED_NUMBER ) { result = new String ( buffer , pos , peekedNumberLength ) ; pos += peekedNumberLength ; } else { throw new IllegalStateException ( " Expected a string but was " + peek ( ) + locationString ( ) ) ; } peeked = PEEKED_NONE ; pathIndices[stackSize - 1]++ ; return result ; } 
public boolean nextBoolean ( ) throws IOException { int p = peeked ; if ( p == PEEKED_NONE ) { p = doPeek ( ) ; } if ( p == PEEKED_TRUE ) { peeked = PEEKED_NONE ; pathIndices[stackSize - 1]++ ; return true ; } else if ( p == PEEKED_FALSE ) { peeked = PEEKED_NONE ; pathIndices[stackSize - 1]++ ; return false ; } throw new IllegalStateException ( " Expected a boolean but was " + peek ( ) + locationString ( ) ) ; } 
public void nextNull ( ) throws IOException { int p = peeked ; if ( p == PEEKED_NONE ) { p = doPeek ( ) ; } if ( p == PEEKED_NULL ) { peeked = PEEKED_NONE ; pathIndices[stackSize - 1]++ ; } else { throw new IllegalStateException ( " Expected null but was " + peek ( ) + locationString ( ) ) ; } } 
public double nextDouble ( ) throws IOException { int p = peeked ; if ( p == PEEKED_NONE ) { p = doPeek ( ) ; } if ( p == PEEKED_LONG ) { peeked = PEEKED_NONE ; pathIndices[stackSize - 1]++ ; return ( double ) peekedLong ; } if ( p == PEEKED_NUMBER ) { peekedString = new String ( buffer , pos , peekedNumberLength ) ; pos += peekedNumberLength ; } else if ( p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED ) { peekedString = nextQuotedValue ( p == PEEKED_SINGLE_QUOTED ? '\'' : ' " ' ) ; } else if ( p == PEEKED_UNQUOTED ) { peekedString = nextUnquotedValue ( ) ; } else if ( p != PEEKED_BUFFERED ) { throw new IllegalStateException ( " Expected a double but was " + peek ( ) + locationString ( ) ) ; } peeked = PEEKED_BUFFERED ; double result = Double.parseDouble ( peekedString ) ; if ( !lenient && ( Double.isNaN ( result ) || Double.isInfinite ( result ) ) ) { throw new MalformedJsonException ( " JSON forbids NaN and infinities: " + result + locationString ( ) ) ; } peekedString = null ; peeked = PEEKED_NONE ; pathIndices[stackSize - 1]++ ; return result ; } 
public long nextLong ( ) throws IOException { int p = peeked ; if ( p == PEEKED_NONE ) { p = doPeek ( ) ; } if ( p == PEEKED_LONG ) { peeked = PEEKED_NONE ; pathIndices[stackSize - 1]++ ; return peekedLong ; } if ( p == PEEKED_NUMBER ) { peekedString = new String ( buffer , pos , peekedNumberLength ) ; pos += peekedNumberLength ; } else if ( p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED ) { if ( p == PEEKED_UNQUOTED ) { peekedString = nextUnquotedValue ( ) ; } else { peekedString = nextQuotedValue ( p == PEEKED_SINGLE_QUOTED ? '\'' : ' " ' ) ; } try { long result = Long.parseLong ( peekedString ) ; peeked = PEEKED_NONE ; pathIndices[stackSize - 1]++ ; return result ; } catch ( NumberFormatException ignored ) { } } else { throw new IllegalStateException ( " Expected a long but was " + peek ( ) + locationString ( ) ) ; } peeked = PEEKED_BUFFERED ; double asDouble = Double.parseDouble ( peekedString ) ; long result = ( long ) asDouble ; if ( result != asDouble ) { throw new NumberFormatException ( " Expected a long but was " + peekedString + locationString ( ) ) ; } peekedString = null ; peeked = PEEKED_NONE ; pathIndices[stackSize - 1]++ ; return result ; } 
private String nextQuotedValue ( char quote ) throws IOException { char[] buffer = this.buffer ; StringBuilder builder = null ; while ( true ) { int p = pos ; int l = limit ; int start = p ; while ( p < l ) { int c = buffer[p++] ; if ( c == quote ) { pos = p ; int len = p - start - 1 ; if ( builder == null ) { return new String ( buffer , start , len ) ; } else { builder.append ( buffer , start , len ) ; return builder.toString ( ) ; } } else if ( c == '\\' ) { pos = p ; int len = p - start - 1 ; if ( builder == null ) { int estimatedLength = ( len + 1 ) * 2 ; builder = new StringBuilder ( Math.max ( estimatedLength , 16 ) ) ; } builder.append ( buffer , start , len ) ; builder.append ( readEscapeCharacter ( ) ) ; p = pos ; l = limit ; start = p ; } else if ( c == '\n' ) { lineNumber++ ; lineStart = p ; } } if ( builder == null ) { int estimatedLength = ( p - start ) * 2 ; builder = new StringBuilder ( Math.max ( estimatedLength , 16 ) ) ; } builder.append ( buffer , start , p - start ) ; pos = p ; if ( !fillBuffer ( 1 ) ) { throw syntaxError ( " Unterminated string " ) ; } } } 
private String nextUnquotedValue ( ) throws IOException { StringBuilder builder = null ; int i = 0 ; findNonLiteralCharacter: while ( true ) { for ( ; pos + i < limit ; i++ ) { switch ( buffer[pos + i] ) { case '/': case '\\': case ' ; ': case '#': case '=': checkLenient ( ) ; case ' { ': case ' } ': case '[': case ']': case ':': case ' , ': case ' ': case '\t': case '\f': case '\r': case '\n': break findNonLiteralCharacter ; } } if ( i < buffer.length ) { if ( fillBuffer ( i + 1 ) ) { continue ; } else { break ; } } if ( builder == null ) { builder = new StringBuilder ( Math.max ( i , 16 ) ) ; } builder.append ( buffer , pos , i ) ; pos += i ; i = 0 ; if ( !fillBuffer ( 1 ) ) { break ; } } String result = ( null == builder ) ? new String ( buffer , pos , i ) : builder.append ( buffer , pos , i ) .toString ( ) ; pos += i ; return result ; } 
private void skipQuotedValue ( char quote ) throws IOException { char[] buffer = this.buffer ; do { int p = pos ; int l = limit ; while ( p < l ) { int c = buffer[p++] ; if ( c == quote ) { pos = p ; return ; } else if ( c == '\\' ) { pos = p ; readEscapeCharacter ( ) ; p = pos ; l = limit ; } else if ( c == '\n' ) { lineNumber++ ; lineStart = p ; } } pos = p ; } while ( fillBuffer ( 1 ) ) ; throw syntaxError ( " Unterminated string " ) ; } 
private void skipUnquotedValue ( ) throws IOException { do { int i = 0 ; for ( ; pos + i < limit ; i++ ) { switch ( buffer[pos + i] ) { case '/': case '\\': case ' ; ': case '#': case '=': checkLenient ( ) ; case ' { ': case ' } ': case '[': case ']': case ':': case ' , ': case ' ': case '\t': case '\f': case '\r': case '\n': pos += i ; return ; } } pos += i ; } while ( fillBuffer ( 1 ) ) ; } 
public int nextInt ( ) throws IOException { int p = peeked ; if ( p == PEEKED_NONE ) { p = doPeek ( ) ; } int result ; if ( p == PEEKED_LONG ) { result = ( int ) peekedLong ; if ( peekedLong != result ) { throw new NumberFormatException ( " Expected an int but was " + peekedLong + locationString ( ) ) ; } peeked = PEEKED_NONE ; pathIndices[stackSize - 1]++ ; return result ; } if ( p == PEEKED_NUMBER ) { peekedString = new String ( buffer , pos , peekedNumberLength ) ; pos += peekedNumberLength ; } else if ( p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED ) { if ( p == PEEKED_UNQUOTED ) { peekedString = nextUnquotedValue ( ) ; } else { peekedString = nextQuotedValue ( p == PEEKED_SINGLE_QUOTED ? '\'' : ' " ' ) ; } try { result = Integer.parseInt ( peekedString ) ; peeked = PEEKED_NONE ; pathIndices[stackSize - 1]++ ; return result ; } catch ( NumberFormatException ignored ) { } } else { throw new IllegalStateException ( " Expected an int but was " + peek ( ) + locationString ( ) ) ; } peeked = PEEKED_BUFFERED ; double asDouble = Double.parseDouble ( peekedString ) ; result = ( int ) asDouble ; if ( result != asDouble ) { throw new NumberFormatException ( " Expected an int but was " + peekedString + locationString ( ) ) ; } peekedString = null ; peeked = PEEKED_NONE ; pathIndices[stackSize - 1]++ ; return result ; } 
public void skipValue ( ) throws IOException { int count = 0 ; do { int p = peeked ; if ( p == PEEKED_NONE ) { p = doPeek ( ) ; } if ( p == PEEKED_BEGIN_ARRAY ) { push ( JsonScope.EMPTY_ARRAY ) ; count++ ; } else if ( p == PEEKED_BEGIN_OBJECT ) { push ( JsonScope.EMPTY_OBJECT ) ; count++ ; } else if ( p == PEEKED_END_ARRAY ) { stackSize-- ; count-- ; } else if ( p == PEEKED_END_OBJECT ) { stackSize-- ; count-- ; } else if ( p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED ) { skipUnquotedValue ( ) ; } else if ( p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME ) { skipQuotedValue ( '\'' ) ; } else if ( p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME ) { skipQuotedValue ( ' " ' ) ; } else if ( p == PEEKED_NUMBER ) { pos += peekedNumberLength ; } peeked = PEEKED_NONE ; } while ( count != 0 ) ; pathIndices[stackSize - 1]++ ; pathNames[stackSize - 1] = " null " ; } 
private boolean fillBuffer ( int minimum ) throws IOException { char[] buffer = this.buffer ; lineStart -= pos ; if ( limit != pos ) { limit -= pos ; System.arraycopy ( buffer , pos , buffer , 0 , limit ) ; } else { limit = 0 ; } pos = 0 ; int total ; while ( ( total = in.read ( buffer , limit , buffer.length - limit ) ) != -1 ) { limit += total ; if ( lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\ufeff' ) { pos++ ; lineStart++ ; minimum++ ; } if ( limit > = minimum ) { return true ; } } return false ; } 
private int nextNonWhitespace ( boolean throwOnEof ) throws IOException { char[] buffer = this.buffer ; int p = pos ; int l = limit ; while ( true ) { if ( p == l ) { pos = p ; if ( !fillBuffer ( 1 ) ) { break ; } p = pos ; l = limit ; } int c = buffer[p++] ; if ( c == '\n' ) { lineNumber++ ; lineStart = p ; continue ; } else if ( c == ' ' || c == '\r' || c == '\t' ) { continue ; } if ( c == '/' ) { pos = p ; if ( p == l ) { pos-- ; boolean charsLoaded = fillBuffer ( 2 ) ; pos++ ; if ( !charsLoaded ) { return c ; } } checkLenient ( ) ; char peek = buffer[pos] ; switch ( peek ) { case '*': pos++ ; if ( !skipTo ( " */ " ) ) { throw syntaxError ( " Unterminated comment " ) ; } p = pos + 2 ; l = limit ; continue ; case '/': pos++ ; skipToEndOfLine ( ) ; p = pos ; l = limit ; continue ; default: return c ; } } else if ( c == '#' ) { pos = p ; checkLenient ( ) ; skipToEndOfLine ( ) ; p = pos ; l = limit ; } else { pos = p ; return c ; } } if ( throwOnEof ) { throw new EOFException ( " End of input " + locationString ( ) ) ; } else { return -1 ; } } 
private boolean skipTo ( String toFind ) throws IOException { int length = toFind.length ( ) ; outer: for ( ; pos + length < = limit || fillBuffer ( length ) ; pos++ ) { if ( buffer[pos] == '\n' ) { lineNumber++ ; lineStart = pos + 1 ; continue ; } for ( int c = 0 ; c < length ; c++ ) { if ( buffer[pos + c] != toFind.charAt ( c ) ) { continue outer ; } } return true ; } return false ; } 
public String getPath ( ) { StringBuilder result = new StringBuilder ( ) .append ( '$' ) ; for ( int i = 0 , size = stackSize ; i < size ; i++ ) { switch ( stack[i] ) { case JsonScope.EMPTY_ARRAY: case JsonScope.NONEMPTY_ARRAY: result.append ( '[' ) .append ( pathIndices[i] ) .append ( ']' ) ; break ; case JsonScope.EMPTY_OBJECT: case JsonScope.DANGLING_NAME: case JsonScope.NONEMPTY_OBJECT: result.append ( '.' ) ; if ( pathNames[i] != null ) { result.append ( pathNames[i] ) ; } break ; case JsonScope.NONEMPTY_DOCUMENT: case JsonScope.EMPTY_DOCUMENT: case JsonScope.CLOSED: break ; } } return result.toString ( ) ; } 
private char readEscapeCharacter ( ) throws IOException { if ( pos == limit && !fillBuffer ( 1 ) ) { throw syntaxError ( " Unterminated escape sequence " ) ; } char escaped = buffer[pos++] ; switch ( escaped ) { case 'u': if ( pos + 4 > limit && !fillBuffer ( 4 ) ) { throw syntaxError ( " Unterminated escape sequence " ) ; } char result = 0 ; for ( int i = pos , end = i + 4 ; i < end ; i++ ) { char c = buffer[i] ; result < < = 4 ; if ( c > = '0' && c < = '9' ) { result += ( c - '0' ) ; } else if ( c > = 'a' && c < = 'f' ) { result += ( c - 'a' + 10 ) ; } else if ( c > = 'A' && c < = 'F' ) { result += ( c - 'A' + 10 ) ; } else { throw new NumberFormatException ( " \\u " + new String ( buffer , pos , 4 ) ) ; } } pos += 4 ; return result ; case 't': return '\t' ; case 'b': return '\b' ; case 'n': return '\n' ; case 'r': return '\r' ; case 'f': return '\f' ; case '\n': lineNumber++ ; lineStart = pos ; case '\'': case ' " ': case '\\': case '/': return escaped ; default: throw syntaxError ( " Invalid escape sequence " ) ; } } 
private void consumeNonExecutePrefix ( ) throws IOException { nextNonWhitespace ( true ) ; pos-- ; if ( pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer ( NON_EXECUTE_PREFIX.length ) ) { return ; } for ( int i = 0 ; i < NON_EXECUTE_PREFIX.length ; i++ ) { if ( buffer[pos + i] != NON_EXECUTE_PREFIX[i] ) { return ; } } pos += NON_EXECUTE_PREFIX.length ; } 
public void promoteNameToValue ( JsonReader reader ) throws IOException { if ( reader instanceof JsonTreeReader ) { ( ( JsonTreeReader ) reader ) .promoteNameToValue ( ) ; return ; } int p = reader.peeked ; if ( p == PEEKED_NONE ) { p = reader.doPeek ( ) ; } if ( p == PEEKED_DOUBLE_QUOTED_NAME ) { reader.peeked = PEEKED_DOUBLE_QUOTED ; } else if ( p == PEEKED_SINGLE_QUOTED_NAME ) { reader.peeked = PEEKED_SINGLE_QUOTED ; } else if ( p == PEEKED_UNQUOTED_NAME ) { reader.peeked = PEEKED_UNQUOTED ; } else { throw new IllegalStateException ( " Expected a name but was " + reader.peek ( ) + reader.locationString ( ) ) ; } } 
private void string ( String value ) throws IOException { String[] replacements = htmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS ; out.write ( " \ " " ) ; int last = 0 ; int length = value.length ( ) ; for ( int i = 0 ; i < length ; i++ ) { char c = value.charAt ( i ) ; String replacement ; if ( c < 128 ) { replacement = replacements[c] ; if ( replacement == null ) { continue ; } } else if ( c == '\u2028' ) { replacement = " \\u2028 " ; } else if ( c == '\u2029' ) { replacement = " \\u2029 " ; } else { continue ; } if ( last < i ) { out.write ( value , last , i - last ) ; } out.write ( replacement ) ; last = i + 1 ; } if ( last < length ) { out.write ( value , last , length - last ) ; } out.write ( " \ " " ) ; } 
private void beforeValue ( ) throws IOException { switch ( peek ( ) ) { case NONEMPTY_DOCUMENT: if ( !lenient ) { throw new IllegalStateException ( " JSON must have only one top-level value. " ) ; } case EMPTY_DOCUMENT: replaceTop ( NONEMPTY_DOCUMENT ) ; break ; case EMPTY_ARRAY: replaceTop ( NONEMPTY_ARRAY ) ; newline ( ) ; break ; case NONEMPTY_ARRAY: out.append ( ' , ' ) ; newline ( ) ; break ; case DANGLING_NAME: out.append ( separator ) ; replaceTop ( NONEMPTY_OBJECT ) ; break ; default: throw new IllegalStateException ( " Nesting problem. " ) ; } } 
public final TypeAdapter < T > nullSafe ( ) { return new TypeAdapter < T > ( ) { @Override public void write ( JsonWriter out , T value ) throws IOException { if ( value == null ) { out.nullValue ( ) ; } else { TypeAdapter.this.write ( out , value ) ; } } @Override public T read ( JsonReader reader ) throws IOException { if ( reader.peek ( ) == JsonToken.NULL ) { reader.nextNull ( ) ; return null ; } return TypeAdapter.this.read ( reader ) ; } } ; } 
public T get ( ) { throw new IllegalStateException ( " Optional.get ( ) cannot be called on an absent value " ) ; } 
public T orNull ( ) { return null ; }
public Double read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } return in.nextDouble ( ) ; }
public Float read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } return ( float ) in.nextDouble ( ) ; }
public Number read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } return in.nextLong ( ) ; }
public < T > T fromJson ( String json , Type typeOfT ) throws JsonSyntaxException { if ( json == null ) { return null ; } StringReader reader = new StringReader ( json ) ; T target = ( T ) fromJson ( reader , typeOfT ) ; return target ; }
public < T > T fromJson ( JsonElement json , Type typeOfT ) throws JsonSyntaxException { if ( json == null ) { return null ; } return ( T ) fromJson ( new JsonTreeReader ( json ) , typeOfT ) ; }
public Collection < E > read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } Collection < E > collection = constructor.construct ( ) ; in.beginArray ( ) ; while ( in.hasNext ( ) ) { E instance = elementTypeAdapter.read ( in ) ; collection.add ( instance ) ; } in.endArray ( ) ; return collection ; }
public Date read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } return deserializeToDate ( in.nextString ( ) ) ; }
public JsonWriter value ( String value ) throws IOException { if ( value == null ) { return nullValue ( ) ; } put ( new JsonPrimitive ( value ) ) ; return this ; }
public JsonWriter value ( Boolean value ) throws IOException { if ( value == null ) { return nullValue ( ) ; } put ( new JsonPrimitive ( value ) ) ; return this ; }
public JsonWriter value ( Number value ) throws IOException { if ( value == null ) { return nullValue ( ) ; } if ( !isLenient ( ) ) { double d = value.doubleValue ( ) ; if ( Double.isNaN ( d ) || Double.isInfinite ( d ) ) { throw new IllegalArgumentException ( " JSON forbids NaN and infinities: " + value ) ; } } put ( new JsonPrimitive ( value ) ) ; return this ; }
public synchronized java.sql.Date read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } try { final long utilDate = format.parse ( in.nextString ( ) ) .getTime ( ) ; return new java.sql.Date ( utilDate ) ; } catch ( ParseException e ) { throw new JsonSyntaxException ( e ) ; } }
public synchronized Time read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } try { Date date = format.parse ( in.nextString ( ) ) ; return new Time ( date.getTime ( ) ) ; } catch ( ParseException e ) { throw new JsonSyntaxException ( e ) ; } }
public Boolean read ( JsonReader in ) throws IOException { JsonToken peek = in.peek ( ) ; if ( peek == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } else if ( peek == JsonToken.STRING ) { return Boolean.parseBoolean ( in.nextString ( ) ) ; } return in.nextBoolean ( ) ; }
public Boolean read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } return Boolean.valueOf ( in.nextString ( ) ) ; }
public Number read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } try { int intValue = in.nextInt ( ) ; return ( byte ) intValue ; } catch ( NumberFormatException e ) { throw new JsonSyntaxException ( e ) ; } }
public Number read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } try { return ( short ) in.nextInt ( ) ; } catch ( NumberFormatException e ) { throw new JsonSyntaxException ( e ) ; } }
public Number read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } try { return in.nextInt ( ) ; } catch ( NumberFormatException e ) { throw new JsonSyntaxException ( e ) ; } }
public Number read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } try { return in.nextLong ( ) ; } catch ( NumberFormatException e ) { throw new JsonSyntaxException ( e ) ; } }
public Number read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } return ( float ) in.nextDouble ( ) ; }
public Number read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } return in.nextDouble ( ) ; }
public Character read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } String str = in.nextString ( ) ; if ( str.length ( ) != 1 ) { throw new JsonSyntaxException ( " Expecting character , got: " + str ) ; } return str.charAt ( 0 ) ; }
public String read ( JsonReader in ) throws IOException { JsonToken peek = in.peek ( ) ; if ( peek == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } if ( peek == JsonToken.BOOLEAN ) { return Boolean.toString ( in.nextBoolean ( ) ) ; } return in.nextString ( ) ; }
public BigDecimal read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } try { return new BigDecimal ( in.nextString ( ) ) ; } catch ( NumberFormatException e ) { throw new JsonSyntaxException ( e ) ; } }
public BigInteger read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } try { return new BigInteger ( in.nextString ( ) ) ; } catch ( NumberFormatException e ) { throw new JsonSyntaxException ( e ) ; } }
public StringBuilder read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } return new StringBuilder ( in.nextString ( ) ) ; }
public StringBuffer read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } return new StringBuffer ( in.nextString ( ) ) ; }
public URL read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } String nextString = in.nextString ( ) ; return " null " .equals ( nextString ) ? null : new URL ( nextString ) ; }
public URI read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } try { String nextString = in.nextString ( ) ; return " null " .equals ( nextString ) ? null : new URI ( nextString ) ; } catch ( URISyntaxException e ) { throw new JsonIOException ( e ) ; } }
public InetAddress read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } return InetAddress.getByName ( in.nextString ( ) ) ; }
public UUID read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } return java.util.UUID.fromString ( in.nextString ( ) ) ; }
public T read ( JsonReader in ) throws IOException { if ( in.peek ( ) == JsonToken.NULL ) { in.nextNull ( ) ; return null ; } return nameToConstant.get ( in.nextString ( ) ) ; }
public T read ( JsonReader in ) throws IOException { if ( skipDeserialize ) { in.skipValue ( ) ; return null ; } return delegate ( ) .read ( in ) ; }
Node < K , V > findByObject ( Object key ) { try { return key != null ? find ( ( K ) key , false ) : null ; } catch ( ClassCastException e ) { return null ; } }
private static Field getOverrideField ( ) { try { return AccessibleObject.class.getDeclaredField ( " override " ) ; } catch ( NoSuchFieldException e ) { return null ; } }
public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > typeToken ) { Type type = typeToken.getType ( ) ; if ( ! ( type instanceof GenericArrayType || type instanceof Class && ( ( Class < ? > ) type ) .isArray ( ) ) ) { return null ; } Type componentType = $Gson$Types.getArrayComponentType ( type ) ; TypeAdapter < ? > componentTypeAdapter = gson.getAdapter ( TypeToken.get ( componentType ) ) ; return new ArrayTypeAdapter ( gson , componentTypeAdapter , $Gson$Types.getRawType ( componentType ) ) ; }
public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > typeToken ) { Type type = typeToken.getType ( ) ; Class < ? super T > rawType = typeToken.getRawType ( ) ; if ( !Collection.class.isAssignableFrom ( rawType ) ) { return null ; } Type elementType = $Gson$Types.getCollectionElementType ( type , rawType ) ; TypeAdapter < ? > elementTypeAdapter = gson.getAdapter ( TypeToken.get ( elementType ) ) ; ObjectConstructor < T > constructor = constructorConstructor.get ( typeToken ) ; @SuppressWarnings ( { " unchecked " , " rawtypes " } ) TypeAdapter < T > result = new Adapter ( gson , elementType , elementTypeAdapter , constructor ) ; return result ; }
public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > targetType ) { Class < ? super T > rawType = targetType.getRawType ( ) ; JsonAdapter annotation = rawType.getAnnotation ( JsonAdapter.class ) ; if ( annotation == null ) { return null ; } return ( TypeAdapter < T > ) getTypeAdapter ( constructorConstructor , gson , targetType , annotation ) ; }
public < T > TypeAdapter < T > create ( Gson gson , final TypeToken < T > type ) { Class < ? super T > raw = type.getRawType ( ) ; if ( !Object.class.isAssignableFrom ( raw ) ) { return null ; } ObjectConstructor < T > constructor = constructorConstructor.get ( type ) ; return new Adapter < T > ( constructor , getBoundFields ( gson , type , raw ) ) ; }
public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > type ) { if ( type.getRawType ( ) == Object.class ) { return ( TypeAdapter < T > ) new ObjectTypeAdapter ( gson ) ; } return null ; }
public T read ( JsonReader in ) throws IOException { if ( deserializer == null ) { return delegate ( ) .read ( in ) ; } JsonElement value = Streams.parse ( in ) ; if ( value.isJsonNull ( ) ) { return null ; } return deserializer.deserialize ( value , typeToken.getType ( ) , context ) ; }
public < T > TypeAdapter < T > create ( Gson gson , TypeToken < T > typeToken ) { Class < ? super T > rawType = typeToken.getRawType ( ) ; if ( !Enum.class.isAssignableFrom ( rawType ) || rawType == Enum.class ) { return null ; } if ( !rawType.isEnum ( ) ) { rawType = rawType.getSuperclass ( ) ; } return ( TypeAdapter < T > ) new EnumTypeAdapter ( rawType ) ; }
private static Object getUnsafeInstance ( ) { try { unsafeClass = Class.forName ( " sun.misc.Unsafe " ) ; Field unsafeField = unsafeClass.getDeclaredField ( " theUnsafe " ) ; unsafeField.setAccessible ( true ) ; return unsafeField.get ( null ) ; } catch ( Exception e ) { return null ; } }
public JsonWriter jsonValue ( String value ) throws IOException { if ( value == null ) { return nullValue ( ) ; } writeDeferredName ( ) ; beforeValue ( ) ; out.append ( value ) ; return this ; }
public JsonWriter value ( String value ) throws IOException { if ( value == null ) { return nullValue ( ) ; } writeDeferredName ( ) ; beforeValue ( ) ; string ( value ) ; return this ; }
public JsonWriter value ( Boolean value ) throws IOException { if ( value == null ) { return nullValue ( ) ; } writeDeferredName ( ) ; beforeValue ( ) ; out.write ( value ? " true " : " false " ) ; return this ; }
public JsonWriter value ( Number value ) throws IOException { if ( value == null ) { return nullValue ( ) ; } writeDeferredName ( ) ; String string = value.toString ( ) ; if ( !lenient && ( string.equals ( " -Infinity " ) || string.equals ( " Infinity " ) || string.equals ( " NaN " ) ) ) { throw new IllegalArgumentException ( " Numeric values must be finite , but was " + value ) ; } beforeValue ( ) ; out.append ( string ) ; return this ; }
public T read ( JsonReader reader ) throws IOException { if ( reader.peek ( ) == JsonToken.NULL ) { reader.nextNull ( ) ; return null ; } return TypeAdapter.this.read ( reader ) ; }
public final boolean hasNext ( ) { checkState ( state != State.FAILED ) ; switch ( state ) { case READY: return true ; case DONE: return false ; default: } return tryToComputeNext ( ) ; } 
public final void remove ( ) { throw new UnsupportedOperationException ( ) ; } 
public static String toLowerCase ( String string ) { int length = string.length ( ) ; for ( int i = 0 ; i < length ; i++ ) { if ( isUpperCase ( string.charAt ( i ) ) ) { char[] chars = string.toCharArray ( ) ; for ( ; i < length ; i++ ) { char c = chars[i] ; if ( isUpperCase ( c ) ) { chars[i] = ( char ) ( c ^ CASE_MASK ) ; } } return String.valueOf ( chars ) ; } } return string ; } 
public static String toUpperCase ( String string ) { int length = string.length ( ) ; for ( int i = 0 ; i < length ; i++ ) { if ( isLowerCase ( string.charAt ( i ) ) ) { char[] chars = string.toCharArray ( ) ; for ( ; i < length ; i++ ) { char c = chars[i] ; if ( isLowerCase ( c ) ) { chars[i] = ( char ) ( c ^ CASE_MASK ) ; } } return String.valueOf ( chars ) ; } } return string ; } 
public static boolean equalsIgnoreCase ( CharSequence s1 , CharSequence s2 ) { int length = s1.length ( ) ; if ( s1 == s2 ) { return true ; } if ( length != s2.length ( ) ) { return false ; } for ( int i = 0 ; i < length ; i++ ) { char c1 = s1.charAt ( i ) ; char c2 = s2.charAt ( i ) ; if ( c1 == c2 ) { continue ; } int alphaIndex = getAlphaIndex ( c1 ) ; if ( alphaIndex < 26 && alphaIndex == getAlphaIndex ( c2 ) ) { continue ; } return false ; } return true ; } 
String convert ( CaseFormat format , String s ) { StringBuilder out = null ; int i = 0 ; int j = -1 ; while ( ( j = wordBoundary.indexIn ( s , ++j ) ) != -1 ) { if ( i == 0 ) { out = new StringBuilder ( s.length ( ) + 4 * wordSeparator.length ( ) ) ; out.append ( format.normalizeFirstWord ( s.substring ( i , j ) ) ) ; } else { out.append ( format.normalizeWord ( s.substring ( i , j ) ) ) ; } out.append ( format.wordSeparator ) ; i = j + wordSeparator.length ( ) ; } return ( i == 0 ) ? format.normalizeFirstWord ( s ) : out.append ( format.normalizeWord ( s.substring ( i ) ) ) .toString ( ) ; } 
public static CharMatcher anyOf ( final CharSequence sequence ) { switch ( sequence.length ( ) ) { case 0: return none ( ) ; case 1: return is ( sequence.charAt ( 0 ) ) ; case 2: return isEither ( sequence.charAt ( 0 ) , sequence.charAt ( 1 ) ) ; default: return new AnyOf ( sequence ) ; } } 
CharMatcher precomputedInternal ( ) { final BitSet table = new BitSet ( ) ; setBits ( table ) ; int totalCharacters = table.cardinality ( ) ; if ( totalCharacters * 2 < = DISTINCT_CHARS ) { return precomputedPositive ( totalCharacters , table , toString ( ) ) ; } else { table.flip ( Character.MIN_VALUE , Character.MAX_VALUE + 1 ) ; int negatedCharacters = DISTINCT_CHARS - totalCharacters ; String suffix = " .negate ( ) " ; final String description = toString ( ) ; String negatedDescription = description.endsWith ( suffix ) ? description.substring ( 0 , description.length ( ) - suffix.length ( ) ) : description + suffix ; return new NegatedFastMatcher ( precomputedPositive ( negatedCharacters , table , negatedDescription ) ) { @Override public String toString ( ) { return description ; } } ; } } 
private static CharMatcher precomputedPositive ( int totalCharacters , BitSet table , String description ) { switch ( totalCharacters ) { case 0: return none ( ) ; case 1: return is ( ( char ) table.nextSetBit ( 0 ) ) ; case 2: char c1 = ( char ) table.nextSetBit ( 0 ) ; char c2 = ( char ) table.nextSetBit ( c1 + 1 ) ; return isEither ( c1 , c2 ) ; default: return isSmall ( totalCharacters , table.length ( ) ) ? SmallCharMatcher.from ( table , description ) : new BitSetMatcher ( table , description ) ; } } 
public String removeFrom ( CharSequence sequence ) { String string = sequence.toString ( ) ; int pos = indexIn ( string ) ; if ( pos == -1 ) { return string ; } char[] chars = string.toCharArray ( ) ; int spread = 1 ; OUT: while ( true ) { pos++ ; while ( true ) { if ( pos == chars.length ) { break OUT ; } if ( matches ( chars[pos] ) ) { break ; } chars[pos - spread] = chars[pos] ; pos++ ; } spread++ ; } return new String ( chars , 0 , pos - spread ) ; } 
public String replaceFrom ( CharSequence sequence , CharSequence replacement ) { int replacementLen = replacement.length ( ) ; if ( replacementLen == 0 ) { return removeFrom ( sequence ) ; } if ( replacementLen == 1 ) { return replaceFrom ( sequence , replacement.charAt ( 0 ) ) ; } String string = sequence.toString ( ) ; int pos = indexIn ( string ) ; if ( pos == -1 ) { return string ; } int len = string.length ( ) ; StringBuilder buf = new StringBuilder ( ( len * 3 / 2 ) + 16 ) ; int oldpos = 0 ; do { buf.append ( string , oldpos , pos ) ; buf.append ( replacement ) ; oldpos = pos + 1 ; pos = indexIn ( string , oldpos ) ; } while ( pos != -1 ) ; buf.append ( string , oldpos , len ) ; return buf.toString ( ) ; } 
public String trimFrom ( CharSequence sequence ) { int len = sequence.length ( ) ; int first ; int last ; for ( first = 0 ; first < len ; first++ ) { if ( !matches ( sequence.charAt ( first ) ) ) { break ; } } for ( last = len - 1 ; last > first ; last-- ) { if ( !matches ( sequence.charAt ( last ) ) ) { break ; } } return sequence.subSequence ( first , last + 1 ) .toString ( ) ; } 
public String collapseFrom ( CharSequence sequence , char replacement ) { int len = sequence.length ( ) ; for ( int i = 0 ; i < len ; i++ ) { char c = sequence.charAt ( i ) ; if ( matches ( c ) ) { if ( c == replacement && ( i == len - 1 || !matches ( sequence.charAt ( i + 1 ) ) ) ) { i++ ; } else { StringBuilder builder = new StringBuilder ( len ) .append ( sequence , 0 , i ) .append ( replacement ) ; return finishCollapseFrom ( sequence , i + 1 , len , replacement , builder , true ) ; } } } return sequence.toString ( ) ; } 
public String trimAndCollapseFrom ( CharSequence sequence , char replacement ) { int len = sequence.length ( ) ; int first = 0 ; int last = len - 1 ; while ( first < len && matches ( sequence.charAt ( first ) ) ) { first++ ; } while ( last > first && matches ( sequence.charAt ( last ) ) ) { last-- ; } return ( first == 0 && last == len - 1 ) ? collapseFrom ( sequence , replacement ) : finishCollapseFrom ( sequence , first , last + 1 , replacement , new StringBuilder ( last + 1 - first ) , false ) ; } 
private String finishCollapseFrom ( CharSequence sequence , int start , int end , char replacement , StringBuilder builder , boolean inMatchingGroup ) { for ( int i = start ; i < end ; i++ ) { char c = sequence.charAt ( i ) ; if ( matches ( c ) ) { if ( !inMatchingGroup ) { builder.append ( replacement ) ; inMatchingGroup = true ; } } else { builder.append ( c ) ; inMatchingGroup = false ; } } return builder.toString ( ) ; } 
public boolean matches ( char c ) { switch ( c ) { case '\t': case '\n': case '\013': case '\f': case '\r': case ' ': case '\u0085': case '\u1680': case '\u2028': case '\u2029': case '\u205f': case '\u3000': return true ; case '\u2007': return false ; default: return c > = '\u2000' && c < = '\u200a' ; } } 
public Iterable < B > convertAll ( final Iterable < ? extends A > fromIterable ) { checkNotNull ( fromIterable , " fromIterable " ) ; return new Iterable < B > ( ) { @Override public Iterator < B > iterator ( ) { return new Iterator < B > ( ) { private final Iterator < ? extends A > fromIterator = fromIterable.iterator ( ) ; @Override public boolean hasNext ( ) { return fromIterator.hasNext ( ) ; } @Override public B next ( ) { return convert ( fromIterator.next ( ) ) ; } @Override public void remove ( ) { fromIterator.remove ( ) ; } } ; } } ; } 
public Iterator < B > iterator ( ) { return new Iterator < B > ( ) { private final Iterator < ? extends A > fromIterator = fromIterable.iterator ( ) ; @Override public boolean hasNext ( ) { return fromIterator.hasNext ( ) ; } @Override public B next ( ) { return convert ( fromIterator.next ( ) ) ; } @Override public void remove ( ) { fromIterator.remove ( ) ; } } ; } 
public static < T > T defaultValue ( Class < T > type ) { checkNotNull ( type ) ; if ( type == boolean.class ) { return ( T ) Boolean.FALSE ; } else if ( type == char.class ) { return ( T ) Character.valueOf ( '\0' ) ; } else if ( type == byte.class ) { return ( T ) Byte.valueOf ( ( byte ) 0 ) ; } else if ( type == short.class ) { return ( T ) Short.valueOf ( ( short ) 0 ) ; } else if ( type == int.class ) { return ( T ) Integer.valueOf ( 0 ) ; } else if ( type == long.class ) { return ( T ) Long.valueOf ( 0L ) ; } else if ( type == float.class ) { return ( T ) FLOAT_DEFAULT ; } else if ( type == double.class ) { return ( T ) DOUBLE_DEFAULT ; } else { return null ; } } 
void cleanUp ( ) { if ( threadStarted ) { return ; } Reference < ? > reference ; while ( ( reference = queue.poll ( ) ) != null ) { reference.clear ( ) ; try { ( ( FinalizableReference ) reference ) .finalizeReferent ( ) ; } catch ( Throwable t ) { logger.log ( Level.SEVERE , " Error cleaning up after reference. " , t ) ; } } } 
public Class < ? > loadFinalizer ( ) { if ( disabled ) { return null ; } ClassLoader systemLoader ; try { systemLoader = ClassLoader.getSystemClassLoader ( ) ; } catch ( SecurityException e ) { logger.info ( " Not allowed to access system class loader. " ) ; return null ; } if ( systemLoader != null ) { try { return systemLoader.loadClass ( FINALIZER_CLASS_NAME ) ; } catch ( ClassNotFoundException e ) { return null ; } } else { return null ; } } 
URL getBaseUrl ( ) throws IOException { String finalizerPath = FINALIZER_CLASS_NAME.replace ( '.' , '/' ) + " .class " ; URL finalizerUrl = getClass ( ) .getClassLoader ( ) .getResource ( finalizerPath ) ; if ( finalizerUrl == null ) { throw new FileNotFoundException ( finalizerPath ) ; } String urlString = finalizerUrl.toString ( ) ; if ( !urlString.endsWith ( finalizerPath ) ) { throw new IOException ( " Unsupported path style: " + urlString ) ; } urlString = urlString.substring ( 0 , urlString.length ( ) - finalizerPath.length ( ) ) ; return new URL ( finalizerUrl , urlString ) ; } 
public static void startFinalizer ( Class < ? > finalizableReferenceClass , ReferenceQueue < Object > queue , PhantomReference < Object > frqReference ) { if ( !finalizableReferenceClass.getName ( ) .equals ( FINALIZABLE_REFERENCE ) ) { throw new IllegalArgumentException ( " Expected " + FINALIZABLE_REFERENCE + " . " ) ; } Finalizer finalizer = new Finalizer ( finalizableReferenceClass , queue , frqReference ) ; String threadName = Finalizer.class.getName ( ) ; Thread thread = null ; if ( bigThreadConstructor != null ) { try { boolean inheritThreadLocals = false ; long defaultStackSize = 0 ; thread = bigThreadConstructor.newInstance ( ( ThreadGroup ) null , finalizer , threadName , defaultStackSize , inheritThreadLocals ) ; } catch ( Throwable t ) { logger.log ( Level.INFO , " Failed to create a thread without inherited thread-local values " , t ) ; } } if ( thread == null ) { thread = new Thread ( ( ThreadGroup ) null , finalizer , threadName ) ; } thread.setDaemon ( true ) ; try { if ( inheritableThreadLocals != null ) { inheritableThreadLocals.set ( thread , null ) ; } } catch ( Throwable t ) { logger.log ( Level.INFO , " Failed to clear thread local values inherited by reference finalizer thread. " , t ) ; } thread.start ( ) ; } 
private boolean cleanUp ( Reference < ? > reference ) { Method finalizeReferentMethod = getFinalizeReferentMethod ( ) ; if ( finalizeReferentMethod == null ) { return false ; } do { reference.clear ( ) ; if ( reference == frqReference ) { return false ; } try { finalizeReferentMethod.invoke ( reference ) ; } catch ( Throwable t ) { logger.log ( Level.SEVERE , " Error cleaning up after reference. " , t ) ; } } while ( ( reference = queue.poll ( ) ) != null ) ; return true ; } 
public final < A extends Appendable > A appendTo ( A appendable , @Nullable Object first , @Nullable Object second , Object... rest ) throws IOException { return appendTo ( appendable , iterable ( first , second , rest ) ) ; } 
public final StringBuilder appendTo ( StringBuilder builder , @Nullable Object first , @Nullable Object second , Object... rest ) { return appendTo ( builder , iterable ( first , second , rest ) ) ; } 
public final String join ( @Nullable Object first , @Nullable Object second , Object... rest ) { return join ( iterable ( first , second , rest ) ) ; } 
public Joiner useForNull ( final String nullText ) { checkNotNull ( nullText ) ; return new Joiner ( this ) { @Override CharSequence toString ( @Nullable Object part ) { return ( part == null ) ? nullText : Joiner.this.toString ( part ) ; } @Override public Joiner useForNull ( String nullText ) { throw new UnsupportedOperationException ( " already specified useForNull " ) ; } @Override public Joiner skipNulls ( ) { throw new UnsupportedOperationException ( " already specified useForNull " ) ; } } ; } 
public Joiner skipNulls ( ) { return new Joiner ( this ) { @Override public < A extends Appendable > A appendTo ( A appendable , Iterator < ? > parts ) throws IOException { checkNotNull ( appendable , " appendable " ) ; checkNotNull ( parts , " parts " ) ; while ( parts.hasNext ( ) ) { Object part = parts.next ( ) ; if ( part != null ) { appendable.append ( Joiner.this.toString ( part ) ) ; break ; } } while ( parts.hasNext ( ) ) { Object part = parts.next ( ) ; if ( part != null ) { appendable.append ( separator ) ; appendable.append ( Joiner.this.toString ( part ) ) ; } } return appendable ; } @Override public Joiner useForNull ( String nullText ) { throw new UnsupportedOperationException ( " already specified skipNulls " ) ; } @Override public MapJoiner withKeyValueSeparator ( String kvs ) { throw new UnsupportedOperationException ( " can't use .skipNulls ( ) with maps " ) ; } } ; } 
public < A extends Appendable > A appendTo ( A appendable , Iterator < ? > parts ) throws IOException { checkNotNull ( appendable , " appendable " ) ; checkNotNull ( parts , " parts " ) ; while ( parts.hasNext ( ) ) { Object part = parts.next ( ) ; if ( part != null ) { appendable.append ( Joiner.this.toString ( part ) ) ; break ; } } while ( parts.hasNext ( ) ) { Object part = parts.next ( ) ; if ( part != null ) { appendable.append ( separator ) ; appendable.append ( Joiner.this.toString ( part ) ) ; } } return appendable ; } 
public < A extends Appendable > A appendTo ( A appendable , Iterator < ? extends Entry < ? , ? > > parts ) throws IOException { checkNotNull ( appendable ) ; if ( parts.hasNext ( ) ) { Entry < ? , ? > entry = parts.next ( ) ; appendable.append ( joiner.toString ( entry.getKey ( ) ) ) ; appendable.append ( keyValueSeparator ) ; appendable.append ( joiner.toString ( entry.getValue ( ) ) ) ; while ( parts.hasNext ( ) ) { appendable.append ( joiner.separator ) ; Entry < ? , ? > e = parts.next ( ) ; appendable.append ( joiner.toString ( e.getKey ( ) ) ) ; appendable.append ( keyValueSeparator ) ; appendable.append ( joiner.toString ( e.getValue ( ) ) ) ; } } return appendable ; } 
private static Iterable < Object > iterable ( final Object first , final Object second , final Object[] rest ) { checkNotNull ( rest ) ; return new AbstractList < Object > ( ) { @Override public int size ( ) { return rest.length + 2 ; } @Override public Object get ( int index ) { switch ( index ) { case 0: return first ; case 1: return second ; default: return rest[index - 2] ; } } } ; } 
public Object get ( int index ) { switch ( index ) { case 0: return first ; case 1: return second ; default: return rest[index - 2] ; } } 
public String toString ( ) { boolean omitNullValuesSnapshot = omitNullValues ; String nextSeparator = " " ; StringBuilder builder = new StringBuilder ( 32 ) .append ( className ) .append ( ' { ' ) ; for ( ValueHolder valueHolder = holderHead.next ; valueHolder != null ; valueHolder = valueHolder.next ) { Object value = valueHolder.value ; if ( !omitNullValuesSnapshot || value != null ) { builder.append ( nextSeparator ) ; nextSeparator = " , " ; if ( valueHolder.name != null ) { builder.append ( valueHolder.name ) .append ( '=' ) ; } if ( value != null && value.getClass ( ) .isArray ( ) ) { Object[] objectArray = { value } ; String arrayString = Arrays.deepToString ( objectArray ) ; builder.append ( arrayString , 1 , arrayString.length ( ) - 1 ) ; } else { builder.append ( value ) ; } } } return builder.append ( ' } ' ) .toString ( ) ; } 
public static < T > Iterable < T > presentInstances ( final Iterable < ? extends Optional < ? extends T > > optionals ) { checkNotNull ( optionals ) ; return new Iterable < T > ( ) { @Override public Iterator < T > iterator ( ) { return new AbstractIterator < T > ( ) { private final Iterator < ? extends Optional < ? extends T > > iterator = checkNotNull ( optionals.iterator ( ) ) ; @Override protected T computeNext ( ) { while ( iterator.hasNext ( ) ) { Optional < ? extends T > optional = iterator.next ( ) ; if ( optional.isPresent ( ) ) { return optional.get ( ) ; } } return endOfData ( ) ; } } ; } } ; } 
public Iterator < T > iterator ( ) { return new AbstractIterator < T > ( ) { private final Iterator < ? extends Optional < ? extends T > > iterator = checkNotNull ( optionals.iterator ( ) ) ; @Override protected T computeNext ( ) { while ( iterator.hasNext ( ) ) { Optional < ? extends T > optional = iterator.next ( ) ; if ( optional.isPresent ( ) ) { return optional.get ( ) ; } } return endOfData ( ) ; } } ; } 
public static void checkArgument ( boolean b , @Nullable String errorMessageTemplate , char p1 , char p2 ) { if ( !b ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkArgument ( boolean b , @Nullable String errorMessageTemplate , char p1 , int p2 ) { if ( !b ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkArgument ( boolean b , @Nullable String errorMessageTemplate , char p1 , long p2 ) { if ( !b ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkArgument ( boolean b , @Nullable String errorMessageTemplate , char p1 , @Nullable Object p2 ) { if ( !b ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkArgument ( boolean b , @Nullable String errorMessageTemplate , int p1 , char p2 ) { if ( !b ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkArgument ( boolean b , @Nullable String errorMessageTemplate , int p1 , int p2 ) { if ( !b ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkArgument ( boolean b , @Nullable String errorMessageTemplate , int p1 , long p2 ) { if ( !b ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkArgument ( boolean b , @Nullable String errorMessageTemplate , int p1 , @Nullable Object p2 ) { if ( !b ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkArgument ( boolean b , @Nullable String errorMessageTemplate , long p1 , char p2 ) { if ( !b ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkArgument ( boolean b , @Nullable String errorMessageTemplate , long p1 , int p2 ) { if ( !b ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkArgument ( boolean b , @Nullable String errorMessageTemplate , long p1 , long p2 ) { if ( !b ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkArgument ( boolean b , @Nullable String errorMessageTemplate , long p1 , @Nullable Object p2 ) { if ( !b ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkArgument ( boolean b , @Nullable String errorMessageTemplate , @Nullable Object p1 , char p2 ) { if ( !b ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkArgument ( boolean b , @Nullable String errorMessageTemplate , @Nullable Object p1 , int p2 ) { if ( !b ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkArgument ( boolean b , @Nullable String errorMessageTemplate , @Nullable Object p1 , long p2 ) { if ( !b ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkArgument ( boolean b , @Nullable String errorMessageTemplate , @Nullable Object p1 , @Nullable Object p2 ) { if ( !b ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkArgument ( boolean b , @Nullable String errorMessageTemplate , @Nullable Object p1 , @Nullable Object p2 , @Nullable Object p3 ) { if ( !b ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 , p2 , p3 ) ) ; } } 
public static void checkArgument ( boolean b , @Nullable String errorMessageTemplate , @Nullable Object p1 , @Nullable Object p2 , @Nullable Object p3 , @Nullable Object p4 ) { if ( !b ) { throw new IllegalArgumentException ( lenientFormat ( errorMessageTemplate , p1 , p2 , p3 , p4 ) ) ; } } 
public static void checkState ( boolean expression , @Nullable String errorMessageTemplate , @Nullable Object@Nullable ... errorMessageArgs ) { if ( !expression ) { throw new IllegalStateException ( lenientFormat ( errorMessageTemplate , errorMessageArgs ) ) ; } } 
public static void checkState ( boolean b , @Nullable String errorMessageTemplate , char p1 ) { if ( !b ) { throw new IllegalStateException ( lenientFormat ( errorMessageTemplate , p1 ) ) ; } } 
public static void checkState ( boolean b , @Nullable String errorMessageTemplate , int p1 ) { if ( !b ) { throw new IllegalStateException ( lenientFormat ( errorMessageTemplate , p1 ) ) ; } } 
public static void checkState ( boolean b , @Nullable String errorMessageTemplate , long p1 ) { if ( !b ) { throw new IllegalStateException ( lenientFormat ( errorMessageTemplate , p1 ) ) ; } } 
public static void checkState ( boolean b , @Nullable String errorMessageTemplate , @Nullable Object p1 ) { if ( !b ) { throw new IllegalStateException ( lenientFormat ( errorMessageTemplate , p1 ) ) ; } } 
public static void checkState ( boolean b , @Nullable String errorMessageTemplate , char p1 , char p2 ) { if ( !b ) { throw new IllegalStateException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkState ( boolean b , @Nullable String errorMessageTemplate , char p1 , int p2 ) { if ( !b ) { throw new IllegalStateException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkState ( boolean b , @Nullable String errorMessageTemplate , char p1 , long p2 ) { if ( !b ) { throw new IllegalStateException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkState ( boolean b , @Nullable String errorMessageTemplate , char p1 , @Nullable Object p2 ) { if ( !b ) { throw new IllegalStateException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkState ( boolean b , @Nullable String errorMessageTemplate , int p1 , char p2 ) { if ( !b ) { throw new IllegalStateException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkState ( boolean b , @Nullable String errorMessageTemplate , int p1 , int p2 ) { if ( !b ) { throw new IllegalStateException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkState ( boolean b , @Nullable String errorMessageTemplate , int p1 , long p2 ) { if ( !b ) { throw new IllegalStateException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkState ( boolean b , @Nullable String errorMessageTemplate , int p1 , @Nullable Object p2 ) { if ( !b ) { throw new IllegalStateException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkState ( boolean b , @Nullable String errorMessageTemplate , long p1 , char p2 ) { if ( !b ) { throw new IllegalStateException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkState ( boolean b , @Nullable String errorMessageTemplate , long p1 , int p2 ) { if ( !b ) { throw new IllegalStateException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkState ( boolean b , @Nullable String errorMessageTemplate , long p1 , long p2 ) { if ( !b ) { throw new IllegalStateException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkState ( boolean b , @Nullable String errorMessageTemplate , long p1 , @Nullable Object p2 ) { if ( !b ) { throw new IllegalStateException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkState ( boolean b , @Nullable String errorMessageTemplate , @Nullable Object p1 , char p2 ) { if ( !b ) { throw new IllegalStateException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkState ( boolean b , @Nullable String errorMessageTemplate , @Nullable Object p1 , int p2 ) { if ( !b ) { throw new IllegalStateException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkState ( boolean b , @Nullable String errorMessageTemplate , @Nullable Object p1 , long p2 ) { if ( !b ) { throw new IllegalStateException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkState ( boolean b , @Nullable String errorMessageTemplate , @Nullable Object p1 , @Nullable Object p2 ) { if ( !b ) { throw new IllegalStateException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void checkState ( boolean b , @Nullable String errorMessageTemplate , @Nullable Object p1 , @Nullable Object p2 , @Nullable Object p3 ) { if ( !b ) { throw new IllegalStateException ( lenientFormat ( errorMessageTemplate , p1 , p2 , p3 ) ) ; } } 
public static void checkState ( boolean b , @Nullable String errorMessageTemplate , @Nullable Object p1 , @Nullable Object p2 , @Nullable Object p3 , @Nullable Object p4 ) { if ( !b ) { throw new IllegalStateException ( lenientFormat ( errorMessageTemplate , p1 , p2 , p3 , p4 ) ) ; } } 
public static < T extends @NonNull Object > T checkNotNull ( T reference , @Nullable String errorMessageTemplate , @Nullable Object@Nullable ... errorMessageArgs ) { if ( reference == null ) { throw new NullPointerException ( lenientFormat ( errorMessageTemplate , errorMessageArgs ) ) ; } return reference ; } 
public static < T extends @NonNull Object > T checkNotNull ( T obj , @Nullable String errorMessageTemplate , char p1 ) { if ( obj == null ) { throw new NullPointerException ( lenientFormat ( errorMessageTemplate , p1 ) ) ; } return obj ; } 
public static < T extends @NonNull Object > T checkNotNull ( T obj , @Nullable String errorMessageTemplate , int p1 ) { if ( obj == null ) { throw new NullPointerException ( lenientFormat ( errorMessageTemplate , p1 ) ) ; } return obj ; } 
public static < T extends @NonNull Object > T checkNotNull ( T obj , @Nullable String errorMessageTemplate , long p1 ) { if ( obj == null ) { throw new NullPointerException ( lenientFormat ( errorMessageTemplate , p1 ) ) ; } return obj ; } 
public static < T extends @NonNull Object > T checkNotNull ( T obj , @Nullable String errorMessageTemplate , @Nullable Object p1 ) { if ( obj == null ) { throw new NullPointerException ( lenientFormat ( errorMessageTemplate , p1 ) ) ; } return obj ; } 
public static < T extends @NonNull Object > T checkNotNull ( T obj , @Nullable String errorMessageTemplate , char p1 , char p2 ) { if ( obj == null ) { throw new NullPointerException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } return obj ; } 
public static < T extends @NonNull Object > T checkNotNull ( T obj , @Nullable String errorMessageTemplate , char p1 , int p2 ) { if ( obj == null ) { throw new NullPointerException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } return obj ; } 
public static < T extends @NonNull Object > T checkNotNull ( T obj , @Nullable String errorMessageTemplate , char p1 , long p2 ) { if ( obj == null ) { throw new NullPointerException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } return obj ; } 
public static < T extends @NonNull Object > T checkNotNull ( T obj , @Nullable String errorMessageTemplate , char p1 , @Nullable Object p2 ) { if ( obj == null ) { throw new NullPointerException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } return obj ; } 
public static < T extends @NonNull Object > T checkNotNull ( T obj , @Nullable String errorMessageTemplate , int p1 , char p2 ) { if ( obj == null ) { throw new NullPointerException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } return obj ; } 
public static < T extends @NonNull Object > T checkNotNull ( T obj , @Nullable String errorMessageTemplate , int p1 , int p2 ) { if ( obj == null ) { throw new NullPointerException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } return obj ; } 
public static < T extends @NonNull Object > T checkNotNull ( T obj , @Nullable String errorMessageTemplate , int p1 , long p2 ) { if ( obj == null ) { throw new NullPointerException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } return obj ; } 
public static < T extends @NonNull Object > T checkNotNull ( T obj , @Nullable String errorMessageTemplate , int p1 , @Nullable Object p2 ) { if ( obj == null ) { throw new NullPointerException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } return obj ; } 
public static < T extends @NonNull Object > T checkNotNull ( T obj , @Nullable String errorMessageTemplate , long p1 , char p2 ) { if ( obj == null ) { throw new NullPointerException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } return obj ; } 
public static < T extends @NonNull Object > T checkNotNull ( T obj , @Nullable String errorMessageTemplate , long p1 , int p2 ) { if ( obj == null ) { throw new NullPointerException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } return obj ; } 
public static < T extends @NonNull Object > T checkNotNull ( T obj , @Nullable String errorMessageTemplate , long p1 , long p2 ) { if ( obj == null ) { throw new NullPointerException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } return obj ; } 
public static < T extends @NonNull Object > T checkNotNull ( T obj , @Nullable String errorMessageTemplate , long p1 , @Nullable Object p2 ) { if ( obj == null ) { throw new NullPointerException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } return obj ; } 
public static < T extends @NonNull Object > T checkNotNull ( T obj , @Nullable String errorMessageTemplate , @Nullable Object p1 , char p2 ) { if ( obj == null ) { throw new NullPointerException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } return obj ; } 
public static < T extends @NonNull Object > T checkNotNull ( T obj , @Nullable String errorMessageTemplate , @Nullable Object p1 , int p2 ) { if ( obj == null ) { throw new NullPointerException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } return obj ; } 
public static < T extends @NonNull Object > T checkNotNull ( T obj , @Nullable String errorMessageTemplate , @Nullable Object p1 , long p2 ) { if ( obj == null ) { throw new NullPointerException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } return obj ; } 
public static < T extends @NonNull Object > T checkNotNull ( T obj , @Nullable String errorMessageTemplate , @Nullable Object p1 , @Nullable Object p2 ) { if ( obj == null ) { throw new NullPointerException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } return obj ; } 
public static < T extends @NonNull Object > T checkNotNull ( T obj , @Nullable String errorMessageTemplate , @Nullable Object p1 , @Nullable Object p2 , @Nullable Object p3 ) { if ( obj == null ) { throw new NullPointerException ( lenientFormat ( errorMessageTemplate , p1 , p2 , p3 ) ) ; } return obj ; } 
public static < T extends @NonNull Object > T checkNotNull ( T obj , @Nullable String errorMessageTemplate , @Nullable Object p1 , @Nullable Object p2 , @Nullable Object p3 , @Nullable Object p4 ) { if ( obj == null ) { throw new NullPointerException ( lenientFormat ( errorMessageTemplate , p1 , p2 , p3 , p4 ) ) ; } return obj ; } 
private static String badElementIndex ( int index , int size , @Nullable String desc ) { if ( index < 0 ) { return lenientFormat ( " %s ( %s ) must not be negative " , desc , index ) ; } else if ( size < 0 ) { throw new IllegalArgumentException ( " negative size: " + size ) ; } else { return lenientFormat ( " %s ( %s ) must be less than size ( %s ) " , desc , index , size ) ; } } 
private static String badPositionIndex ( int index , int size , @Nullable String desc ) { if ( index < 0 ) { return lenientFormat ( " %s ( %s ) must not be negative " , desc , index ) ; } else if ( size < 0 ) { throw new IllegalArgumentException ( " negative size: " + size ) ; } else { return lenientFormat ( " %s ( %s ) must not be greater than size ( %s ) " , desc , index , size ) ; } } 
private static String badPositionIndexes ( int start , int end , int size ) { if ( start < 0 || start > size ) { return badPositionIndex ( start , size , " start index " ) ; } if ( end < 0 || end > size ) { return badPositionIndex ( end , size , " end index " ) ; } return lenientFormat ( " end index ( %s ) must not be less than start index ( %s ) " , end , start ) ; } 
static CharMatcher from ( BitSet chars , String description ) { long filter = 0 ; int size = chars.cardinality ( ) ; boolean containsZero = chars.get ( 0 ) ; char[] table = new char[chooseTableSize ( size ) ] ; int mask = table.length - 1 ; for ( int c = chars.nextSetBit ( 0 ) ; c != -1 ; c = chars.nextSetBit ( c + 1 ) ) { filter |= 1L < < c ; int index = smear ( c ) & mask ; while ( true ) { if ( table[index] == 0 ) { table[index] = ( char ) c ; break ; } index = ( index + 1 ) & mask ; } } return new SmallCharMatcher ( table , filter , containsZero , description ) ; } 
public boolean matches ( char c ) { if ( c == 0 ) { return containsZero ; } if ( !checkFilter ( c ) ) { return false ; } int mask = table.length - 1 ; int startingIndex = smear ( c ) & mask ; int index = startingIndex ; do { if ( table[index] == 0 ) { return false ; } else if ( table[index] == c ) { return true ; } else { index = ( index + 1 ) & mask ; } } while ( index != startingIndex ) ; return false ; } 
public static Splitter on ( final CharMatcher separatorMatcher ) { checkNotNull ( separatorMatcher ) ; return new Splitter ( new Strategy ( ) { @Override public SplittingIterator iterator ( Splitter splitter , final CharSequence toSplit ) { return new SplittingIterator ( splitter , toSplit ) { @Override int separatorStart ( int start ) { return separatorMatcher.indexIn ( toSplit , start ) ; } @Override int separatorEnd ( int separatorPosition ) { return separatorPosition + 1 ; } } ; } } ) ; } 
public SplittingIterator iterator ( Splitter splitter , final CharSequence toSplit ) { return new SplittingIterator ( splitter , toSplit ) { @Override int separatorStart ( int start ) { return separatorMatcher.indexIn ( toSplit , start ) ; } @Override int separatorEnd ( int separatorPosition ) { return separatorPosition + 1 ; } } ; } 
public static Splitter on ( final String separator ) { checkArgument ( separator.length ( ) != 0 , " The separator may not be the empty string. " ) ; if ( separator.length ( ) == 1 ) { return Splitter.on ( separator.charAt ( 0 ) ) ; } return new Splitter ( new Strategy ( ) { @Override public SplittingIterator iterator ( Splitter splitter , CharSequence toSplit ) { return new SplittingIterator ( splitter , toSplit ) { @Override public int separatorStart ( int start ) { int separatorLength = separator.length ( ) ; positions: for ( int p = start , last = toSplit.length ( ) - separatorLength ; p < = last ; p++ ) { for ( int i = 0 ; i < separatorLength ; i++ ) { if ( toSplit.charAt ( i + p ) != separator.charAt ( i ) ) { continue positions ; } } return p ; } return -1 ; } @Override public int separatorEnd ( int separatorPosition ) { return separatorPosition + separator.length ( ) ; } } ; } } ) ; } 
public SplittingIterator iterator ( Splitter splitter , CharSequence toSplit ) { return new SplittingIterator ( splitter , toSplit ) { @Override public int separatorStart ( int start ) { int separatorLength = separator.length ( ) ; positions: for ( int p = start , last = toSplit.length ( ) - separatorLength ; p < = last ; p++ ) { for ( int i = 0 ; i < separatorLength ; i++ ) { if ( toSplit.charAt ( i + p ) != separator.charAt ( i ) ) { continue positions ; } } return p ; } return -1 ; } @Override public int separatorEnd ( int separatorPosition ) { return separatorPosition + separator.length ( ) ; } } ; } 
private static Splitter on ( final CommonPattern separatorPattern ) { checkArgument ( !separatorPattern.matcher ( " " ) .matches ( ) , " The pattern may not match the empty string: %s " , separatorPattern ) ; return new Splitter ( new Strategy ( ) { @Override public SplittingIterator iterator ( final Splitter splitter , CharSequence toSplit ) { final CommonMatcher matcher = separatorPattern.matcher ( toSplit ) ; return new SplittingIterator ( splitter , toSplit ) { @Override public int separatorStart ( int start ) { return matcher.find ( start ) ? matcher.start ( ) : -1 ; } @Override public int separatorEnd ( int separatorPosition ) { return matcher.end ( ) ; } } ; } } ) ; } 
public SplittingIterator iterator ( final Splitter splitter , CharSequence toSplit ) { final CommonMatcher matcher = separatorPattern.matcher ( toSplit ) ; return new SplittingIterator ( splitter , toSplit ) { @Override public int separatorStart ( int start ) { return matcher.find ( start ) ? matcher.start ( ) : -1 ; } @Override public int separatorEnd ( int separatorPosition ) { return matcher.end ( ) ; } } ; } 
public static Splitter fixedLength ( final int length ) { checkArgument ( length > 0 , " The length may not be less than 1 " ) ; return new Splitter ( new Strategy ( ) { @Override public SplittingIterator iterator ( final Splitter splitter , CharSequence toSplit ) { return new SplittingIterator ( splitter , toSplit ) { @Override public int separatorStart ( int start ) { int nextChunkStart = start + length ; return ( nextChunkStart < toSplit.length ( ) ? nextChunkStart : -1 ) ; } @Override public int separatorEnd ( int separatorPosition ) { return separatorPosition ; } } ; } } ) ; } 
public SplittingIterator iterator ( final Splitter splitter , CharSequence toSplit ) { return new SplittingIterator ( splitter , toSplit ) { @Override public int separatorStart ( int start ) { int nextChunkStart = start + length ; return ( nextChunkStart < toSplit.length ( ) ? nextChunkStart : -1 ) ; } @Override public int separatorEnd ( int separatorPosition ) { return separatorPosition ; } } ; } 
public Iterable < String > split ( final CharSequence sequence ) { checkNotNull ( sequence ) ; return new Iterable < String > ( ) { @Override public Iterator < String > iterator ( ) { return splittingIterator ( sequence ) ; } @Override public String toString ( ) { return Joiner.on ( " , " ) .appendTo ( new StringBuilder ( ) .append ( '[' ) , this ) .append ( ']' ) .toString ( ) ; } } ; } 
public Map < String , String > split ( CharSequence sequence ) { Map < String , String > map = new LinkedHashMap < > ( ) ; for ( String entry : outerSplitter.split ( sequence ) ) { Iterator < String > entryFields = entrySplitter.splittingIterator ( entry ) ; checkArgument ( entryFields.hasNext ( ) , INVALID_ENTRY_MESSAGE , entry ) ; String key = entryFields.next ( ) ; checkArgument ( !map.containsKey ( key ) , " Duplicate key [%s] found. " , key ) ; checkArgument ( entryFields.hasNext ( ) , INVALID_ENTRY_MESSAGE , entry ) ; String value = entryFields.next ( ) ; map.put ( key , value ) ; checkArgument ( !entryFields.hasNext ( ) , INVALID_ENTRY_MESSAGE , entry ) ; } return Collections.unmodifiableMap ( map ) ; } 
protected String computeNext ( ) { int nextStart = offset ; while ( offset != -1 ) { int start = nextStart ; int end ; int separatorPosition = separatorStart ( offset ) ; if ( separatorPosition == -1 ) { end = toSplit.length ( ) ; offset = -1 ; } else { end = separatorPosition ; offset = separatorEnd ( separatorPosition ) ; } if ( offset == nextStart ) { offset++ ; if ( offset > toSplit.length ( ) ) { offset = -1 ; } continue ; } while ( start < end && trimmer.matches ( toSplit.charAt ( start ) ) ) { start++ ; } while ( end > start && trimmer.matches ( toSplit.charAt ( end - 1 ) ) ) { end-- ; } if ( omitEmptyStrings && start == end ) { nextStart = offset ; continue ; } if ( limit == 1 ) { end = toSplit.length ( ) ; offset = -1 ; while ( end > start && trimmer.matches ( toSplit.charAt ( end - 1 ) ) ) { end-- ; } } else { limit-- ; } return toSplit.subSequence ( start , end ) .toString ( ) ; } return endOfData ( ) ; } 
private static TimeUnit chooseUnit ( long nanos ) { if ( DAYS.convert ( nanos , NANOSECONDS ) > 0 ) { return DAYS ; } if ( HOURS.convert ( nanos , NANOSECONDS ) > 0 ) { return HOURS ; } if ( MINUTES.convert ( nanos , NANOSECONDS ) > 0 ) { return MINUTES ; } if ( SECONDS.convert ( nanos , NANOSECONDS ) > 0 ) { return SECONDS ; } if ( MILLISECONDS.convert ( nanos , NANOSECONDS ) > 0 ) { return MILLISECONDS ; } if ( MICROSECONDS.convert ( nanos , NANOSECONDS ) > 0 ) { return MICROSECONDS ; } return NANOSECONDS ; } 
private static String abbreviate ( TimeUnit unit ) { switch ( unit ) { case NANOSECONDS: return " ns " ; case MICROSECONDS: return " \u03bcs " ; case MILLISECONDS: return " ms " ; case SECONDS: return " s " ; case MINUTES: return " min " ; case HOURS: return " h " ; case DAYS: return " d " ; default: throw new AssertionError ( ) ; } } 
public static String repeat ( String string , int count ) { checkNotNull ( string ) ; if ( count < = 1 ) { checkArgument ( count > = 0 , " invalid count: %s " , count ) ; return ( count == 0 ) ? " " : string ; } final int len = string.length ( ) ; final long longSize = ( long ) len * ( long ) count ; final int size = ( int ) longSize ; if ( size != longSize ) { throw new ArrayIndexOutOfBoundsException ( " Required array size too large: " + longSize ) ; } final char[] array = new char[size] ; string.getChars ( 0 , len , array , 0 ) ; int n ; for ( n = len ; n < size - n ; n < < = 1 ) { System.arraycopy ( array , 0 , array , n , n ) ; } System.arraycopy ( array , 0 , array , n , size - n ) ; return new String ( array ) ; } 
public static String lenientFormat ( @Nullable String template , @Nullable Object@Nullable ... args ) { template = String.valueOf ( template ) ; if ( args == null ) { args = new Object[] { " ( Object[] ) null " } ; } else { for ( int i = 0 ; i < args.length ; i++ ) { args[i] = lenientToString ( args[i] ) ; } } StringBuilder builder = new StringBuilder ( template.length ( ) + 16 * args.length ) ; int templateStart = 0 ; int i = 0 ; while ( i < args.length ) { int placeholderStart = template.indexOf ( " %s " , templateStart ) ; if ( placeholderStart == -1 ) { break ; } builder.append ( template , templateStart , placeholderStart ) ; builder.append ( args[i++] ) ; templateStart = placeholderStart + 2 ; } builder.append ( template , templateStart , template.length ( ) ) ; if ( i < args.length ) { builder.append ( " [ " ) ; builder.append ( args[i++] ) ; while ( i < args.length ) { builder.append ( " , " ) ; builder.append ( args[i++] ) ; } builder.append ( ']' ) ; } return builder.toString ( ) ; } 
public T get ( ) { if ( !initialized ) { synchronized ( this ) { if ( !initialized ) { T t = delegate.get ( ) ; value = t ; initialized = true ; delegate = null ; return t ; } } } return value ; } 
public T get ( ) { long nanos = expirationNanos ; long now = Platform.systemNanoTime ( ) ; if ( nanos == 0 || now - nanos > = 0 ) { synchronized ( this ) { if ( nanos == expirationNanos ) { T t = delegate.get ( ) ; value = t ; nanos = now + durationNanos ; expirationNanos = ( nanos == 0 ) ? 1 : nanos ; return t ; } } } return value ; } 
public static < X1 extends Throwable , X2 extends Throwable > void propagateIfPossible ( @Nullable Throwable throwable , Class < X1 > declaredType1 , Class < X2 > declaredType2 ) throws X1 , X2 { checkNotNull ( declaredType2 ) ; propagateIfInstanceOf ( throwable , declaredType1 ) ; propagateIfPossible ( throwable , declaredType2 ) ; } 
public static Throwable getRootCause ( Throwable throwable ) { Throwable slowPointer = throwable ; boolean advanceSlowPointer = false ; Throwable cause ; while ( ( cause = throwable.getCause ( ) ) != null ) { throwable = cause ; if ( throwable == slowPointer ) { throw new IllegalArgumentException ( " Loop in causal chain detected. " , throwable ) ; } if ( advanceSlowPointer ) { slowPointer = slowPointer.getCause ( ) ; } advanceSlowPointer = !advanceSlowPointer ; } return throwable ; } 
public static List < Throwable > getCausalChain ( Throwable throwable ) { checkNotNull ( throwable ) ; List < Throwable > causes = new ArrayList < > ( 4 ) ; causes.add ( throwable ) ; Throwable slowPointer = throwable ; boolean advanceSlowPointer = false ; Throwable cause ; while ( ( cause = throwable.getCause ( ) ) != null ) { throwable = cause ; causes.add ( throwable ) ; if ( throwable == slowPointer ) { throw new IllegalArgumentException ( " Loop in causal chain detected. " , throwable ) ; } if ( advanceSlowPointer ) { slowPointer = slowPointer.getCause ( ) ; } advanceSlowPointer = !advanceSlowPointer ; } return Collections.unmodifiableList ( causes ) ; } 
private static List < StackTraceElement > jlaStackTrace ( final Throwable t ) { checkNotNull ( t ) ; return new AbstractList < StackTraceElement > ( ) { @Override public StackTraceElement get ( int n ) { return ( StackTraceElement ) invokeAccessibleNonThrowingMethod ( getStackTraceElementMethod , jla , t , n ) ; } @Override public int size ( ) { return ( Integer ) invokeAccessibleNonThrowingMethod ( getStackTraceDepthMethod , jla , t ) ; } } ; } 
private static Object invokeAccessibleNonThrowingMethod ( Method method , Object receiver , Object... params ) { try { return method.invoke ( receiver , params ) ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( e ) ; } catch ( InvocationTargetException e ) { throw propagate ( e.getCause ( ) ) ; } } 
private static Object getJLA ( ) { try { Class < ? > sharedSecrets = Class.forName ( SHARED_SECRETS_CLASSNAME , false , null ) ; Method langAccess = sharedSecrets.getMethod ( " getJavaLangAccess " ) ; return langAccess.invoke ( null ) ; } catch ( ThreadDeath death ) { throw death ; } catch ( Throwable t ) { return null ; } } 
private static Method getSizeMethod ( ) { try { Method getStackTraceDepth = getJlaMethod ( " getStackTraceDepth " , Throwable.class ) ; if ( getStackTraceDepth == null ) { return null ; } getStackTraceDepth.invoke ( getJLA ( ) , new Throwable ( ) ) ; return getStackTraceDepth ; } catch ( UnsupportedOperationException | IllegalAccessException | InvocationTargetException e ) { return null ; } } 
public static int encodedLength ( CharSequence sequence ) { int utf16Length = sequence.length ( ) ; int utf8Length = utf16Length ; int i = 0 ; while ( i < utf16Length && sequence.charAt ( i ) < 0x80 ) { i++ ; } for ( ; i < utf16Length ; i++ ) { char c = sequence.charAt ( i ) ; if ( c < 0x800 ) { utf8Length += ( ( 0x7f - c ) > > > 31 ) ; } else { utf8Length += encodedLengthGeneral ( sequence , i ) ; break ; } } if ( utf8Length < utf16Length ) { throw new IllegalArgumentException ( " UTF-8 length does not fit in int: " + ( utf8Length + ( 1L < < 32 ) ) ) ; } return utf8Length ; } 
private static int encodedLengthGeneral ( CharSequence sequence , int start ) { int utf16Length = sequence.length ( ) ; int utf8Length = 0 ; for ( int i = start ; i < utf16Length ; i++ ) { char c = sequence.charAt ( i ) ; if ( c < 0x800 ) { utf8Length += ( 0x7f - c ) > > > 31 ; } else { utf8Length += 2 ; if ( MIN_SURROGATE < = c && c < = MAX_SURROGATE ) { if ( Character.codePointAt ( sequence , i ) == c ) { throw new IllegalArgumentException ( unpairedSurrogateMsg ( i ) ) ; } i++ ; } } } return utf8Length ; } 
private static boolean isWellFormedSlowPath ( byte[] bytes , int off , int end ) { int index = off ; while ( true ) { int byte1 ; do { if ( index > = end ) { return true ; } } while ( ( byte1 = bytes[index++] ) > = 0 ) ; if ( byte1 < ( byte ) 0xE0 ) { if ( index == end ) { return false ; } if ( byte1 < ( byte ) 0xC2 || bytes[index++] > ( byte ) 0xBF ) { return false ; } } else if ( byte1 < ( byte ) 0xF0 ) { if ( index + 1 > = end ) { return false ; } int byte2 = bytes[index++] ; if ( byte2 > ( byte ) 0xBF || ( byte1 == ( byte ) 0xE0 && byte2 < ( byte ) 0xA0 ) || ( byte1 == ( byte ) 0xED && ( byte ) 0xA0 < = byte2 ) || bytes[index++] > ( byte ) 0xBF ) { return false ; } } else { if ( index + 2 > = end ) { return false ; } int byte2 = bytes[index++] ; if ( byte2 > ( byte ) 0xBF || ( ( ( byte1 < < 28 ) + ( byte2 - ( byte ) 0x90 ) ) > > 30 ) != 0 || bytes[index++] > ( byte ) 0xBF || bytes[index++] > ( byte ) 0xBF ) { return false ; } } } } 
public static void verify ( boolean expression , @Nullable String errorMessageTemplate , @Nullable Object@Nullable ... errorMessageArgs ) { if ( !expression ) { throw new VerifyException ( lenientFormat ( errorMessageTemplate , errorMessageArgs ) ) ; } } 
public static void verify ( boolean expression , @Nullable String errorMessageTemplate , char p1 ) { if ( !expression ) { throw new VerifyException ( lenientFormat ( errorMessageTemplate , p1 ) ) ; } } 
public static void verify ( boolean expression , @Nullable String errorMessageTemplate , int p1 ) { if ( !expression ) { throw new VerifyException ( lenientFormat ( errorMessageTemplate , p1 ) ) ; } } 
public static void verify ( boolean expression , @Nullable String errorMessageTemplate , long p1 ) { if ( !expression ) { throw new VerifyException ( lenientFormat ( errorMessageTemplate , p1 ) ) ; } } 
public static void verify ( boolean expression , @Nullable String errorMessageTemplate , @Nullable Object p1 ) { if ( !expression ) { throw new VerifyException ( lenientFormat ( errorMessageTemplate , p1 ) ) ; } } 
public static void verify ( boolean expression , @Nullable String errorMessageTemplate , char p1 , char p2 ) { if ( !expression ) { throw new VerifyException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void verify ( boolean expression , @Nullable String errorMessageTemplate , int p1 , char p2 ) { if ( !expression ) { throw new VerifyException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void verify ( boolean expression , @Nullable String errorMessageTemplate , long p1 , char p2 ) { if ( !expression ) { throw new VerifyException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void verify ( boolean expression , @Nullable String errorMessageTemplate , @Nullable Object p1 , char p2 ) { if ( !expression ) { throw new VerifyException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void verify ( boolean expression , @Nullable String errorMessageTemplate , char p1 , int p2 ) { if ( !expression ) { throw new VerifyException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void verify ( boolean expression , @Nullable String errorMessageTemplate , int p1 , int p2 ) { if ( !expression ) { throw new VerifyException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void verify ( boolean expression , @Nullable String errorMessageTemplate , long p1 , int p2 ) { if ( !expression ) { throw new VerifyException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void verify ( boolean expression , @Nullable String errorMessageTemplate , @Nullable Object p1 , int p2 ) { if ( !expression ) { throw new VerifyException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void verify ( boolean expression , @Nullable String errorMessageTemplate , char p1 , long p2 ) { if ( !expression ) { throw new VerifyException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void verify ( boolean expression , @Nullable String errorMessageTemplate , int p1 , long p2 ) { if ( !expression ) { throw new VerifyException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void verify ( boolean expression , @Nullable String errorMessageTemplate , long p1 , long p2 ) { if ( !expression ) { throw new VerifyException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void verify ( boolean expression , @Nullable String errorMessageTemplate , @Nullable Object p1 , long p2 ) { if ( !expression ) { throw new VerifyException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void verify ( boolean expression , @Nullable String errorMessageTemplate , char p1 , @Nullable Object p2 ) { if ( !expression ) { throw new VerifyException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void verify ( boolean expression , @Nullable String errorMessageTemplate , int p1 , @Nullable Object p2 ) { if ( !expression ) { throw new VerifyException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void verify ( boolean expression , @Nullable String errorMessageTemplate , long p1 , @Nullable Object p2 ) { if ( !expression ) { throw new VerifyException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void verify ( boolean expression , @Nullable String errorMessageTemplate , @Nullable Object p1 , @Nullable Object p2 ) { if ( !expression ) { throw new VerifyException ( lenientFormat ( errorMessageTemplate , p1 , p2 ) ) ; } } 
public static void verify ( boolean expression , @Nullable String errorMessageTemplate , @Nullable Object p1 , @Nullable Object p2 , @Nullable Object p3 ) { if ( !expression ) { throw new VerifyException ( lenientFormat ( errorMessageTemplate , p1 , p2 , p3 ) ) ; } } 
public static void verify ( boolean expression , @Nullable String errorMessageTemplate , @Nullable Object p1 , @Nullable Object p2 , @Nullable Object p3 , @Nullable Object p4 ) { if ( !expression ) { throw new VerifyException ( lenientFormat ( errorMessageTemplate , p1 , p2 , p3 , p4 ) ) ; } } 
public static < T > T verifyNotNull ( @Nullable T reference , @Nullable String errorMessageTemplate , @Nullable Object@Nullable ... errorMessageArgs ) { verify ( reference != null , errorMessageTemplate , errorMessageArgs ) ; return reference ; } 
public ImmutableMap < K , V > getAllPresent ( Iterable < ? > keys ) { Map < K , V > result = Maps.newLinkedHashMap ( ) ; for ( Object key : keys ) { if ( !result.containsKey ( key ) ) { @SuppressWarnings ( " unchecked " ) K castKey = ( K ) key ; V value = getIfPresent ( key ) ; if ( value != null ) { result.put ( castKey , value ) ; } } } return ImmutableMap.copyOf ( result ) ; } 
public void put ( K key , V value ) { throw new UnsupportedOperationException ( ) ; }
public V get ( K key , Callable < ? extends V > valueLoader ) throws ExecutionException { throw new UnsupportedOperationException ( ) ; }public void cleanUp ( ) { } 
public long size ( ) { throw new UnsupportedOperationException ( ) ; } 
public void invalidate ( Object key ) { throw new UnsupportedOperationException ( ) ; } 
public void invalidateAll ( ) { throw new UnsupportedOperationException ( ) ; } 
public CacheStats stats ( ) { throw new UnsupportedOperationException ( ) ; } 
public ConcurrentMap < K , V > asMap ( ) { throw new UnsupportedOperationException ( ) ; } 
public void refresh ( K key ) { throw new UnsupportedOperationException ( ) ; } public void recordMisses ( int count ) { } 
public void recordLoadSuccess ( long loadTime ) { } 
public void recordLoadException ( long loadTime ) { } 
public void recordEviction ( ) { } 
public void onRemoval ( RemovalNotification < Object , Object > notification ) { } 
public String toString ( ) { MoreObjects.ToStringHelper s = MoreObjects.toStringHelper ( this ) ; if ( initialCapacity != UNSET_INT ) { s.add ( " initialCapacity " , initialCapacity ) ; } if ( concurrencyLevel != UNSET_INT ) { s.add ( " concurrencyLevel " , concurrencyLevel ) ; } if ( maximumSize != UNSET_INT ) { s.add ( " maximumSize " , maximumSize ) ; } if ( maximumWeight != UNSET_INT ) { s.add ( " maximumWeight " , maximumWeight ) ; } if ( expireAfterWriteNanos != UNSET_INT ) { s.add ( " expireAfterWrite " , expireAfterWriteNanos + " ns " ) ; } if ( expireAfterAccessNanos != UNSET_INT ) { s.add ( " expireAfterAccess " , expireAfterAccessNanos + " ns " ) ; } if ( keyStrength != null ) { s.add ( " keyStrength " , Ascii.toLowerCase ( keyStrength.toString ( ) ) ) ; } if ( valueStrength != null ) { s.add ( " valueStrength " , Ascii.toLowerCase ( valueStrength.toString ( ) ) ) ; } if ( keyEquivalence != null ) { s.addValue ( " keyEquivalence " ) ; } if ( valueEquivalence != null ) { s.addValue ( " valueEquivalence " ) ; } if ( removalListener != null ) { s.addValue ( " removalListener " ) ; } return s.toString ( ) ; } 
public static CacheBuilderSpec parse ( String cacheBuilderSpecification ) { CacheBuilderSpec spec = new CacheBuilderSpec ( cacheBuilderSpecification ) ; if ( !cacheBuilderSpecification.isEmpty ( ) ) { for ( String keyValuePair : KEYS_SPLITTER.split ( cacheBuilderSpecification ) ) { List < String > keyAndValue = ImmutableList.copyOf ( KEY_VALUE_SPLITTER.split ( keyValuePair ) ) ; checkArgument ( !keyAndValue.isEmpty ( ) , " blank key-value pair " ) ; checkArgument ( keyAndValue.size ( ) < = 2 , " key-value pair %s with more than one equals sign " , keyValuePair ) ; String key = keyAndValue.get ( 0 ) ; ValueParser valueParser = VALUE_PARSERS.get ( key ) ; checkArgument ( valueParser != null , " unknown key %s " , key ) ; String value = keyAndValue.size ( ) == 1 ? null : keyAndValue.get ( 1 ) ; valueParser.parse ( spec , key , value ) ; } } return spec ; } 
CacheBuilder < Object , Object > toCacheBuilder ( ) { CacheBuilder < Object , Object > builder = CacheBuilder.newBuilder ( ) ; if ( initialCapacity != null ) { builder.initialCapacity ( initialCapacity ) ; } if ( maximumSize != null ) { builder.maximumSize ( maximumSize ) ; } if ( maximumWeight != null ) { builder.maximumWeight ( maximumWeight ) ; } if ( concurrencyLevel != null ) { builder.concurrencyLevel ( concurrencyLevel ) ; } if ( keyStrength != null ) { switch ( keyStrength ) { case WEAK: builder.weakKeys ( ) ; break ; default: throw new AssertionError ( ) ; } } if ( valueStrength != null ) { switch ( valueStrength ) { case SOFT: builder.softValues ( ) ; break ; case WEAK: builder.weakValues ( ) ; break ; default: throw new AssertionError ( ) ; } } if ( recordStats != null && recordStats ) { builder.recordStats ( ) ; } if ( writeExpirationTimeUnit != null ) { builder.expireAfterWrite ( writeExpirationDuration , writeExpirationTimeUnit ) ; } if ( accessExpirationTimeUnit != null ) { builder.expireAfterAccess ( accessExpirationDuration , accessExpirationTimeUnit ) ; } if ( refreshTimeUnit != null ) { builder.refreshAfterWrite ( refreshDuration , refreshTimeUnit ) ; } return builder ; } 
public void parse ( CacheBuilderSpec spec , String key , String value ) { checkArgument ( value != null && !value.isEmpty ( ) , " value of key %s omitted " , key ) ; try { char lastChar = value.charAt ( value.length ( ) - 1 ) ; TimeUnit timeUnit ; switch ( lastChar ) { case 'd': timeUnit = TimeUnit.DAYS ; break ; case 'h': timeUnit = TimeUnit.HOURS ; break ; case 'm': timeUnit = TimeUnit.MINUTES ; break ; case 's': timeUnit = TimeUnit.SECONDS ; break ; default: throw new IllegalArgumentException ( format ( " key %s invalid format. was %s , must end with one of [dDhHmMsS] " , key , value ) ) ; } long duration = Long.parseLong ( value.substring ( 0 , value.length ( ) - 1 ) ) ; parseDuration ( spec , duration , timeUnit ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( format ( " key %s value set to %s , must be integer " , key , value ) ) ; } } 
public static < K , V > CacheLoader < K , V > asyncReloading ( final CacheLoader < K , V > loader , final Executor executor ) { checkNotNull ( loader ) ; checkNotNull ( executor ) ; return new CacheLoader < K , V > ( ) { @Override public V load ( K key ) throws Exception { return loader.load ( key ) ; } @Override public ListenableFuture < V > reload ( final K key , final V oldValue ) throws Exception { ListenableFutureTask < V > task = ListenableFutureTask.create ( new Callable < V > ( ) { @Override public V call ( ) throws Exception { return loader.reload ( key , oldValue ) .get ( ) ; } } ) ; executor.execute ( task ) ; return task ; } @Override public Map < K , V > loadAll ( Iterable < ? extends K > keys ) throws Exception { return loader.loadAll ( keys ) ; } } ; } 
public ListenableFuture < V > reload ( final K key , final V oldValue ) throws Exception { ListenableFutureTask < V > task = ListenableFutureTask.create ( new Callable < V > ( ) { @Override public V call ( ) throws Exception { return loader.reload ( key , oldValue ) .get ( ) ; } } ) ; executor.execute ( task ) ; return task ; } 
 < K , V > ValueReference < K , V > referenceValue ( Segment < K , V > segment , ReferenceEntry < K , V > entry , V value , int weight ) { return ( weight == 1 ) ? new StrongValueReference < K , V > ( value ) : new WeightedStrongValueReference < K , V > ( value , weight ) ; } 
 < K , V > ValueReference < K , V > referenceValue ( Segment < K , V > segment , ReferenceEntry < K , V > entry , V value , int weight ) { return ( weight == 1 ) ? new SoftValueReference < K , V > ( segment.valueReferenceQueue , value , entry ) : new WeightedSoftValueReference < K , V > ( segment.valueReferenceQueue , value , entry , weight ) ; } 
 < K , V > ValueReference < K , V > referenceValue ( Segment < K , V > segment , ReferenceEntry < K , V > entry , V value , int weight ) { return ( weight == 1 ) ? new WeakValueReference < K , V > ( segment.valueReferenceQueue , value , entry ) : new WeightedWeakValueReference < K , V > ( segment.valueReferenceQueue , value , entry , weight ) ; } 
 < K , V > ReferenceEntry < K , V > copyEntry ( Segment < K , V > segment , ReferenceEntry < K , V > original , ReferenceEntry < K , V > newNext ) { return newEntry ( segment , original.getKey ( ) , original.getHash ( ) , newNext ) ; } 
 < K , V > ReferenceEntry < K , V > newEntry ( Segment < K , V > segment , K key , int hash , @Nullable ReferenceEntry < K , V > next ) { return new StrongEntry < > ( key , hash , next ) ; } 
 < K , V > ReferenceEntry < K , V > newEntry ( Segment < K , V > segment , K key , int hash , @Nullable ReferenceEntry < K , V > next ) { return new StrongAccessEntry < > ( key , hash , next ) ; } 
 < K , V > ReferenceEntry < K , V > copyEntry ( Segment < K , V > segment , ReferenceEntry < K , V > original , ReferenceEntry < K , V > newNext ) { ReferenceEntry < K , V > newEntry = super.copyEntry ( segment , original , newNext ) ; copyAccessEntry ( original , newEntry ) ; return newEntry ; } 
 < K , V > ReferenceEntry < K , V > newEntry ( Segment < K , V > segment , K key , int hash , @Nullable ReferenceEntry < K , V > next ) { return new StrongWriteEntry < > ( key , hash , next ) ; } 
 < K , V > ReferenceEntry < K , V > copyEntry ( Segment < K , V > segment , ReferenceEntry < K , V > original , ReferenceEntry < K , V > newNext ) { ReferenceEntry < K , V > newEntry = super.copyEntry ( segment , original , newNext ) ; copyWriteEntry ( original , newEntry ) ; return newEntry ; } 
 < K , V > ReferenceEntry < K , V > newEntry ( Segment < K , V > segment , K key , int hash , @Nullable ReferenceEntry < K , V > next ) { return new StrongAccessWriteEntry < > ( key , hash , next ) ; } 
 < K , V > ReferenceEntry < K , V > copyEntry ( Segment < K , V > segment , ReferenceEntry < K , V > original , ReferenceEntry < K , V > newNext ) { ReferenceEntry < K , V > newEntry = super.copyEntry ( segment , original , newNext ) ; copyAccessEntry ( original , newEntry ) ; copyWriteEntry ( original , newEntry ) ; return newEntry ; } 
 < K , V > ReferenceEntry < K , V > newEntry ( Segment < K , V > segment , K key , int hash , @Nullable ReferenceEntry < K , V > next ) { return new WeakEntry < > ( segment.keyReferenceQueue , key , hash , next ) ; } 
 < K , V > ReferenceEntry < K , V > newEntry ( Segment < K , V > segment , K key , int hash , @Nullable ReferenceEntry < K , V > next ) { return new WeakAccessEntry < > ( segment.keyReferenceQueue , key , hash , next ) ; } 
 < K , V > ReferenceEntry < K , V > newEntry ( Segment < K , V > segment , K key , int hash , @Nullable ReferenceEntry < K , V > next ) { return new WeakWriteEntry < > ( segment.keyReferenceQueue , key , hash , next ) ; } 
 < K , V > ReferenceEntry < K , V > newEntry ( Segment < K , V > segment , K key , int hash , @Nullable ReferenceEntry < K , V > next ) { return new WeakAccessWriteEntry < > ( segment.keyReferenceQueue , key , hash , next ) ; } 
public ValueReference < Object , Object > copyFor ( ReferenceQueue < Object > queue , @Nullable Object value , ReferenceEntry < Object , Object > entry ) { return this ; } 
public void notifyNewValue ( Object newValue ) { } 
public ValueReference < Object , Object > getValueReference ( ) { return null ; } 
public void setValueReference ( ValueReference < Object , Object > valueReference ) { } 
public ReferenceEntry < Object , Object > getNext ( ) { return null ; } 
public Object getKey ( ) { return null ; } 
public void setAccessTime ( long time ) { } 
public void setNextInAccessQueue ( ReferenceEntry < Object , Object > next ) { } 
public void setPreviousInAccessQueue ( ReferenceEntry < Object , Object > previous ) { } 
public void setWriteTime ( long time ) { } 
public void setNextInWriteQueue ( ReferenceEntry < Object , Object > next ) { } 
public void setPreviousInWriteQueue ( ReferenceEntry < Object , Object > previous ) { } 
public ValueReference < K , V > getValueReference ( ) { throw new UnsupportedOperationException ( ) ; } 
public void setValueReference ( ValueReference < K , V > valueReference ) { throw new UnsupportedOperationException ( ) ; } 
public ReferenceEntry < K , V > getNext ( ) { throw new UnsupportedOperationException ( ) ; } 
public int getHash ( ) { throw new UnsupportedOperationException ( ) ; } 
public K getKey ( ) { throw new UnsupportedOperationException ( ) ; } 
public long getAccessTime ( ) { throw new UnsupportedOperationException ( ) ; } 
public void setAccessTime ( long time ) { throw new UnsupportedOperationException ( ) ; } 
public ReferenceEntry < K , V > getNextInAccessQueue ( ) { throw new UnsupportedOperationException ( ) ; } 
public void setNextInAccessQueue ( ReferenceEntry < K , V > next ) { throw new UnsupportedOperationException ( ) ; } 
public ReferenceEntry < K , V > getPreviousInAccessQueue ( ) { throw new UnsupportedOperationException ( ) ; } 
public void setPreviousInAccessQueue ( ReferenceEntry < K , V > previous ) { throw new UnsupportedOperationException ( ) ; } 
public long getWriteTime ( ) { throw new UnsupportedOperationException ( ) ; } 
public void setWriteTime ( long time ) { throw new UnsupportedOperationException ( ) ; } 
public ReferenceEntry < K , V > getNextInWriteQueue ( ) { throw new UnsupportedOperationException ( ) ; } 
public void setNextInWriteQueue ( ReferenceEntry < K , V > next ) { throw new UnsupportedOperationException ( ) ; } 
public ReferenceEntry < K , V > getPreviousInWriteQueue ( ) { throw new UnsupportedOperationException ( ) ; } 
public void setPreviousInWriteQueue ( ReferenceEntry < K , V > previous ) { throw new UnsupportedOperationException ( ) ; } 
public Object peek ( ) { return null ; } 
public Object poll ( ) { return null ; } 
public void notifyNewValue ( V newValue ) { } 
public ReferenceEntry < K , V > getEntry ( ) { return null ; }
V getLiveValue ( ReferenceEntry < K , V > entry , long now ) { if ( entry.getKey ( ) == null ) { return null ; } V value = entry.getValueReference ( ) .get ( ) ; if ( value == null ) { return null ; } if ( isExpired ( entry , now ) ) { return null ; } return value ; } 
ReferenceEntry < K , V > copyEntry ( ReferenceEntry < K , V > original , ReferenceEntry < K , V > newNext ) { if ( original.getKey ( ) == null ) { return null ; } ValueReference < K , V > valueReference = original.getValueReference ( ) ; V value = valueReference.get ( ) ; if ( ( value == null ) && valueReference.isActive ( ) ) { return null ; } ReferenceEntry < K , V > newEntry = map.entryFactory.copyEntry ( this , original , newNext ) ; newEntry.setValueReference ( valueReference.copyFor ( this.valueReferenceQueue , value , newEntry ) ) ; return newEntry ; } 
V get ( K key , int hash , CacheLoader < ? super K , V > loader ) throws ExecutionException { checkNotNull ( key ) ; checkNotNull ( loader ) ; try { if ( count != 0 ) { ReferenceEntry < K , V > e = getEntry ( key , hash ) ; if ( e != null ) { long now = map.ticker.read ( ) ; V value = getLiveValue ( e , now ) ; if ( value != null ) { recordRead ( e , now ) ; statsCounter.recordHits ( 1 ) ; return scheduleRefresh ( e , key , hash , value , now , loader ) ; } ValueReference < K , V > valueReference = e.getValueReference ( ) ; if ( valueReference.isLoading ( ) ) { return waitForLoadingValue ( e , key , valueReference ) ; } } } return lockedGetOrLoad ( key , hash , loader ) ; } catch ( ExecutionException ee ) { Throwable cause = ee.getCause ( ) ; if ( cause instanceof Error ) { throw new ExecutionError ( ( Error ) cause ) ; } else if ( cause instanceof RuntimeException ) { throw new UncheckedExecutionException ( cause ) ; } throw ee ; } finally { postReadCleanup ( ) ; } } 
V get ( Object key , int hash ) { try { if ( count != 0 ) { long now = map.ticker.read ( ) ; ReferenceEntry < K , V > e = getLiveEntry ( key , hash , now ) ; if ( e == null ) { return null ; } V value = e.getValueReference ( ) .get ( ) ; if ( value != null ) { recordRead ( e , now ) ; return scheduleRefresh ( e , e.getKey ( ) , hash , value , now , map.defaultLoader ) ; } tryDrainReferenceQueues ( ) ; } return null ; } finally { postReadCleanup ( ) ; } } 
V lockedGetOrLoad ( K key , int hash , CacheLoader < ? super K , V > loader ) throws ExecutionException { ReferenceEntry < K , V > e ; ValueReference < K , V > valueReference = null ; LoadingValueReference < K , V > loadingValueReference = null ; boolean createNewEntry = true ; lock ( ) ; try { long now = map.ticker.read ( ) ; preWriteCleanup ( now ) ; int newCount = this.count - 1 ; AtomicReferenceArray < ReferenceEntry < K , V > > table = this.table ; int index = hash & ( table.length ( ) - 1 ) ; ReferenceEntry < K , V > first = table.get ( index ) ; for ( e = first ; e != null ; e = e.getNext ( ) ) { K entryKey = e.getKey ( ) ; if ( e.getHash ( ) == hash && entryKey != null && map.keyEquivalence.equivalent ( key , entryKey ) ) { valueReference = e.getValueReference ( ) ; if ( valueReference.isLoading ( ) ) { createNewEntry = false ; } else { V value = valueReference.get ( ) ; if ( value == null ) { enqueueNotification ( entryKey , hash , value , valueReference.getWeight ( ) , RemovalCause.COLLECTED ) ; } else if ( map.isExpired ( e , now ) ) { enqueueNotification ( entryKey , hash , value , valueReference.getWeight ( ) , RemovalCause.EXPIRED ) ; } else { recordLockedRead ( e , now ) ; statsCounter.recordHits ( 1 ) ; return value ; } writeQueue.remove ( e ) ; accessQueue.remove ( e ) ; this.count = newCount ; } break ; } } if ( createNewEntry ) { loadingValueReference = new LoadingValueReference < > ( ) ; if ( e == null ) { e = newEntry ( key , hash , first ) ; e.setValueReference ( loadingValueReference ) ; table.set ( index , e ) ; } else { e.setValueReference ( loadingValueReference ) ; } } } finally { unlock ( ) ; postWriteCleanup ( ) ; } if ( createNewEntry ) { try { synchronized ( e ) { return loadSync ( key , hash , loadingValueReference , loader ) ; } } finally { statsCounter.recordMisses ( 1 ) ; } } else { return waitForLoadingValue ( e , key , valueReference ) ; } } 
V waitForLoadingValue ( ReferenceEntry < K , V > e , K key , ValueReference < K , V > valueReference ) throws ExecutionException { if ( !valueReference.isLoading ( ) ) { throw new AssertionError ( ) ; } checkState ( !Thread.holdsLock ( e ) , " Recursive load of: %s " , key ) ; try { V value = valueReference.waitForValue ( ) ; if ( value == null ) { throw new InvalidCacheLoadException ( " CacheLoader returned null for key " + key + " . " ) ; } long now = map.ticker.read ( ) ; recordRead ( e , now ) ; return value ; } finally { statsCounter.recordMisses ( 1 ) ; } } 
V compute ( K key , int hash , BiFunction < ? super K , ? super V , ? extends V > function ) { ReferenceEntry < K , V > e ; ValueReference < K , V > valueReference = null ; LoadingValueReference < K , V > loadingValueReference = null ; boolean createNewEntry = true ; V newValue ; lock ( ) ; try { long now = map.ticker.read ( ) ; preWriteCleanup ( now ) ; AtomicReferenceArray < ReferenceEntry < K , V > > table = this.table ; int index = hash & ( table.length ( ) - 1 ) ; ReferenceEntry < K , V > first = table.get ( index ) ; for ( e = first ; e != null ; e = e.getNext ( ) ) { K entryKey = e.getKey ( ) ; if ( e.getHash ( ) == hash && entryKey != null && map.keyEquivalence.equivalent ( key , entryKey ) ) { valueReference = e.getValueReference ( ) ; if ( map.isExpired ( e , now ) ) { enqueueNotification ( entryKey , hash , valueReference.get ( ) , valueReference.getWeight ( ) , RemovalCause.EXPIRED ) ; } writeQueue.remove ( e ) ; accessQueue.remove ( e ) ; createNewEntry = false ; break ; } } loadingValueReference = new LoadingValueReference < > ( valueReference ) ; if ( e == null ) { createNewEntry = true ; e = newEntry ( key , hash , first ) ; e.setValueReference ( loadingValueReference ) ; table.set ( index , e ) ; } else { e.setValueReference ( loadingValueReference ) ; } newValue = loadingValueReference.compute ( key , function ) ; if ( newValue != null ) { if ( valueReference != null && newValue == valueReference.get ( ) ) { loadingValueReference.set ( newValue ) ; e.setValueReference ( valueReference ) ; recordWrite ( e , 0 , now ) ; return newValue ; } try { return getAndRecordStats ( key , hash , loadingValueReference , Futures.immediateFuture ( newValue ) ) ; } catch ( ExecutionException exception ) { throw new AssertionError ( " impossible ; Futures.immediateFuture can't throw " ) ; } } else if ( createNewEntry ) { removeLoadingValue ( key , hash , loadingValueReference ) ; return null ; } else { removeEntry ( e , hash , RemovalCause.EXPLICIT ) ; return null ; } } finally { unlock ( ) ; postWriteCleanup ( ) ; } } 
ListenableFuture < V > loadAsync ( final K key , final int hash , final LoadingValueReference < K , V > loadingValueReference , CacheLoader < ? super K , V > loader ) { final ListenableFuture < V > loadingFuture = loadingValueReference.loadFuture ( key , loader ) ; loadingFuture.addListener ( new Runnable ( ) { @Override public void run ( ) { try { getAndRecordStats ( key , hash , loadingValueReference , loadingFuture ) ; } catch ( Throwable t ) { logger.log ( Level.WARNING , " Exception thrown during refresh " , t ) ; loadingValueReference.setException ( t ) ; } } } , directExecutor ( ) ) ; return loadingFuture ; } 
V getAndRecordStats ( K key , int hash , LoadingValueReference < K , V > loadingValueReference , ListenableFuture < V > newValue ) throws ExecutionException { V value = null ; try { value = getUninterruptibly ( newValue ) ; if ( value == null ) { throw new InvalidCacheLoadException ( " CacheLoader returned null for key " + key + " . " ) ; } statsCounter.recordLoadSuccess ( loadingValueReference.elapsedNanos ( ) ) ; storeLoadedValue ( key , hash , loadingValueReference , value ) ; return value ; } finally { if ( value == null ) { statsCounter.recordLoadException ( loadingValueReference.elapsedNanos ( ) ) ; removeLoadingValue ( key , hash , loadingValueReference ) ; } } } 
V scheduleRefresh ( ReferenceEntry < K , V > entry , K key , int hash , V oldValue , long now , CacheLoader < ? super K , V > loader ) { if ( map.refreshes ( ) && ( now - entry.getWriteTime ( ) > map.refreshNanos ) && !entry.getValueReference ( ) .isLoading ( ) ) { V newValue = refresh ( key , hash , loader , true ) ; if ( newValue != null ) { return newValue ; } } return oldValue ; } 
V refresh ( K key , int hash , CacheLoader < ? super K , V > loader , boolean checkTime ) { final LoadingValueReference < K , V > loadingValueReference = insertLoadingValueReference ( key , hash , checkTime ) ; if ( loadingValueReference == null ) { return null ; } ListenableFuture < V > result = loadAsync ( key , hash , loadingValueReference , loader ) ; if ( result.isDone ( ) ) { try { return Uninterruptibles.getUninterruptibly ( result ) ; } catch ( Throwable t ) { } } return null ; } 
LoadingValueReference < K , V > insertLoadingValueReference ( final K key , final int hash , boolean checkTime ) { ReferenceEntry < K , V > e = null ; lock ( ) ; try { long now = map.ticker.read ( ) ; preWriteCleanup ( now ) ; AtomicReferenceArray < ReferenceEntry < K , V > > table = this.table ; int index = hash & ( table.length ( ) - 1 ) ; ReferenceEntry < K , V > first = table.get ( index ) ; for ( e = first ; e != null ; e = e.getNext ( ) ) { K entryKey = e.getKey ( ) ; if ( e.getHash ( ) == hash && entryKey != null && map.keyEquivalence.equivalent ( key , entryKey ) ) { ValueReference < K , V > valueReference = e.getValueReference ( ) ; if ( valueReference.isLoading ( ) || ( checkTime && ( now - e.getWriteTime ( ) < map.refreshNanos ) ) ) { return null ; } ++modCount ; LoadingValueReference < K , V > loadingValueReference = new LoadingValueReference < > ( valueReference ) ; e.setValueReference ( loadingValueReference ) ; return loadingValueReference ; } } ++modCount ; LoadingValueReference < K , V > loadingValueReference = new LoadingValueReference < > ( ) ; e = newEntry ( key , hash , first ) ; e.setValueReference ( loadingValueReference ) ; table.set ( index , e ) ; return loadingValueReference ; } finally { unlock ( ) ; postWriteCleanup ( ) ; } } 
void clearValueReferenceQueue ( ) { while ( valueReferenceQueue.poll ( ) != null ) { } } 
void clearKeyReferenceQueue ( ) { while ( keyReferenceQueue.poll ( ) != null ) { } }
void expireEntries ( long now ) { drainRecencyQueue ( ) ; ReferenceEntry < K , V > e ; while ( ( e = writeQueue.peek ( ) ) != null && map.isExpired ( e , now ) ) { if ( !removeEntry ( e , e.getHash ( ) , RemovalCause.EXPIRED ) ) { throw new AssertionError ( ) ; } } while ( ( e = accessQueue.peek ( ) ) != null && map.isExpired ( e , now ) ) { if ( !removeEntry ( e , e.getHash ( ) , RemovalCause.EXPIRED ) ) { throw new AssertionError ( ) ; } } } 
void enqueueNotification ( @Nullable K key , int hash , @Nullable V value , int weight , RemovalCause cause ) { totalWeight -= weight ; if ( cause.wasEvicted ( ) ) { statsCounter.recordEviction ( ) ; } if ( map.removalNotificationQueue != DISCARDING_QUEUE ) { RemovalNotification < K , V > notification = RemovalNotification.create ( key , value , cause ) ; map.removalNotificationQueue.offer ( notification ) ; } } 
void evictEntries ( ReferenceEntry < K , V > newest ) { if ( !map.evictsBySize ( ) ) { return ; } drainRecencyQueue ( ) ; if ( newest.getValueReference ( ) .getWeight ( ) > maxSegmentWeight ) { if ( !removeEntry ( newest , newest.getHash ( ) , RemovalCause.SIZE ) ) { throw new AssertionError ( ) ; } } while ( totalWeight > maxSegmentWeight ) { ReferenceEntry < K , V > e = getNextEvictable ( ) ; if ( !removeEntry ( e , e.getHash ( ) , RemovalCause.SIZE ) ) { throw new AssertionError ( ) ; } } } 
ReferenceEntry < K , V > getEntry ( Object key , int hash ) { for ( ReferenceEntry < K , V > e = getFirst ( hash ) ; e != null ; e = e.getNext ( ) ) { if ( e.getHash ( ) != hash ) { continue ; } K entryKey = e.getKey ( ) ; if ( entryKey == null ) { tryDrainReferenceQueues ( ) ; continue ; } if ( map.keyEquivalence.equivalent ( key , entryKey ) ) { return e ; } } return null ; } 
ReferenceEntry < K , V > getLiveEntry ( Object key , int hash , long now ) { ReferenceEntry < K , V > e = getEntry ( key , hash ) ; if ( e == null ) { return null ; } else if ( map.isExpired ( e , now ) ) { tryExpireEntries ( now ) ; return null ; } return e ; } 
V getLiveValue ( ReferenceEntry < K , V > entry , long now ) { if ( entry.getKey ( ) == null ) { tryDrainReferenceQueues ( ) ; return null ; } V value = entry.getValueReference ( ) .get ( ) ; if ( value == null ) { tryDrainReferenceQueues ( ) ; return null ; } if ( map.isExpired ( entry , now ) ) { tryExpireEntries ( now ) ; return null ; } return value ; } 
boolean containsValue ( Object value ) { try { if ( count != 0 ) { long now = map.ticker.read ( ) ; AtomicReferenceArray < ReferenceEntry < K , V > > table = this.table ; int length = table.length ( ) ; for ( int i = 0 ; i < length ; ++i ) { for ( ReferenceEntry < K , V > e = table.get ( i ) ; e != null ; e = e.getNext ( ) ) { V entryValue = getLiveValue ( e , now ) ; if ( entryValue == null ) { continue ; } if ( map.valueEquivalence.equivalent ( value , entryValue ) ) { return true ; } } } } return false ; } finally { postReadCleanup ( ) ; } } 
V put ( K key , int hash , V value , boolean onlyIfAbsent ) { lock ( ) ; try { long now = map.ticker.read ( ) ; preWriteCleanup ( now ) ; int newCount = this.count + 1 ; if ( newCount > this.threshold ) { expand ( ) ; newCount = this.count + 1 ; } AtomicReferenceArray < ReferenceEntry < K , V > > table = this.table ; int index = hash & ( table.length ( ) - 1 ) ; ReferenceEntry < K , V > first = table.get ( index ) ; for ( ReferenceEntry < K , V > e = first ; e != null ; e = e.getNext ( ) ) { K entryKey = e.getKey ( ) ; if ( e.getHash ( ) == hash && entryKey != null && map.keyEquivalence.equivalent ( key , entryKey ) ) { ValueReference < K , V > valueReference = e.getValueReference ( ) ; V entryValue = valueReference.get ( ) ; if ( entryValue == null ) { ++modCount ; if ( valueReference.isActive ( ) ) { enqueueNotification ( key , hash , entryValue , valueReference.getWeight ( ) , RemovalCause.COLLECTED ) ; setValue ( e , key , value , now ) ; newCount = this.count ; } else { setValue ( e , key , value , now ) ; newCount = this.count + 1 ; } this.count = newCount ; evictEntries ( e ) ; return null ; } else if ( onlyIfAbsent ) { recordLockedRead ( e , now ) ; return entryValue ; } else { ++modCount ; enqueueNotification ( key , hash , entryValue , valueReference.getWeight ( ) , RemovalCause.REPLACED ) ; setValue ( e , key , value , now ) ; evictEntries ( e ) ; return entryValue ; } } } ++modCount ; ReferenceEntry < K , V > newEntry = newEntry ( key , hash , first ) ; setValue ( newEntry , key , value , now ) ; table.set ( index , newEntry ) ; newCount = this.count + 1 ; this.count = newCount ; evictEntries ( newEntry ) ; return null ; } finally { unlock ( ) ; postWriteCleanup ( ) ; } } 
void expand ( ) { AtomicReferenceArray < ReferenceEntry < K , V > > oldTable = table ; int oldCapacity = oldTable.length ( ) ; if ( oldCapacity > = MAXIMUM_CAPACITY ) { return ; } int newCount = count ; AtomicReferenceArray < ReferenceEntry < K , V > > newTable = newEntryArray ( oldCapacity < < 1 ) ; threshold = newTable.length ( ) * 3 / 4 ; int newMask = newTable.length ( ) - 1 ; for ( int oldIndex = 0 ; oldIndex < oldCapacity ; ++oldIndex ) { ReferenceEntry < K , V > head = oldTable.get ( oldIndex ) ; if ( head != null ) { ReferenceEntry < K , V > next = head.getNext ( ) ; int headIndex = head.getHash ( ) & newMask ; if ( next == null ) { newTable.set ( headIndex , head ) ; } else { ReferenceEntry < K , V > tail = head ; int tailIndex = headIndex ; for ( ReferenceEntry < K , V > e = next ; e != null ; e = e.getNext ( ) ) { int newIndex = e.getHash ( ) & newMask ; if ( newIndex != tailIndex ) { tailIndex = newIndex ; tail = e ; } } newTable.set ( tailIndex , tail ) ; for ( ReferenceEntry < K , V > e = head ; e != tail ; e = e.getNext ( ) ) { int newIndex = e.getHash ( ) & newMask ; ReferenceEntry < K , V > newNext = newTable.get ( newIndex ) ; ReferenceEntry < K , V > newFirst = copyEntry ( e , newNext ) ; if ( newFirst != null ) { newTable.set ( newIndex , newFirst ) ; } else { removeCollectedEntry ( e ) ; newCount-- ; } } } } } table = newTable ; this.count = newCount ; } 
boolean replace ( K key , int hash , V oldValue , V newValue ) { lock ( ) ; try { long now = map.ticker.read ( ) ; preWriteCleanup ( now ) ; AtomicReferenceArray < ReferenceEntry < K , V > > table = this.table ; int index = hash & ( table.length ( ) - 1 ) ; ReferenceEntry < K , V > first = table.get ( index ) ; for ( ReferenceEntry < K , V > e = first ; e != null ; e = e.getNext ( ) ) { K entryKey = e.getKey ( ) ; if ( e.getHash ( ) == hash && entryKey != null && map.keyEquivalence.equivalent ( key , entryKey ) ) { ValueReference < K , V > valueReference = e.getValueReference ( ) ; V entryValue = valueReference.get ( ) ; if ( entryValue == null ) { if ( valueReference.isActive ( ) ) { int newCount = this.count - 1 ; ++modCount ; ReferenceEntry < K , V > newFirst = removeValueFromChain ( first , e , entryKey , hash , entryValue , valueReference , RemovalCause.COLLECTED ) ; newCount = this.count - 1 ; table.set ( index , newFirst ) ; this.count = newCount ; } return false ; } if ( map.valueEquivalence.equivalent ( oldValue , entryValue ) ) { ++modCount ; enqueueNotification ( key , hash , entryValue , valueReference.getWeight ( ) , RemovalCause.REPLACED ) ; setValue ( e , key , newValue , now ) ; evictEntries ( e ) ; return true ; } else { recordLockedRead ( e , now ) ; return false ; } } } return false ; } finally { unlock ( ) ; postWriteCleanup ( ) ; } } 
V replace ( K key , int hash , V newValue ) { lock ( ) ; try { long now = map.ticker.read ( ) ; preWriteCleanup ( now ) ; AtomicReferenceArray < ReferenceEntry < K , V > > table = this.table ; int index = hash & ( table.length ( ) - 1 ) ; ReferenceEntry < K , V > first = table.get ( index ) ; for ( ReferenceEntry < K , V > e = first ; e != null ; e = e.getNext ( ) ) { K entryKey = e.getKey ( ) ; if ( e.getHash ( ) == hash && entryKey != null && map.keyEquivalence.equivalent ( key , entryKey ) ) { ValueReference < K , V > valueReference = e.getValueReference ( ) ; V entryValue = valueReference.get ( ) ; if ( entryValue == null ) { if ( valueReference.isActive ( ) ) { int newCount = this.count - 1 ; ++modCount ; ReferenceEntry < K , V > newFirst = removeValueFromChain ( first , e , entryKey , hash , entryValue , valueReference , RemovalCause.COLLECTED ) ; newCount = this.count - 1 ; table.set ( index , newFirst ) ; this.count = newCount ; } return null ; } ++modCount ; enqueueNotification ( key , hash , entryValue , valueReference.getWeight ( ) , RemovalCause.REPLACED ) ; setValue ( e , key , newValue , now ) ; evictEntries ( e ) ; return entryValue ; } } return null ; } finally { unlock ( ) ; postWriteCleanup ( ) ; } } 
V remove ( Object key , int hash ) { lock ( ) ; try { long now = map.ticker.read ( ) ; preWriteCleanup ( now ) ; int newCount = this.count - 1 ; AtomicReferenceArray < ReferenceEntry < K , V > > table = this.table ; int index = hash & ( table.length ( ) - 1 ) ; ReferenceEntry < K , V > first = table.get ( index ) ; for ( ReferenceEntry < K , V > e = first ; e != null ; e = e.getNext ( ) ) { K entryKey = e.getKey ( ) ; if ( e.getHash ( ) == hash && entryKey != null && map.keyEquivalence.equivalent ( key , entryKey ) ) { ValueReference < K , V > valueReference = e.getValueReference ( ) ; V entryValue = valueReference.get ( ) ; RemovalCause cause ; if ( entryValue != null ) { cause = RemovalCause.EXPLICIT ; } else if ( valueReference.isActive ( ) ) { cause = RemovalCause.COLLECTED ; } else { return null ; } ++modCount ; ReferenceEntry < K , V > newFirst = removeValueFromChain ( first , e , entryKey , hash , entryValue , valueReference , cause ) ; newCount = this.count - 1 ; table.set ( index , newFirst ) ; this.count = newCount ; return entryValue ; } } return null ; } finally { unlock ( ) ; postWriteCleanup ( ) ; } } 
boolean remove ( Object key , int hash , Object value ) { lock ( ) ; try { long now = map.ticker.read ( ) ; preWriteCleanup ( now ) ; int newCount = this.count - 1 ; AtomicReferenceArray < ReferenceEntry < K , V > > table = this.table ; int index = hash & ( table.length ( ) - 1 ) ; ReferenceEntry < K , V > first = table.get ( index ) ; for ( ReferenceEntry < K , V > e = first ; e != null ; e = e.getNext ( ) ) { K entryKey = e.getKey ( ) ; if ( e.getHash ( ) == hash && entryKey != null && map.keyEquivalence.equivalent ( key , entryKey ) ) { ValueReference < K , V > valueReference = e.getValueReference ( ) ; V entryValue = valueReference.get ( ) ; RemovalCause cause ; if ( map.valueEquivalence.equivalent ( value , entryValue ) ) { cause = RemovalCause.EXPLICIT ; } else if ( entryValue == null && valueReference.isActive ( ) ) { cause = RemovalCause.COLLECTED ; } else { return false ; } ++modCount ; ReferenceEntry < K , V > newFirst = removeValueFromChain ( first , e , entryKey , hash , entryValue , valueReference , cause ) ; newCount = this.count - 1 ; table.set ( index , newFirst ) ; this.count = newCount ; return ( cause == RemovalCause.EXPLICIT ) ; } } return false ; } finally { unlock ( ) ; postWriteCleanup ( ) ; } } 
boolean storeLoadedValue ( K key , int hash , LoadingValueReference < K , V > oldValueReference , V newValue ) { lock ( ) ; try { long now = map.ticker.read ( ) ; preWriteCleanup ( now ) ; int newCount = this.count + 1 ; if ( newCount > this.threshold ) { expand ( ) ; newCount = this.count + 1 ; } AtomicReferenceArray < ReferenceEntry < K , V > > table = this.table ; int index = hash & ( table.length ( ) - 1 ) ; ReferenceEntry < K , V > first = table.get ( index ) ; for ( ReferenceEntry < K , V > e = first ; e != null ; e = e.getNext ( ) ) { K entryKey = e.getKey ( ) ; if ( e.getHash ( ) == hash && entryKey != null && map.keyEquivalence.equivalent ( key , entryKey ) ) { ValueReference < K , V > valueReference = e.getValueReference ( ) ; V entryValue = valueReference.get ( ) ; if ( oldValueReference == valueReference || ( entryValue == null && valueReference != UNSET ) ) { ++modCount ; if ( oldValueReference.isActive ( ) ) { RemovalCause cause = ( entryValue == null ) ? RemovalCause.COLLECTED : RemovalCause.REPLACED ; enqueueNotification ( key , hash , entryValue , oldValueReference.getWeight ( ) , cause ) ; newCount-- ; } setValue ( e , key , newValue , now ) ; this.count = newCount ; evictEntries ( e ) ; return true ; } enqueueNotification ( key , hash , newValue , 0 , RemovalCause.REPLACED ) ; return false ; } } ++modCount ; ReferenceEntry < K , V > newEntry = newEntry ( key , hash , first ) ; setValue ( newEntry , key , newValue , now ) ; table.set ( index , newEntry ) ; this.count = newCount ; evictEntries ( newEntry ) ; return true ; } finally { unlock ( ) ; postWriteCleanup ( ) ; } } 
void clear ( ) { if ( count != 0 ) { lock ( ) ; try { long now = map.ticker.read ( ) ; preWriteCleanup ( now ) ; AtomicReferenceArray < ReferenceEntry < K , V > > table = this.table ; for ( int i = 0 ; i < table.length ( ) ; ++i ) { for ( ReferenceEntry < K , V > e = table.get ( i ) ; e != null ; e = e.getNext ( ) ) { if ( e.getValueReference ( ) .isActive ( ) ) { K key = e.getKey ( ) ; V value = e.getValueReference ( ) .get ( ) ; RemovalCause cause = ( key == null || value == null ) ? RemovalCause.COLLECTED : RemovalCause.EXPLICIT ; enqueueNotification ( key , e.getHash ( ) , value , e.getValueReference ( ) .getWeight ( ) , cause ) ; } } } for ( int i = 0 ; i < table.length ( ) ; ++i ) { table.set ( i , null ) ; } clearReferenceQueues ( ) ; writeQueue.clear ( ) ; accessQueue.clear ( ) ; readCount.set ( 0 ) ; ++modCount ; count = 0 ; } finally { unlock ( ) ; postWriteCleanup ( ) ; } } } 
ReferenceEntry < K , V > removeValueFromChain ( ReferenceEntry < K , V > first , ReferenceEntry < K , V > entry , @Nullable K key , int hash , V value , ValueReference < K , V > valueReference , RemovalCause cause ) { enqueueNotification ( key , hash , value , valueReference.getWeight ( ) , cause ) ; writeQueue.remove ( entry ) ; accessQueue.remove ( entry ) ; if ( valueReference.isLoading ( ) ) { valueReference.notifyNewValue ( null ) ; return first ; } else { return removeEntryFromChain ( first , entry ) ; } } 
ReferenceEntry < K , V > removeEntryFromChain ( ReferenceEntry < K , V > first , ReferenceEntry < K , V > entry ) { int newCount = count ; ReferenceEntry < K , V > newFirst = entry.getNext ( ) ; for ( ReferenceEntry < K , V > e = first ; e != entry ; e = e.getNext ( ) ) { ReferenceEntry < K , V > next = copyEntry ( e , newFirst ) ; if ( next != null ) { newFirst = next ; } else { removeCollectedEntry ( e ) ; newCount-- ; } } this.count = newCount ; return newFirst ; } 
boolean reclaimKey ( ReferenceEntry < K , V > entry , int hash ) { lock ( ) ; try { int newCount = count - 1 ; AtomicReferenceArray < ReferenceEntry < K , V > > table = this.table ; int index = hash & ( table.length ( ) - 1 ) ; ReferenceEntry < K , V > first = table.get ( index ) ; for ( ReferenceEntry < K , V > e = first ; e != null ; e = e.getNext ( ) ) { if ( e == entry ) { ++modCount ; ReferenceEntry < K , V > newFirst = removeValueFromChain ( first , e , e.getKey ( ) , hash , e.getValueReference ( ) .get ( ) , e.getValueReference ( ) , RemovalCause.COLLECTED ) ; newCount = this.count - 1 ; table.set ( index , newFirst ) ; this.count = newCount ; return true ; } } return false ; } finally { unlock ( ) ; postWriteCleanup ( ) ; } } 
boolean reclaimValue ( K key , int hash , ValueReference < K , V > valueReference ) { lock ( ) ; try { int newCount = this.count - 1 ; AtomicReferenceArray < ReferenceEntry < K , V > > table = this.table ; int index = hash & ( table.length ( ) - 1 ) ; ReferenceEntry < K , V > first = table.get ( index ) ; for ( ReferenceEntry < K , V > e = first ; e != null ; e = e.getNext ( ) ) { K entryKey = e.getKey ( ) ; if ( e.getHash ( ) == hash && entryKey != null && map.keyEquivalence.equivalent ( key , entryKey ) ) { ValueReference < K , V > v = e.getValueReference ( ) ; if ( v == valueReference ) { ++modCount ; ReferenceEntry < K , V > newFirst = removeValueFromChain ( first , e , entryKey , hash , valueReference.get ( ) , valueReference , RemovalCause.COLLECTED ) ; newCount = this.count - 1 ; table.set ( index , newFirst ) ; this.count = newCount ; return true ; } return false ; } } return false ; } finally { unlock ( ) ; if ( !isHeldByCurrentThread ( ) ) { postWriteCleanup ( ) ; } } } 
boolean removeLoadingValue ( K key , int hash , LoadingValueReference < K , V > valueReference ) { lock ( ) ; try { AtomicReferenceArray < ReferenceEntry < K , V > > table = this.table ; int index = hash & ( table.length ( ) - 1 ) ; ReferenceEntry < K , V > first = table.get ( index ) ; for ( ReferenceEntry < K , V > e = first ; e != null ; e = e.getNext ( ) ) { K entryKey = e.getKey ( ) ; if ( e.getHash ( ) == hash && entryKey != null && map.keyEquivalence.equivalent ( key , entryKey ) ) { ValueReference < K , V > v = e.getValueReference ( ) ; if ( v == valueReference ) { if ( valueReference.isActive ( ) ) { e.setValueReference ( valueReference.getOldValue ( ) ) ; } else { ReferenceEntry < K , V > newFirst = removeEntryFromChain ( first , e ) ; table.set ( index , newFirst ) ; } return true ; } return false ; } } return false ; } finally { unlock ( ) ; postWriteCleanup ( ) ; } } 
boolean removeEntry ( ReferenceEntry < K , V > entry , int hash , RemovalCause cause ) { int newCount = this.count - 1 ; AtomicReferenceArray < ReferenceEntry < K , V > > table = this.table ; int index = hash & ( table.length ( ) - 1 ) ; ReferenceEntry < K , V > first = table.get ( index ) ; for ( ReferenceEntry < K , V > e = first ; e != null ; e = e.getNext ( ) ) { if ( e == entry ) { ++modCount ; ReferenceEntry < K , V > newFirst = removeValueFromChain ( first , e , e.getKey ( ) , hash , e.getValueReference ( ) .get ( ) , e.getValueReference ( ) , cause ) ; newCount = this.count - 1 ; table.set ( index , newFirst ) ; this.count = newCount ; return true ; } } return false ; } 
public ListenableFuture < V > loadFuture ( K key , CacheLoader < ? super K , V > loader ) { try { stopwatch.start ( ) ; V previousValue = oldValue.get ( ) ; if ( previousValue == null ) { V newValue = loader.load ( key ) ; return set ( newValue ) ? futureValue : Futures.immediateFuture ( newValue ) ; } ListenableFuture < V > newValue = loader.reload ( key , previousValue ) ; if ( newValue == null ) { return Futures.immediateFuture ( null ) ; } return transform ( newValue , new com.google.common.base.Function < V , V > ( ) { @Override public V apply ( V newValue ) { LoadingValueReference.this.set ( newValue ) ; return newValue ; } } , directExecutor ( ) ) ; } catch ( Throwable t ) { ListenableFuture < V > result = setException ( t ) ? futureValue : fullyFailedFuture ( t ) ; if ( t instanceof InterruptedException ) { Thread.currentThread ( ) .interrupt ( ) ; } return result ; } } 
public V compute ( K key , BiFunction < ? super K , ? super V , ? extends V > function ) { stopwatch.start ( ) ; V previousValue ; try { previousValue = oldValue.waitForValue ( ) ; } catch ( ExecutionException e ) { previousValue = null ; } V newValue ; try { newValue = function.apply ( key , previousValue ) ; } catch ( Throwable th ) { this.setException ( th ) ; throw th ; } this.set ( newValue ) ; return newValue ; } 
public Iterator < ReferenceEntry < K , V > > iterator ( ) { return new AbstractSequentialIterator < ReferenceEntry < K , V > > ( peek ( ) ) { @Override protected ReferenceEntry < K , V > computeNext ( ReferenceEntry < K , V > previous ) { ReferenceEntry < K , V > next = previous.getNextInWriteQueue ( ) ; return ( next == head ) ? null : next ; } } ; } 
protected ReferenceEntry < K , V > computeNext ( ReferenceEntry < K , V > previous ) { ReferenceEntry < K , V > next = previous.getNextInWriteQueue ( ) ; return ( next == head ) ? null : next ; } 
public Iterator < ReferenceEntry < K , V > > iterator ( ) { return new AbstractSequentialIterator < ReferenceEntry < K , V > > ( peek ( ) ) { @Override protected ReferenceEntry < K , V > computeNext ( ReferenceEntry < K , V > previous ) { ReferenceEntry < K , V > next = previous.getNextInAccessQueue ( ) ; return ( next == head ) ? null : next ; } } ; } 
public boolean isEmpty ( ) { long sum = 0L ; Segment < K , V > [] segments = this.segments ; for ( int i = 0 ; i < segments.length ; ++i ) { if ( segments[i].count != 0 ) { return false ; } sum += segments[i].modCount ; } if ( sum != 0L ) { for ( int i = 0 ; i < segments.length ; ++i ) { if ( segments[i].count != 0 ) { return false ; } sum -= segments[i].modCount ; } if ( sum != 0L ) { return false ; } } return true ; } 
ImmutableMap < K , V > getAllPresent ( Iterable < ? > keys ) { int hits = 0 ; int misses = 0 ; Map < K , V > result = Maps.newLinkedHashMap ( ) ; for ( Object key : keys ) { V value = get ( key ) ; if ( value == null ) { misses++ ; } else { @SuppressWarnings ( " unchecked " ) K castKey = ( K ) key ; result.put ( castKey , value ) ; hits++ ; } } globalStatsCounter.recordHits ( hits ) ; globalStatsCounter.recordMisses ( misses ) ; return ImmutableMap.copyOf ( result ) ; } 
ImmutableMap < K , V > getAll ( Iterable < ? extends K > keys ) throws ExecutionException { int hits = 0 ; int misses = 0 ; Map < K , V > result = Maps.newLinkedHashMap ( ) ; Set < K > keysToLoad = Sets.newLinkedHashSet ( ) ; for ( K key : keys ) { V value = get ( key ) ; if ( !result.containsKey ( key ) ) { result.put ( key , value ) ; if ( value == null ) { misses++ ; keysToLoad.add ( key ) ; } else { hits++ ; } } } try { if ( !keysToLoad.isEmpty ( ) ) { try { Map < K , V > newEntries = loadAll ( keysToLoad , defaultLoader ) ; for ( K key : keysToLoad ) { V value = newEntries.get ( key ) ; if ( value == null ) { throw new InvalidCacheLoadException ( " loadAll failed to return a value for " + key ) ; } result.put ( key , value ) ; } } catch ( UnsupportedLoadingOperationException e ) { for ( K key : keysToLoad ) { misses-- ; result.put ( key , get ( key , defaultLoader ) ) ; } } } return ImmutableMap.copyOf ( result ) ; } finally { globalStatsCounter.recordHits ( hits ) ; globalStatsCounter.recordMisses ( misses ) ; } } 
Map < K , V > loadAll ( Set < ? extends K > keys , CacheLoader < ? super K , V > loader ) throws ExecutionException { checkNotNull ( loader ) ; checkNotNull ( keys ) ; Stopwatch stopwatch = Stopwatch.createStarted ( ) ; Map < K , V > result ; boolean success = false ; try { @SuppressWarnings ( " unchecked " ) Map < K , V > map = ( Map < K , V > ) loader.loadAll ( keys ) ; result = map ; success = true ; } catch ( UnsupportedLoadingOperationException e ) { success = true ; throw e ; } catch ( InterruptedException e ) { Thread.currentThread ( ) .interrupt ( ) ; throw new ExecutionException ( e ) ; } catch ( RuntimeException e ) { throw new UncheckedExecutionException ( e ) ; } catch ( Exception e ) { throw new ExecutionException ( e ) ; } catch ( Error e ) { throw new ExecutionError ( e ) ; } finally { if ( !success ) { globalStatsCounter.recordLoadException ( stopwatch.elapsed ( NANOSECONDS ) ) ; } } if ( result == null ) { globalStatsCounter.recordLoadException ( stopwatch.elapsed ( NANOSECONDS ) ) ; throw new InvalidCacheLoadException ( loader + " returned null map from loadAll " ) ; } stopwatch.stop ( ) ; boolean nullsPresent = false ; for ( Entry < K , V > entry : result.entrySet ( ) ) { K key = entry.getKey ( ) ; V value = entry.getValue ( ) ; if ( key == null || value == null ) { nullsPresent = true ; } else { put ( key , value ) ; } } if ( nullsPresent ) { globalStatsCounter.recordLoadException ( stopwatch.elapsed ( NANOSECONDS ) ) ; throw new InvalidCacheLoadException ( loader + " returned null keys or values from loadAll " ) ; } globalStatsCounter.recordLoadSuccess ( stopwatch.elapsed ( NANOSECONDS ) ) ; return result ; } 
ReferenceEntry < K , V > getEntry ( @Nullable Object key ) { if ( key == null ) { return null ; } int hash = hash ( key ) ; return segmentFor ( hash ) .getEntry ( key , hash ) ; } 
public boolean containsValue ( @Nullable Object value ) { if ( value == null ) { return false ; } long now = ticker.read ( ) ; final Segment < K , V > [] segments = this.segments ; long last = -1L ; for ( int i = 0 ; i < CONTAINS_VALUE_RETRIES ; i++ ) { long sum = 0L ; for ( Segment < K , V > segment : segments ) { int unused = segment.count ; AtomicReferenceArray < ReferenceEntry < K , V > > table = segment.table ; for ( int j = 0 ; j < table.length ( ) ; j++ ) { for ( ReferenceEntry < K , V > e = table.get ( j ) ; e != null ; e = e.getNext ( ) ) { V v = segment.getLiveValue ( e , now ) ; if ( v != null && valueEquivalence.equivalent ( value , v ) ) { return true ; } } } sum += segment.modCount ; } if ( sum == last ) { break ; } last = sum ; } return false ; } 
final void advance ( ) { nextExternal = null ; if ( nextInChain ( ) ) { return ; } if ( nextInTable ( ) ) { return ; } while ( nextSegmentIndex > = 0 ) { currentSegment = segments[nextSegmentIndex--] ; if ( currentSegment.count != 0 ) { currentTable = currentSegment.table ; nextTableIndex = currentTable.length ( ) - 1 ; if ( nextInTable ( ) ) { return ; } } } } 
boolean advanceTo ( ReferenceEntry < K , V > entry ) { try { long now = ticker.read ( ) ; K key = entry.getKey ( ) ; V value = getLiveValue ( entry , now ) ; if ( value != null ) { nextExternal = new WriteThroughEntry ( key , value ) ; return true ; } else { return false ; } } finally { currentSegment.postReadCleanup ( ) ; } } 
public boolean contains ( Object o ) { if ( ! ( o instanceof Entry ) ) { return false ; } Entry < ? , ? > e = ( Entry < ? , ? > ) o ; Object key = e.getKey ( ) ; if ( key == null ) { return false ; } V v = LocalCache.this.get ( key ) ; return v != null && valueEquivalence.equivalent ( e.getValue ( ) , v ) ; } 
CacheBuilder < K , V > recreateCacheBuilder ( ) { CacheBuilder < K , V > builder = CacheBuilder.newBuilder ( ) .setKeyStrength ( keyStrength ) .setValueStrength ( valueStrength ) .keyEquivalence ( keyEquivalence ) .valueEquivalence ( valueEquivalence ) .concurrencyLevel ( concurrencyLevel ) .removalListener ( removalListener ) ; builder.strictParsing = false ; if ( expireAfterWriteNanos > 0 ) { builder.expireAfterWrite ( expireAfterWriteNanos , TimeUnit.NANOSECONDS ) ; } if ( expireAfterAccessNanos > 0 ) { builder.expireAfterAccess ( expireAfterAccessNanos , TimeUnit.NANOSECONDS ) ; } if ( weigher != OneWeigher.INSTANCE ) { builder.weigher ( weigher ) ; if ( maxWeight != UNSET_INT ) { builder.maximumWeight ( maxWeight ) ; } } else { if ( maxWeight != UNSET_INT ) { builder.maximumSize ( maxWeight ) ; } } if ( ticker != null ) { builder.ticker ( ticker ) ; } return builder ; } 
public V get ( K key , final Callable < ? extends V > valueLoader ) throws ExecutionException { checkNotNull ( valueLoader ) ; return localCache.get ( key , new CacheLoader < Object , V > ( ) { @Override public V load ( Object key ) throws Exception { return valueLoader.call ( ) ; } } ) ; } 
public void add ( long x ) { Cell[] as ; long b , v ; int[] hc ; Cell a ; int n ; if ( ( as = cells ) != null || !casBase ( b = base , b + x ) ) { boolean uncontended = true ; if ( ( hc = threadHashCode.get ( ) ) == null || as == null || ( n = as.length ) < 1 || ( a = as[ ( n - 1 ) & hc[0]] ) == null || ! ( uncontended = a.cas ( v = a.value , v + x ) ) ) retryUpdate ( x , hc , uncontended ) ; } } 
public long sum ( ) { long sum = base ; Cell[] as = cells ; if ( as != null ) { int n = as.length ; for ( int i = 0 ; i < n ; ++i ) { Cell a = as[i] ; if ( a != null ) sum += a.value ; } } return sum ; } 
public long sumThenReset ( ) { long sum = base ; Cell[] as = cells ; base = 0L ; if ( as != null ) { int n = as.length ; for ( int i = 0 ; i < n ; ++i ) { Cell a = as[i] ; if ( a != null ) { sum += a.value ; a.value = 0L ; } } } return sum ; } 
public static < K , V > RemovalListener < K , V > asynchronous ( final RemovalListener < K , V > listener , final Executor executor ) { checkNotNull ( listener ) ; checkNotNull ( executor ) ; return new RemovalListener < K , V > ( ) { @Override public void onRemoval ( final RemovalNotification < K , V > notification ) { executor.execute ( new Runnable ( ) { @Override public void run ( ) { listener.onRemoval ( notification ) ; } } ) ; } } ; } 
public void onRemoval ( final RemovalNotification < K , V > notification ) { executor.execute ( new Runnable ( ) { @Override public void run ( ) { listener.onRemoval ( notification ) ; } } ) ; } 
final void retryUpdate ( long x , int[] hc , boolean wasUncontended ) { int h ; if ( hc == null ) { threadHashCode.set ( hc = new int[1] ) ; int r = rng.nextInt ( ) ; h = hc[0] = ( r == 0 ) ? 1 : r ; } else h = hc[0] ; boolean collide = false ; for ( ; ; ) { Cell[] as ; Cell a ; int n ; long v ; if ( ( as = cells ) != null && ( n = as.length ) > 0 ) { if ( ( a = as[ ( n - 1 ) & h] ) == null ) { if ( busy == 0 ) { Cell r = new Cell ( x ) ; if ( busy == 0 && casBusy ( ) ) { boolean created = false ; try { Cell[] rs ; int m , j ; if ( ( rs = cells ) != null && ( m = rs.length ) > 0 && rs[j = ( m - 1 ) & h] == null ) { rs[j] = r ; created = true ; } } finally { busy = 0 ; } if ( created ) break ; continue ; } } collide = false ; } else if ( !wasUncontended ) wasUncontended = true ; else if ( a.cas ( v = a.value , fn ( v , x ) ) ) break ; else if ( n > = NCPU || cells != as ) collide = false ; else if ( !collide ) collide = true ; else if ( busy == 0 && casBusy ( ) ) { try { if ( cells == as ) { Cell[] rs = new Cell[n < < 1] ; for ( int i = 0 ; i < n ; ++i ) rs[i] = as[i] ; cells = rs ; } } finally { busy = 0 ; } collide = false ; continue ; } h ^= h < < 13 ; h ^= h > > > 17 ; h ^= h < < 5 ; hc[0] = h ; } else if ( busy == 0 && cells == as && casBusy ( ) ) { boolean init = false ; try { if ( cells == as ) { Cell[] rs = new Cell[2] ; rs[h & 1] = new Cell ( x ) ; cells = rs ; init = true ; } } finally { busy = 0 ; } if ( init ) break ; } else if ( casBase ( v = base , fn ( v , x ) ) ) break ; } } 
private static sun.misc.Unsafe getUnsafe ( ) { try { return sun.misc.Unsafe.getUnsafe ( ) ; } catch ( SecurityException tryReflectionInstead ) { } try { return java.security.AccessController.doPrivileged ( new java.security.PrivilegedExceptionAction < sun.misc.Unsafe > ( ) { @Override public sun.misc.Unsafe run ( ) throws Exception { Class < sun.misc.Unsafe > k = sun.misc.Unsafe.class ; for ( java.lang.reflect.Field f : k.getDeclaredFields ( ) ) { f.setAccessible ( true ) ; Object x = f.get ( null ) ; if ( k.isInstance ( x ) ) return k.cast ( x ) ; } throw new NoSuchFieldError ( " the Unsafe " ) ; } } ) ; } catch ( java.security.PrivilegedActionException e ) { throw new RuntimeException ( " Could not initialize intrinsics " , e.getCause ( ) ) ; } } 
private V putInBothMaps ( @Nullable K key , @Nullable V value , boolean force ) { checkKey ( key ) ; checkValue ( value ) ; boolean containedKey = containsKey ( key ) ; if ( containedKey && Objects.equal ( value , get ( key ) ) ) { return value ; } if ( force ) { inverse ( ) .remove ( value ) ; } else { checkArgument ( !containsValue ( value ) , " value already present: %s " , value ) ; } V oldValue = delegate.put ( key , value ) ; updateInverseMap ( key , containedKey , oldValue , value ) ; return oldValue ; } 
public void replaceAll ( BiFunction < ? super K , ? super V , ? extends V > function ) { this.delegate.replaceAll ( function ) ; inverse.delegate.clear ( ) ; Entry < K , V > broken = null ; Iterator < Entry < K , V > > itr = this.delegate.entrySet ( ) .iterator ( ) ; while ( itr.hasNext ( ) ) { Entry < K , V > entry = itr.next ( ) ; K k = entry.getKey ( ) ; V v = entry.getValue ( ) ; K conflict = inverse.delegate.putIfAbsent ( v , k ) ; if ( conflict != null ) { broken = entry ; itr.remove ( ) ; } } if ( broken != null ) { throw new IllegalArgumentException ( " value already present: " + broken.getValue ( ) ) ; } } 
Iterator < Entry < K , V > > entrySetIterator ( ) { final Iterator < Entry < K , V > > iterator = delegate.entrySet ( ) .iterator ( ) ; return new Iterator < Entry < K , V > > ( ) { @Nullable Entry < K , V > entry ; @Override public boolean hasNext ( ) { return iterator.hasNext ( ) ; } @Override public Entry < K , V > next ( ) { entry = iterator.next ( ) ; return new BiMapEntry ( entry ) ; } @Override public void remove ( ) { checkRemove ( entry != null ) ; V value = entry.getValue ( ) ; iterator.remove ( ) ; removeFromInverseMap ( value ) ; entry = null ; } } ; } 
public final boolean hasNext ( ) { checkState ( state != State.FAILED ) ; switch ( state ) { case DONE: return false ; case READY: return true ; default: } return tryToComputeNext ( ) ; } 
public boolean put ( @Nullable K key , @Nullable V value ) { Collection < V > collection = map.get ( key ) ; if ( collection == null ) { collection = createCollection ( key ) ; if ( collection.add ( value ) ) { totalSize++ ; map.put ( key , collection ) ; return true ; } else { throw new AssertionError ( " New Collection violated the Collection spec " ) ; } } else if ( collection.add ( value ) ) { totalSize++ ; return true ; } else { return false ; } } 
public Collection < V > replaceValues ( @Nullable K key , Iterable < ? extends V > values ) { Iterator < ? extends V > iterator = values.iterator ( ) ; if ( !iterator.hasNext ( ) ) { return removeAll ( key ) ; } Collection < V > collection = getOrCreateCollection ( key ) ; Collection < V > oldValues = createCollection ( ) ; oldValues.addAll ( collection ) ; totalSize -= collection.size ( ) ; collection.clear ( ) ; while ( iterator.hasNext ( ) ) { if ( collection.add ( iterator.next ( ) ) ) { totalSize++ ; } } return unmodifiableCollectionSubclass ( oldValues ) ; } 
public Iterator < K > iterator ( ) { final Iterator < Entry < K , Collection < V > > > entryIterator = map ( ) .entrySet ( ) .iterator ( ) ; return new Iterator < K > ( ) { @Nullable Entry < K , Collection < V > > entry ; @Override public boolean hasNext ( ) { return entryIterator.hasNext ( ) ; } @Override public K next ( ) { entry = entryIterator.next ( ) ; return entry.getKey ( ) ; } @Override public void remove ( ) { checkRemove ( entry != null ) ; Collection < V > collection = entry.getValue ( ) ; entryIterator.remove ( ) ; totalSize -= collection.size ( ) ; collection.clear ( ) ; entry = null ; } } ; } 
public NavigableSet < K > subSet ( K fromElement , boolean fromInclusive , K toElement , boolean toInclusive ) { return new NavigableKeySet ( sortedMap ( ) .subMap ( fromElement , fromInclusive , toElement , toInclusive ) ) ; }
Iterator < V > valueIterator ( ) { return new Itr < V > ( ) { @Override V output ( K key , V value ) { return value ; } } ; }
Iterator < Entry < K , V > > entryIterator ( ) { return new Itr < Entry < K , V > > ( ) { @Override Entry < K , V > output ( K key , V value ) { return Maps.immutableEntry ( key , value ) ; } } ; } 
public NavigableMap < K , Collection < V > > subMap ( K fromKey , boolean fromInclusive , K toKey , boolean toInclusive ) { return new NavigableAsMap ( sortedMap ( ) .subMap ( fromKey , fromInclusive , toKey , toInclusive ) ) ; }
Iterator < E > elementIterator ( ) { final Iterator < Map.Entry < E , Count > > backingEntries = backingMap.entrySet ( ) .iterator ( ) ; return new Iterator < E > ( ) { Map.@Nullable Entry < E , Count > toRemove ; @Override public boolean hasNext ( ) { return backingEntries.hasNext ( ) ; } @Override public E next ( ) { final Map.Entry < E , Count > mapEntry = backingEntries.next ( ) ; toRemove = mapEntry ; return mapEntry.getKey ( ) ; } @Override public void remove ( ) { checkRemove ( toRemove != null ) ; size -= toRemove.getValue ( ) .getAndSet ( 0 ) ; backingEntries.remove ( ) ; toRemove = null ; } } ; } 
Iterator < Entry < E > > entryIterator ( ) { final Iterator < Map.Entry < E , Count > > backingEntries = backingMap.entrySet ( ) .iterator ( ) ; return new Iterator < Multiset.Entry < E > > ( ) { Map.@Nullable Entry < E , Count > toRemove ; @Override public boolean hasNext ( ) { return backingEntries.hasNext ( ) ; } @Override public Multiset.Entry < E > next ( ) { final Map.Entry < E , Count > mapEntry = backingEntries.next ( ) ; toRemove = mapEntry ; return new Multisets.AbstractEntry < E > ( ) { @Override public E getElement ( ) { return mapEntry.getKey ( ) ; } @Override public int getCount ( ) { Count count = mapEntry.getValue ( ) ; if ( count == null || count.get ( ) == 0 ) { Count frequency = backingMap.get ( getElement ( ) ) ; if ( frequency != null ) { return frequency.get ( ) ; } } return ( count == null ) ? 0 : count.get ( ) ; } } ; } @Override public void remove ( ) { checkRemove ( toRemove != null ) ; size -= toRemove.getValue ( ) .getAndSet ( 0 ) ; backingEntries.remove ( ) ; toRemove = null ; } } ; } 
public Multiset.Entry < E > next ( ) { final Map.Entry < E , Count > mapEntry = backingEntries.next ( ) ; toRemove = mapEntry ; return new Multisets.AbstractEntry < E > ( ) { @Override public E getElement ( ) { return mapEntry.getKey ( ) ; } @Override public int getCount ( ) { Count count = mapEntry.getValue ( ) ; if ( count == null || count.get ( ) == 0 ) { Count frequency = backingMap.get ( getElement ( ) ) ; if ( frequency != null ) { return frequency.get ( ) ; } } return ( count == null ) ? 0 : count.get ( ) ; } } ; } 
public int add ( @Nullable E element , int occurrences ) { if ( occurrences == 0 ) { return count ( element ) ; } checkArgument ( occurrences > 0 , " occurrences cannot be negative: %s " , occurrences ) ; Count frequency = backingMap.get ( element ) ; int oldCount ; if ( frequency == null ) { oldCount = 0 ; backingMap.put ( element , new Count ( occurrences ) ) ; } else { oldCount = frequency.get ( ) ; long newCount = ( long ) oldCount + ( long ) occurrences ; checkArgument ( newCount < = Integer.MAX_VALUE , " too many occurrences: %s " , newCount ) ; frequency.add ( occurrences ) ; } size += occurrences ; return oldCount ; } 
public int remove ( @Nullable Object element , int occurrences ) { if ( occurrences == 0 ) { return count ( element ) ; } checkArgument ( occurrences > 0 , " occurrences cannot be negative: %s " , occurrences ) ; Count frequency = backingMap.get ( element ) ; if ( frequency == null ) { return 0 ; } int oldCount = frequency.get ( ) ; int numberRemoved ; if ( oldCount > occurrences ) { numberRemoved = occurrences ; } else { numberRemoved = oldCount ; backingMap.remove ( element ) ; } frequency.add ( -numberRemoved ) ; size -= numberRemoved ; return oldCount ; } 
public int setCount ( @Nullable E element , int count ) { checkNonnegative ( count , " count " ) ; Count existingCounter ; int oldCount ; if ( count == 0 ) { existingCounter = backingMap.remove ( element ) ; oldCount = getAndSet ( existingCounter , count ) ; } else { existingCounter = backingMap.get ( element ) ; oldCount = getAndSet ( existingCounter , count ) ; if ( existingCounter == null ) { backingMap.put ( element , new Count ( count ) ) ; } } size += ( count - oldCount ) ; return oldCount ; } 
private static int getAndSet ( @Nullable Count i , int count ) { if ( i == null ) { return 0 ; } return i.getAndSet ( count ) ; }
public SortedMultiset < E > subMultiset ( @Nullable E fromElement , BoundType fromBoundType , @Nullable E toElement , BoundType toBoundType ) { checkNotNull ( fromBoundType ) ; checkNotNull ( toBoundType ) ; return tailMultiset ( fromElement , fromBoundType ) .headMultiset ( toElement , toBoundType ) ; } 
SortedMultiset < E > createDescendingMultiset ( ) { @WeakOuter class DescendingMultisetImpl extends DescendingMultiset < E > { @Override SortedMultiset < E > forwardMultiset ( ) { return AbstractSortedMultiset.this ; } @Override Iterator < Entry < E > > entryIterator ( ) { return descendingEntryIterator ( ) ; } @Override public Iterator < E > iterator ( ) { return descendingIterator ( ) ; } } return new DescendingMultisetImpl ( ) ; } 
Iterator < V > valuesIterator ( ) { return new TransformedIterator < Cell < R , C , V > , V > ( cellSet ( ) .iterator ( ) ) { @Override V transform ( Cell < R , C , V > cell ) { return cell.getValue ( ) ; } } ; }
Entry < K , V > getEntry ( final int index ) { checkElementIndex ( index , size ( ) ) ; return new AbstractMapEntry < K , V > ( ) { @Override public K getKey ( ) { return ArrayMap.this.getKey ( index ) ; } @Override public V getValue ( ) { return ArrayMap.this.getValue ( index ) ; } @Override public V setValue ( V value ) { return ArrayMap.this.setValue ( index , value ) ; } } ; } 
public V remove ( Object key ) { throw new UnsupportedOperationException ( ) ; } 
public void clear ( ) { throw new UnsupportedOperationException ( ) ; } 
Iterator < Cell < R , C , V > > cellIterator ( ) { return new AbstractIndexedListIterator < Cell < R , C , V > > ( size ( ) ) { @Override protected Cell < R , C , V > get ( final int index ) { return getCell ( index ) ; } } ; } 
private Cell < R , C , V > getCell ( final int index ) { return new Tables.AbstractCell < R , C , V > ( ) { final int rowIndex = index / columnList.size ( ) ; final int columnIndex = index % columnList.size ( ) ; @Override public R getRowKey ( ) { return rowList.get ( rowIndex ) ; } @Override public C getColumnKey ( ) { return columnList.get ( columnIndex ) ; } @Override public V getValue ( ) { return at ( rowIndex , columnIndex ) ; } } ; } 
Iterator < V > valuesIterator ( ) { return new AbstractIndexedListIterator < V > ( size ( ) ) { @Override protected V get ( int index ) { return getValue ( index ) ; } } ; } 
static < E > List < List < E > > create ( List < ? extends List < ? extends E > > lists ) { ImmutableList.Builder < List < E > > axesBuilder = new ImmutableList.Builder < > ( lists.size ( ) ) ; for ( List < ? extends E > list : lists ) { List < E > copy = ImmutableList.copyOf ( list ) ; if ( copy.isEmpty ( ) ) { return ImmutableList.of ( ) ; } axesBuilder.add ( copy ) ; } return new CartesianList < E > ( axesBuilder.build ( ) ) ; } 
public int indexOf ( Object o ) { if ( ! ( o instanceof List ) ) { return -1 ; } List < ? > list = ( List < ? > ) o ; if ( list.size ( ) != axes.size ( ) ) { return -1 ; } ListIterator < ? > itr = list.listIterator ( ) ; int computedIndex = 0 ; while ( itr.hasNext ( ) ) { int axisIndex = itr.nextIndex ( ) ; int elemIndex = axes.get ( axisIndex ) .indexOf ( itr.next ( ) ) ; if ( elemIndex == -1 ) { return -1 ; } computedIndex += elemIndex * axesSizeProduct[axisIndex + 1] ; } return computedIndex ; } 
public ImmutableList < E > get ( final int index ) { checkElementIndex ( index , size ( ) ) ; return new ImmutableList < E > ( ) { @Override public int size ( ) { return axes.size ( ) ; } @Override public E get ( int axis ) { checkElementIndex ( axis , size ( ) ) ; int axisIndex = getAxisIndexForProductIndex ( index , axis ) ; return axes.get ( axis ) .get ( axisIndex ) ; } @Override boolean isPartialView ( ) { return true ; } } ; } 
static < T , K , V > Collector < T , ? , ImmutableBiMap < K , V > > toImmutableBiMap ( Function < ? super T , ? extends K > keyFunction , Function < ? super T , ? extends V > valueFunction ) { checkNotNull ( keyFunction ) ; checkNotNull ( valueFunction ) ; return Collector.of ( ImmutableBiMap.Builder < K , V > ::new , ( builder , input ) - > builder.put ( keyFunction.apply ( input ) , valueFunction.apply ( input ) ) , ImmutableBiMap.Builder::combine , ImmutableBiMap.Builder::build , new Collector.Characteristics[0] ) ; } 
static < T , K , V > Collector < T , ? , ImmutableMap < K , V > > toImmutableMap ( Function < ? super T , ? extends K > keyFunction , Function < ? super T , ? extends V > valueFunction ) { checkNotNull ( keyFunction ) ; checkNotNull ( valueFunction ) ; return Collector.of ( ImmutableMap.Builder < K , V > ::new , ( builder , input ) - > builder.put ( keyFunction.apply ( input ) , valueFunction.apply ( input ) ) , ImmutableMap.Builder::combine , ImmutableMap.Builder::build ) ; } 
static < T , K , V > Collector < T , ? , ImmutableSortedMap < K , V > > toImmutableSortedMap ( Comparator < ? super K > comparator , Function < ? super T , ? extends K > keyFunction , Function < ? super T , ? extends V > valueFunction ) { checkNotNull ( comparator ) ; checkNotNull ( keyFunction ) ; checkNotNull ( valueFunction ) ; return Collector.of ( ( ) - > new ImmutableSortedMap.Builder < K , V > ( comparator ) , ( builder , input ) - > builder.put ( keyFunction.apply ( input ) , valueFunction.apply ( input ) ) , ImmutableSortedMap.Builder::combine , ImmutableSortedMap.Builder::build , Collector.Characteristics.UNORDERED ) ; } 
static < E > Collector < E , ? , ImmutableSortedSet < E > > toImmutableSortedSet ( Comparator < ? super E > comparator ) { checkNotNull ( comparator ) ; return Collector.of ( ( ) - > new ImmutableSortedSet.Builder < E > ( comparator ) , ImmutableSortedSet.Builder::add , ImmutableSortedSet.Builder::combine , ImmutableSortedSet.Builder::build ) ; } 
static < E extends Comparable < ? super E > > Collector < Range < E > , ? , ImmutableRangeSet < E > > toImmutableRangeSet ( ) { return ( Collector ) TO_IMMUTABLE_RANGE_SET ; } 
static < T , K extends Comparable < ? super K > , V > Collector < T , ? , ImmutableRangeMap < K , V > > toImmutableRangeMap ( Function < ? super T , Range < K > > keyFunction , Function < ? super T , ? extends V > valueFunction ) { checkNotNull ( keyFunction ) ; checkNotNull ( valueFunction ) ; return Collector.of ( ImmutableRangeMap:: < K , V > builder , ( builder , input ) - > builder.put ( keyFunction.apply ( input ) , valueFunction.apply ( input ) ) , ImmutableRangeMap.Builder::combine , ImmutableRangeMap.Builder::build ) ; } 
private static < E > int calculateSize ( List < E > sortedInputList , Comparator < ? super E > comparator ) { int permutations = 1 ; int n = 1 ; int r = 1 ; while ( n < sortedInputList.size ( ) ) { int comparison = comparator.compare ( sortedInputList.get ( n - 1 ) , sortedInputList.get ( n ) ) ; if ( comparison < 0 ) { permutations = IntMath.saturatedMultiply ( permutations , IntMath.binomial ( n , r ) ) ; r = 0 ; if ( permutations == Integer.MAX_VALUE ) { return Integer.MAX_VALUE ; } } n++ ; r++ ; } return IntMath.saturatedMultiply ( permutations , IntMath.binomial ( n , r ) ) ; } 
void calculateNextPermutation ( ) { j = list.size ( ) - 1 ; int s = 0 ; if ( j == -1 ) { return ; } while ( true ) { int q = c[j] + o[j] ; if ( q < 0 ) { switchDirection ( ) ; continue ; } if ( q == j + 1 ) { if ( j == 0 ) { break ; } s++ ; switchDirection ( ) ; continue ; } Collections.swap ( list , j - c[j] + s , j - q + s ) ; c[j] = q ; break ; } } 
static < T > Spliterator < T > indexed ( int size , int extraCharacteristics , IntFunction < T > function , Comparator < ? super T > comparator ) { if ( comparator != null ) { checkArgument ( ( extraCharacteristics & Spliterator.SORTED ) != 0 ) ; } class WithCharacteristics implements Spliterator < T > { private final Spliterator.OfInt delegate ; WithCharacteristics ( Spliterator.OfInt delegate ) { this.delegate = delegate ; } @Override public boolean tryAdvance ( Consumer < ? super T > action ) { return delegate.tryAdvance ( ( IntConsumer ) i - > action.accept ( function.apply ( i ) ) ) ; } @Override public void forEachRemaining ( Consumer < ? super T > action ) { delegate.forEachRemaining ( ( IntConsumer ) i - > action.accept ( function.apply ( i ) ) ) ; } @Override @Nullable public Spliterator < T > trySplit ( ) { Spliterator.OfInt split = delegate.trySplit ( ) ; return ( split == null ) ? null : new WithCharacteristics ( split ) ; } @Override public long estimateSize ( ) { return delegate.estimateSize ( ) ; } @Override public int characteristics ( ) { return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED | extraCharacteristics ; } @Override public Comparator < ? super T > getComparator ( ) { if ( hasCharacteristics ( Spliterator.SORTED ) ) { return comparator ; } else { throw new IllegalStateException ( ) ; } } } return new WithCharacteristics ( IntStream.range ( 0 , size ) .spliterator ( ) ) ; } 
static < InElementT , OutElementT > Spliterator < OutElementT > map ( Spliterator < InElementT > fromSpliterator , Function < ? super InElementT , ? extends OutElementT > function ) { checkNotNull ( fromSpliterator ) ; checkNotNull ( function ) ; return new Spliterator < OutElementT > ( ) { @Override public boolean tryAdvance ( Consumer < ? super OutElementT > action ) { return fromSpliterator.tryAdvance ( fromElement - > action.accept ( function.apply ( fromElement ) ) ) ; } @Override public void forEachRemaining ( Consumer < ? super OutElementT > action ) { fromSpliterator.forEachRemaining ( fromElement - > action.accept ( function.apply ( fromElement ) ) ) ; } @Override public Spliterator < OutElementT > trySplit ( ) { Spliterator < InElementT > fromSplit = fromSpliterator.trySplit ( ) ; return ( fromSplit != null ) ? map ( fromSplit , function ) : null ; } @Override public long estimateSize ( ) { return fromSpliterator.estimateSize ( ) ; } @Override public int characteristics ( ) { return fromSpliterator.characteristics ( ) & ~ ( Spliterator.DISTINCT | Spliterator.NONNULL | Spliterator.SORTED ) ; } } ; } 
static < T > Spliterator < T > filter ( Spliterator < T > fromSpliterator , Predicate < ? super T > predicate ) { checkNotNull ( fromSpliterator ) ; checkNotNull ( predicate ) ; class Splitr implements Spliterator < T > , Consumer < T > { T holder = null ; @Override public void accept ( T t ) { this.holder = t ; } @Override public boolean tryAdvance ( Consumer < ? super T > action ) { while ( fromSpliterator.tryAdvance ( this ) ) { try { if ( predicate.test ( holder ) ) { action.accept ( holder ) ; return true ; } } finally { holder = null ; } } return false ; } @Override public Spliterator < T > trySplit ( ) { Spliterator < T > fromSplit = fromSpliterator.trySplit ( ) ; return ( fromSplit == null ) ? null : filter ( fromSplit , predicate ) ; } @Override public long estimateSize ( ) { return fromSpliterator.estimateSize ( ) / 2 ; } @Override public Comparator < ? super T > getComparator ( ) { return fromSpliterator.getComparator ( ) ; } @Override public int characteristics ( ) { return fromSpliterator.characteristics ( ) & ( Spliterator.DISTINCT | Spliterator.NONNULL | Spliterator.ORDERED | Spliterator.SORTED ) ; } } return new Splitr ( ) ; } 
public final boolean tryAdvance ( Consumer < ? super OutElementT > action ) { while ( true ) { if ( prefix != null && prefix.tryAdvance ( action ) ) { if ( estimatedSize != Long.MAX_VALUE ) { estimatedSize-- ; } return true ; } else { prefix = null ; } if ( !from.tryAdvance ( fromElement - > prefix = function.apply ( fromElement ) ) ) { return false ; } } } 
public final OutSpliteratorT trySplit ( ) { Spliterator < InElementT > fromSplit = from.trySplit ( ) ; if ( fromSplit != null ) { int splitCharacteristics = characteristics & ~Spliterator.SIZED ; long estSplitSize = estimateSize ( ) ; if ( estSplitSize < Long.MAX_VALUE ) { estSplitSize /= 2 ; this.estimatedSize -= estSplitSize ; this.characteristics = splitCharacteristics ; } OutSpliteratorT result = factory.newFlatMapSpliterator ( this.prefix , fromSplit , function , splitCharacteristics , estSplitSize ) ; this.prefix = null ; return result ; } else if ( prefix != null ) { OutSpliteratorT result = prefix ; this.prefix = null ; return result ; } else { return null ; } } 
public V put ( @Nullable K key , @Nullable V value ) { if ( needsAllocArrays ( ) ) { allocArrays ( ) ; } long[] entries = this.entries ; Object[] keys = this.keys ; Object[] values = this.values ; int hash = smearedHash ( key ) ; int tableIndex = hash & hashTableMask ( ) ; int newEntryIndex = this.size ; int next = table[tableIndex] ; if ( next == UNSET ) { table[tableIndex] = newEntryIndex ; } else { int last ; long entry ; do { last = next ; entry = entries[next] ; if ( getHash ( entry ) == hash && Objects.equal ( key , keys[next] ) ) { @SuppressWarnings ( " unchecked " ) @Nullable V oldValue = ( V ) values[next] ; values[next] = value ; accessEntry ( next ) ; return oldValue ; } next = getNext ( entry ) ; } while ( next != UNSET ) ; entries[last] = swapNext ( entry , newEntryIndex ) ; } if ( newEntryIndex == Integer.MAX_VALUE ) { throw new IllegalStateException ( " Cannot contain more than Integer.MAX_VALUE elements! " ) ; } int newSize = newEntryIndex + 1 ; resizeMeMaybe ( newSize ) ; insertEntry ( newEntryIndex , key , value , hash ) ; this.size = newSize ; int oldCapacity = table.length ; if ( Hashing.needsResizing ( newEntryIndex , oldCapacity , LOAD_FACTOR ) ) { resizeTable ( 2 * oldCapacity ) ; } modCount++ ; return null ; } 
private V remove ( @Nullable Object key , int hash ) { int tableIndex = hash & hashTableMask ( ) ; int next = table[tableIndex] ; if ( next == UNSET ) { return null ; } int last = UNSET ; do { if ( getHash ( entries[next] ) == hash && Objects.equal ( key , keys[next] ) ) { @SuppressWarnings ( " unchecked " ) @Nullable V oldValue = ( V ) values[next] ; if ( last == UNSET ) { table[tableIndex] = getNext ( entries[next] ) ; } else { entries[last] = swapNext ( entries[last] , getNext ( entries[next] ) ) ; } moveLastEntry ( next ) ; size-- ; modCount++ ; return oldValue ; } last = next ; next = getNext ( entries[next] ) ; } while ( next != UNSET ) ; return null ; } 
void moveLastEntry ( int dstIndex ) { int srcIndex = size ( ) - 1 ; if ( dstIndex < srcIndex ) { keys[dstIndex] = keys[srcIndex] ; values[dstIndex] = values[srcIndex] ; keys[srcIndex] = null ; values[srcIndex] = null ; long lastEntry = entries[srcIndex] ; entries[dstIndex] = lastEntry ; entries[srcIndex] = UNSET ; int tableIndex = getHash ( lastEntry ) & hashTableMask ( ) ; int lastNext = table[tableIndex] ; if ( lastNext == srcIndex ) { table[tableIndex] = dstIndex ; } else { int previous ; long entry ; do { previous = lastNext ; lastNext = getNext ( entry = entries[lastNext] ) ; } while ( lastNext != srcIndex ) ; entries[previous] = swapNext ( entry , dstIndex ) ; } } else { keys[dstIndex] = null ; values[dstIndex] = null ; entries[dstIndex] = UNSET ; } } 
public boolean add ( @Nullable E object ) { if ( needsAllocArrays ( ) ) { allocArrays ( ) ; } long[] entries = this.entries ; Object[] elements = this.elements ; int hash = smearedHash ( object ) ; int tableIndex = hash & hashTableMask ( ) ; int newEntryIndex = this.size ; int next = table[tableIndex] ; if ( next == UNSET ) { table[tableIndex] = newEntryIndex ; } else { int last ; long entry ; do { last = next ; entry = entries[next] ; if ( getHash ( entry ) == hash && Objects.equal ( object , elements[next] ) ) { return false ; } next = getNext ( entry ) ; } while ( next != UNSET ) ; entries[last] = swapNext ( entry , newEntryIndex ) ; } if ( newEntryIndex == Integer.MAX_VALUE ) { throw new IllegalStateException ( " Cannot contain more than Integer.MAX_VALUE elements! " ) ; } int newSize = newEntryIndex + 1 ; resizeMeMaybe ( newSize ) ; insertEntry ( newEntryIndex , object , hash ) ; this.size = newSize ; int oldCapacity = table.length ; if ( Hashing.needsResizing ( newEntryIndex , oldCapacity , LOAD_FACTOR ) ) { resizeTable ( 2 * oldCapacity ) ; } modCount++ ; return true ; } 
private boolean remove ( Object object , int hash ) { int tableIndex = hash & hashTableMask ( ) ; int next = table[tableIndex] ; if ( next == UNSET ) { return false ; } int last = UNSET ; do { if ( getHash ( entries[next] ) == hash && Objects.equal ( object , elements[next] ) ) { if ( last == UNSET ) { table[tableIndex] = getNext ( entries[next] ) ; } else { entries[last] = swapNext ( entries[last] , getNext ( entries[next] ) ) ; } moveLastEntry ( next ) ; size-- ; modCount++ ; return true ; } last = next ; next = getNext ( entries[next] ) ; } while ( next != UNSET ) ; return false ; } 
void moveLastEntry ( int dstIndex ) { int srcIndex = size ( ) - 1 ; if ( dstIndex < srcIndex ) { elements[dstIndex] = elements[srcIndex] ; elements[srcIndex] = null ; long lastEntry = entries[srcIndex] ; entries[dstIndex] = lastEntry ; entries[srcIndex] = UNSET ; int tableIndex = getHash ( lastEntry ) & hashTableMask ( ) ; int lastNext = table[tableIndex] ; if ( lastNext == srcIndex ) { table[tableIndex] = dstIndex ; } else { int previous ; long entry ; do { previous = lastNext ; lastNext = getNext ( entry = entries[lastNext] ) ; } while ( lastNext != srcIndex ) ; entries[previous] = swapNext ( entry , dstIndex ) ; } } else { elements[dstIndex] = null ; entries[dstIndex] = UNSET ; } } 
public Iterator < E > iterator ( ) { return new Iterator < E > ( ) { int expectedModCount = modCount ; int currentIndex = firstEntryIndex ( ) ; int indexToRemove = -1 ; @Override public boolean hasNext ( ) { return currentIndex > = 0 ; } @Override @SuppressWarnings ( " unchecked " ) public E next ( ) { checkForConcurrentModification ( ) ; if ( !hasNext ( ) ) { throw new NoSuchElementException ( ) ; } indexToRemove = currentIndex ; E result = ( E ) elements[currentIndex] ; currentIndex = getSuccessor ( currentIndex ) ; return result ; } @Override public void remove ( ) { checkForConcurrentModification ( ) ; checkRemove ( indexToRemove > = 0 ) ; expectedModCount++ ; CompactHashSet.this.remove ( elements[indexToRemove] , getHash ( entries[indexToRemove] ) ) ; currentIndex = adjustAfterRemove ( currentIndex , indexToRemove ) ; indexToRemove = -1 ; } private void checkForConcurrentModification ( ) { if ( modCount != expectedModCount ) { throw new ConcurrentModificationException ( ) ; } } } ; } 
Set < Entry < K , V > > createEntrySet ( ) { @WeakOuter class EntrySetImpl extends EntrySetView { @Override public Spliterator < Entry < K , V > > spliterator ( ) { return Spliterators.spliterator ( this , Spliterator.ORDERED | Spliterator.DISTINCT ) ; } } return new EntrySetImpl ( ) ; } 
Set < K > createKeySet ( ) { @WeakOuter class KeySetImpl extends KeySetView { @Override public Object[] toArray ( ) { return ObjectArrays.toArrayImpl ( this ) ; } @Override public < T > T[] toArray ( T[] a ) { return ObjectArrays.toArrayImpl ( this , a ) ; } @Override public Spliterator < K > spliterator ( ) { return Spliterators.spliterator ( this , Spliterator.ORDERED | Spliterator.DISTINCT ) ; } } return new KeySetImpl ( ) ; } 
Collection < V > createValues ( ) { @WeakOuter class ValuesImpl extends ValuesView { @Override public Object[] toArray ( ) { return ObjectArrays.toArrayImpl ( this ) ; } @Override public < T > T[] toArray ( T[] a ) { return ObjectArrays.toArrayImpl ( this , a ) ; } @Override public Spliterator < V > spliterator ( ) { return Spliterators.spliterator ( this , Spliterator.ORDERED ) ; } } return new ValuesImpl ( ) ; } 
public int add ( E element , int occurrences ) { checkNotNull ( element ) ; if ( occurrences == 0 ) { return count ( element ) ; } CollectPreconditions.checkPositive ( occurrences , " occurences " ) ; while ( true ) { AtomicInteger existingCounter = Maps.safeGet ( countMap , element ) ; if ( existingCounter == null ) { existingCounter = countMap.putIfAbsent ( element , new AtomicInteger ( occurrences ) ) ; if ( existingCounter == null ) { return 0 ; } } while ( true ) { int oldValue = existingCounter.get ( ) ; if ( oldValue != 0 ) { try { int newValue = IntMath.checkedAdd ( oldValue , occurrences ) ; if ( existingCounter.compareAndSet ( oldValue , newValue ) ) { return oldValue ; } } catch ( ArithmeticException overflow ) { throw new IllegalArgumentException ( " Overflow adding " + occurrences + " occurrences to a count of " + oldValue ) ; } } else { AtomicInteger newCounter = new AtomicInteger ( occurrences ) ; if ( ( countMap.putIfAbsent ( element , newCounter ) == null ) || countMap.replace ( element , existingCounter , newCounter ) ) { return 0 ; } break ; } } } } 
public int remove ( @Nullable Object element , int occurrences ) { if ( occurrences == 0 ) { return count ( element ) ; } CollectPreconditions.checkPositive ( occurrences , " occurences " ) ; AtomicInteger existingCounter = Maps.safeGet ( countMap , element ) ; if ( existingCounter == null ) { return 0 ; } while ( true ) { int oldValue = existingCounter.get ( ) ; if ( oldValue != 0 ) { int newValue = Math.max ( 0 , oldValue - occurrences ) ; if ( existingCounter.compareAndSet ( oldValue , newValue ) ) { if ( newValue == 0 ) { countMap.remove ( element , existingCounter ) ; } return oldValue ; } } else { return 0 ; } } } 
public boolean removeExactly ( @Nullable Object element , int occurrences ) { if ( occurrences == 0 ) { return true ; } CollectPreconditions.checkPositive ( occurrences , " occurences " ) ; AtomicInteger existingCounter = Maps.safeGet ( countMap , element ) ; if ( existingCounter == null ) { return false ; } while ( true ) { int oldValue = existingCounter.get ( ) ; if ( oldValue < occurrences ) { return false ; } int newValue = oldValue - occurrences ; if ( existingCounter.compareAndSet ( oldValue , newValue ) ) { if ( newValue == 0 ) { countMap.remove ( element , existingCounter ) ; } return true ; } } } 
public int setCount ( E element , int count ) { checkNotNull ( element ) ; checkNonnegative ( count , " count " ) ; while ( true ) { AtomicInteger existingCounter = Maps.safeGet ( countMap , element ) ; if ( existingCounter == null ) { if ( count == 0 ) { return 0 ; } else { existingCounter = countMap.putIfAbsent ( element , new AtomicInteger ( count ) ) ; if ( existingCounter == null ) { return 0 ; } } } while ( true ) { int oldValue = existingCounter.get ( ) ; if ( oldValue == 0 ) { if ( count == 0 ) { return 0 ; } else { AtomicInteger newCounter = new AtomicInteger ( count ) ; if ( ( countMap.putIfAbsent ( element , newCounter ) == null ) || countMap.replace ( element , existingCounter , newCounter ) ) { return 0 ; } } break ; } else { if ( existingCounter.compareAndSet ( oldValue , count ) ) { if ( count == 0 ) { countMap.remove ( element , existingCounter ) ; } return oldValue ; } } } } } 
public boolean setCount ( E element , int expectedOldCount , int newCount ) { checkNotNull ( element ) ; checkNonnegative ( expectedOldCount , " oldCount " ) ; checkNonnegative ( newCount , " newCount " ) ; AtomicInteger existingCounter = Maps.safeGet ( countMap , element ) ; if ( existingCounter == null ) { if ( expectedOldCount != 0 ) { return false ; } else if ( newCount == 0 ) { return true ; } else { return countMap.putIfAbsent ( element , new AtomicInteger ( newCount ) ) == null ; } } int oldValue = existingCounter.get ( ) ; if ( oldValue == expectedOldCount ) { if ( oldValue == 0 ) { if ( newCount == 0 ) { countMap.remove ( element , existingCounter ) ; return true ; } else { AtomicInteger newCounter = new AtomicInteger ( newCount ) ; return ( countMap.putIfAbsent ( element , newCounter ) == null ) || countMap.replace ( element , existingCounter , newCounter ) ; } } else { if ( existingCounter.compareAndSet ( oldValue , newCount ) ) { if ( newCount == 0 ) { countMap.remove ( element , existingCounter ) ; } return true ; } } } return false ; } 
Set < E > createElementSet ( ) { final Set < E > delegate = countMap.keySet ( ) ; return new ForwardingSet < E > ( ) { @Override protected Set < E > delegate ( ) { return delegate ; } @Override public boolean contains ( @Nullable Object object ) { return object != null && Collections2.safeContains ( delegate , object ) ; } @Override public boolean containsAll ( Collection < ? > collection ) { return standardContainsAll ( collection ) ; } @Override public boolean remove ( Object object ) { return object != null && Collections2.safeRemove ( delegate , object ) ; } @Override public boolean removeAll ( Collection < ? > c ) { return standardRemoveAll ( c ) ; } } ; } 
Iterator < Entry < E > > entryIterator ( ) { final Iterator < Entry < E > > readOnlyIterator = new AbstractIterator < Entry < E > > ( ) { private final Iterator < Map.Entry < E , AtomicInteger > > mapEntries = countMap.entrySet ( ) .iterator ( ) ; @Override protected Entry < E > computeNext ( ) { while ( true ) { if ( !mapEntries.hasNext ( ) ) { return endOfData ( ) ; } Map.Entry < E , AtomicInteger > mapEntry = mapEntries.next ( ) ; int count = mapEntry.getValue ( ) .get ( ) ; if ( count != 0 ) { return Multisets.immutableEntry ( mapEntry.getKey ( ) , count ) ; } } } } ; return new ForwardingIterator < Entry < E > > ( ) { @Nullable private Entry < E > last ; @Override protected Iterator < Entry < E > > delegate ( ) { return readOnlyIterator ; } @Override public Entry < E > next ( ) { last = super.next ( ) ; return last ; } @Override public void remove ( ) { checkRemove ( last != null ) ; ConcurrentHashMultiset.this.setCount ( last.getElement ( ) , 0 ) ; last = null ; } } ; } 
protected Entry < E > computeNext ( ) { while ( true ) { if ( !mapEntries.hasNext ( ) ) { return endOfData ( ) ; } Map.Entry < E , AtomicInteger > mapEntry = mapEntries.next ( ) ; int count = mapEntry.getValue ( ) .get ( ) ; if ( count != 0 ) { return Multisets.immutableEntry ( mapEntry.getKey ( ) , count ) ; } } } 
public static < C extends Comparable > ContiguousSet < C > create ( Range < C > range , DiscreteDomain < C > domain ) { checkNotNull ( range ) ; checkNotNull ( domain ) ; Range < C > effectiveRange = range ; try { if ( !range.hasLowerBound ( ) ) { effectiveRange = effectiveRange.intersection ( Range.atLeast ( domain.minValue ( ) ) ) ; } if ( !range.hasUpperBound ( ) ) { effectiveRange = effectiveRange.intersection ( Range.atMost ( domain.maxValue ( ) ) ) ; } } catch ( NoSuchElementException e ) { throw new IllegalArgumentException ( e ) ; } boolean empty = effectiveRange.isEmpty ( ) || Range.compareOrThrow ( range.lowerBound.leastValueAbove ( domain ) , range.upperBound.greatestValueBelow ( domain ) ) > 0 ; return empty ? new EmptyContiguousSet < C > ( domain ) : new RegularContiguousSet < C > ( effectiveRange , domain ) ; } 
public ContiguousSet < C > subSet ( C fromElement , boolean fromInclusive , C toElement , boolean toInclusive ) { checkNotNull ( fromElement ) ; checkNotNull ( toElement ) ; checkArgument ( comparator ( ) .compare ( fromElement , toElement ) < = 0 ) ; return subSetImpl ( fromElement , fromInclusive , toElement , toInclusive ) ; } 
Cut < C > withLowerBoundType ( BoundType boundType , DiscreteDomain < C > domain ) { switch ( boundType ) { case CLOSED: return this ; case OPEN: @Nullable C previous = domain.previous ( endpoint ) ; return ( previous == null ) ? Cut. < C > belowAll ( ) : new AboveValue < C > ( previous ) ; default: throw new AssertionError ( ) ; } } 
Cut < C > withUpperBoundType ( BoundType boundType , DiscreteDomain < C > domain ) { switch ( boundType ) { case CLOSED: @Nullable C previous = domain.previous ( endpoint ) ; return ( previous == null ) ? Cut. < C > aboveAll ( ) : new AboveValue < C > ( previous ) ; case OPEN: return this ; default: throw new AssertionError ( ) ; } } 
Cut < C > withLowerBoundType ( BoundType boundType , DiscreteDomain < C > domain ) { switch ( boundType ) { case OPEN: return this ; case CLOSED: @Nullable C next = domain.next ( endpoint ) ; return ( next == null ) ? Cut. < C > belowAll ( ) : belowValue ( next ) ; default: throw new AssertionError ( ) ; } } 
Cut < C > withUpperBoundType ( BoundType boundType , DiscreteDomain < C > domain ) { switch ( boundType ) { case OPEN: @Nullable C next = domain.next ( endpoint ) ; return ( next == null ) ? Cut. < C > aboveAll ( ) : belowValue ( next ) ; case CLOSED: return this ; default: throw new AssertionError ( ) ; } } 
protected final T endOfData ( ) { state = State.DONE ; return null ; }
public Class < ? > loadFinalizer ( ) { try { ClassLoader finalizerLoader = newLoader ( getBaseUrl ( ) ) ; return finalizerLoader.loadClass ( FINALIZER_CLASS_NAME ) ; } catch ( Exception e ) { logger.log ( Level.WARNING , LOADING_ERROR , e ) ; return null ; } }
private Method getFinalizeReferentMethod ( ) { Class < ? > finalizableReferenceClass = finalizableReferenceClassReference.get ( ) ; if ( finalizableReferenceClass == null ) { return null ; } try { return finalizableReferenceClass.getMethod ( " finalizeReferent " ) ; } catch ( NoSuchMethodException e ) { throw new AssertionError ( e ) ; } }
private static Field getInheritableThreadLocalsField ( ) { try { Field inheritableThreadLocals = Thread.class.getDeclaredField ( " inheritableThreadLocals " ) ; inheritableThreadLocals.setAccessible ( true ) ; return inheritableThreadLocals ; } catch ( Throwable t ) { logger.log ( Level.INFO , " Couldn't access Thread.inheritableThreadLocals. Reference finalizer threads will " + " inherit thread local values. " ) ; return null ; } }
private static Constructor < Thread > getBigThreadConstructor ( ) { try { return Thread.class.getConstructor ( ThreadGroup.class , Runnable.class , String.class , long.class , boolean.class ) ; } catch ( Throwable t ) { return null ; } }
private static Method getJlaMethod ( String name , Class < ? > ... parameterTypes ) throws ThreadDeath { try { return Class.forName ( JAVA_LANG_ACCESS_CLASSNAME , false , null ) .getMethod ( name , parameterTypes ) ; } catch ( ThreadDeath death ) { throw death ; } catch ( Throwable t ) { return null ; } }
public Object get ( ) { return null ; }
public ReferenceEntry < Object , Object > getEntry ( ) { return null ; }
public Object waitForValue ( ) { return null ; }
public ReferenceEntry < K , V > poll ( ) { ReferenceEntry < K , V > next = head.getNextInWriteQueue ( ) ; if ( next == head ) { return null ; } remove ( next ) ; return next ; }
public ReferenceEntry < K , V > poll ( ) { ReferenceEntry < K , V > next = head.getNextInAccessQueue ( ) ; if ( next == head ) { return null ; } remove ( next ) ; return next ; }
public V get ( @Nullable Object key ) { if ( key == null ) { return null ; } int hash = hash ( key ) ; return segmentFor ( hash ) .get ( key , hash ) ; }
public V remove ( @Nullable Object key ) { if ( key == null ) { return null ; } int hash = hash ( key ) ; return segmentFor ( hash ) .remove ( key , hash ) ; }
public Collection < V > get ( Object key ) { Collection < V > collection = Maps.safeGet ( submap , key ) ; if ( collection == null ) { return null ; } @SuppressWarnings ( " unchecked " ) K k = ( K ) key ; return wrapCollection ( k , collection ) ; }
public Collection < V > remove ( Object key ) { Collection < V > collection = submap.remove ( key ) ; if ( collection == null ) { return null ; } Collection < V > output = createCollection ( ) ; output.addAll ( collection ) ; totalSize -= collection.size ( ) ; collection.clear ( ) ; return output ; }
Entry < K , Collection < V > > pollAsMapEntry ( Iterator < Entry < K , Collection < V > > > entryIterator ) { if ( !entryIterator.hasNext ( ) ) { return null ; } Entry < K , Collection < V > > entry = entryIterator.next ( ) ; Collection < V > output = createCollection ( ) ; output.addAll ( entry.getValue ( ) ) ; entryIterator.remove ( ) ; return Maps.immutableEntry ( entry.getKey ( ) , unmodifiableCollectionSubclass ( output ) ) ; }
public Entry < E > pollFirstEntry ( ) { Iterator < Entry < E > > entryIterator = entryIterator ( ) ; if ( entryIterator.hasNext ( ) ) { Entry < E > result = entryIterator.next ( ) ; result = Multisets.immutableEntry ( result.getElement ( ) , result.getCount ( ) ) ; entryIterator.remove ( ) ; return result ; } return null ; }
public Entry < E > pollLastEntry ( ) { Iterator < Entry < E > > entryIterator = descendingEntryIterator ( ) ; if ( entryIterator.hasNext ( ) ) { Entry < E > result = entryIterator.next ( ) ; result = Multisets.immutableEntry ( result.getElement ( ) , result.getCount ( ) ) ; entryIterator.remove ( ) ; return result ; } return null ; }
UnmodifiableIterator < Entry < K , V > > entryIterator ( ) { return new AbstractIterator < Entry < K , V > > ( ) { private int index = -1 ; private final int maxIndex = keyToIndex ( ) .size ( ) ; @Override protected Entry < K , V > computeNext ( ) { for ( index++ ; index < maxIndex ; index++ ) { V value = getValue ( index ) ; if ( value != null ) { return Maps.immutableEntry ( getKey ( index ) , value ) ; } } return endOfData ( ) ; } } ; } 
Set < Entry < E > > createEntrySet ( ) { @WeakOuter class EntrySetImpl extends Multisets.EntrySet < E > { @Override Multiset < E > multiset ( ) { return DescendingMultiset.this ; } @Override public Iterator < Entry < E > > iterator ( ) { return entryIterator ( ) ; } @Override public int size ( ) { return forwardMultiset ( ) .entrySet ( ) .size ( ) ; } } return new EntrySetImpl ( ) ; } 
ContiguousSet < C > subSetImpl ( C fromElement , boolean fromInclusive , C toElement , boolean toInclusive ) { return this ; } 
public static < K extends Enum < K > , V extends Enum < V > > EnumBiMap < K , V > create ( Map < K , V > map ) { EnumBiMap < K , V > bimap = create ( inferKeyType ( map ) , inferValueType ( map ) ) ; bimap.putAll ( map ) ; return bimap ; } 
static < K extends Enum < K > > Class < K > inferKeyType ( Map < K , ? > map ) { if ( map instanceof EnumBiMap ) { return ( ( EnumBiMap < K , ? > ) map ) .keyType ( ) ; } if ( map instanceof EnumHashBiMap ) { return ( ( EnumHashBiMap < K , ? > ) map ) .keyType ( ) ; } checkArgument ( !map.isEmpty ( ) ) ; return map.keySet ( ) .iterator ( ) .next ( ) .getDeclaringClass ( ) ; } 
public int add ( E element , int occurrences ) { checkIsE ( element ) ; checkNonnegative ( occurrences , " occurrences " ) ; if ( occurrences == 0 ) { return count ( element ) ; } int index = element.ordinal ( ) ; int oldCount = counts[index] ; long newCount = ( long ) oldCount + occurrences ; checkArgument ( newCount < = Integer.MAX_VALUE , " too many occurrences: %s " , newCount ) ; counts[index] = ( int ) newCount ; if ( oldCount == 0 ) { distinctElements++ ; } size += occurrences ; return oldCount ; } 
public int remove ( @Nullable Object element , int occurrences ) { if ( element == null || !isActuallyE ( element ) ) { return 0 ; } Enum < ? > e = ( Enum < ? > ) element ; checkNonnegative ( occurrences , " occurrences " ) ; if ( occurrences == 0 ) { return count ( element ) ; } int index = e.ordinal ( ) ; int oldCount = counts[index] ; if ( oldCount == 0 ) { return 0 ; } else if ( oldCount < = occurrences ) { counts[index] = 0 ; distinctElements-- ; size -= oldCount ; } else { counts[index] = oldCount - occurrences ; size -= occurrences ; } return oldCount ; } 
public int setCount ( E element , int count ) { checkIsE ( element ) ; checkNonnegative ( count , " count " ) ; int index = element.ordinal ( ) ; int oldCount = counts[index] ; counts[index] = count ; size += count - oldCount ; if ( oldCount == 0 && count > 0 ) { distinctElements++ ; } else if ( oldCount > 0 && count == 0 ) { distinctElements-- ; } return oldCount ; } 
Iterator < E > elementIterator ( ) { return new Itr < E > ( ) { @Override E output ( int index ) { return enumConstants[index] ; } } ; } 
Iterator < Entry < E > > entryIterator ( ) { return new Itr < Entry < E > > ( ) { @Override Entry < E > output ( final int index ) { return new Multisets.AbstractEntry < E > ( ) { @Override public E getElement ( ) { return enumConstants[index] ; } @Override public int getCount ( ) { return counts[index] ; } } ; } } ; } 
Entry < E > output ( final int index ) { return new Multisets.AbstractEntry < E > ( ) { @Override public E getElement ( ) { return enumConstants[index] ; } @Override public int getCount ( ) { return counts[index] ; } } ; } 
public Collection < V > remove ( @Nullable Object key ) { Collection < V > collection = unfiltered.asMap ( ) .get ( key ) ; if ( collection == null ) { return null ; } @SuppressWarnings ( " unchecked " ) K k = ( K ) key ; List < V > result = Lists.newArrayList ( ) ; Iterator < V > itr = collection.iterator ( ) ; while ( itr.hasNext ( ) ) { V v = itr.next ( ) ; if ( satisfies ( k , v ) ) { itr.remove ( ) ; result.add ( v ) ; } } if ( result.isEmpty ( ) ) { return null ; } else if ( unfiltered instanceof SetMultimap ) { return Collections.unmodifiableSet ( Sets.newLinkedHashSet ( result ) ) ; } else { return Collections.unmodifiableList ( result ) ; } } 
Set < K > createKeySet ( ) { @WeakOuter class KeySetImpl extends Maps.KeySet < K , Collection < V > > { KeySetImpl ( ) { super ( AsMap.this ) ; } @Override public boolean removeAll ( Collection < ? > c ) { return removeEntriesIf ( Maps. < K > keyPredicateOnEntries ( in ( c ) ) ) ; } @Override public boolean retainAll ( Collection < ? > c ) { return removeEntriesIf ( Maps. < K > keyPredicateOnEntries ( not ( in ( c ) ) ) ) ; } @Override public boolean remove ( @Nullable Object o ) { return AsMap.this.remove ( o ) != null ; } } return new KeySetImpl ( ) ; } 
Set < Entry < K , Collection < V > > > createEntrySet ( ) { @WeakOuter class EntrySetImpl extends Maps.EntrySet < K , Collection < V > > { @Override Map < K , Collection < V > > map ( ) { return AsMap.this ; } @Override public Iterator < Entry < K , Collection < V > > > iterator ( ) { return new AbstractIterator < Entry < K , Collection < V > > > ( ) { final Iterator < Entry < K , Collection < V > > > backingIterator = unfiltered.asMap ( ) .entrySet ( ) .iterator ( ) ; @Override protected Entry < K , Collection < V > > computeNext ( ) { while ( backingIterator.hasNext ( ) ) { Entry < K , Collection < V > > entry = backingIterator.next ( ) ; K key = entry.getKey ( ) ; Collection < V > collection = filterCollection ( entry.getValue ( ) , new ValuePredicate ( key ) ) ; if ( !collection.isEmpty ( ) ) { return Maps.immutableEntry ( key , collection ) ; } } return endOfData ( ) ; } } ; } @Override public boolean removeAll ( Collection < ? > c ) { return removeEntriesIf ( in ( c ) ) ; } @Override public boolean retainAll ( Collection < ? > c ) { return removeEntriesIf ( not ( in ( c ) ) ) ; } @Override public int size ( ) { return Iterators.size ( iterator ( ) ) ; } } return new EntrySetImpl ( ) ; } 
public Iterator < Entry < K , Collection < V > > > iterator ( ) { return new AbstractIterator < Entry < K , Collection < V > > > ( ) { final Iterator < Entry < K , Collection < V > > > backingIterator = unfiltered.asMap ( ) .entrySet ( ) .iterator ( ) ; @Override protected Entry < K , Collection < V > > computeNext ( ) { while ( backingIterator.hasNext ( ) ) { Entry < K , Collection < V > > entry = backingIterator.next ( ) ; K key = entry.getKey ( ) ; Collection < V > collection = filterCollection ( entry.getValue ( ) , new ValuePredicate ( key ) ) ; if ( !collection.isEmpty ( ) ) { return Maps.immutableEntry ( key , collection ) ; } } return endOfData ( ) ; } } ; } 
Collection < Collection < V > > createValues ( ) { @WeakOuter class ValuesImpl extends Maps.Values < K , Collection < V > > { ValuesImpl ( ) { super ( AsMap.this ) ; } @Override public boolean remove ( @Nullable Object o ) { if ( o instanceof Collection ) { Collection < ? > c = ( Collection < ? > ) o ; Iterator < Entry < K , Collection < V > > > entryIterator = unfiltered.asMap ( ) .entrySet ( ) .iterator ( ) ; while ( entryIterator.hasNext ( ) ) { Entry < K , Collection < V > > entry = entryIterator.next ( ) ; K key = entry.getKey ( ) ; Collection < V > collection = filterCollection ( entry.getValue ( ) , new ValuePredicate ( key ) ) ; if ( !collection.isEmpty ( ) && c.equals ( collection ) ) { if ( collection.size ( ) == entry.getValue ( ) .size ( ) ) { entryIterator.remove ( ) ; } else { collection.clear ( ) ; } return true ; } } } return false ; } @Override public boolean removeAll ( Collection < ? > c ) { return removeEntriesIf ( Maps. < Collection < V > > valuePredicateOnEntries ( in ( c ) ) ) ; } @Override public boolean retainAll ( Collection < ? > c ) { return removeEntriesIf ( Maps. < Collection < V > > valuePredicateOnEntries ( not ( in ( c ) ) ) ) ; } } return new ValuesImpl ( ) ; } 
public boolean remove ( @Nullable Object o ) { if ( o instanceof Collection ) { Collection < ? > c = ( Collection < ? > ) o ; Iterator < Entry < K , Collection < V > > > entryIterator = unfiltered.asMap ( ) .entrySet ( ) .iterator ( ) ; while ( entryIterator.hasNext ( ) ) { Entry < K , Collection < V > > entry = entryIterator.next ( ) ; K key = entry.getKey ( ) ; Collection < V > collection = filterCollection ( entry.getValue ( ) , new ValuePredicate ( key ) ) ; if ( !collection.isEmpty ( ) && c.equals ( collection ) ) { if ( collection.size ( ) == entry.getValue ( ) .size ( ) ) { entryIterator.remove ( ) ; } else { collection.clear ( ) ; } return true ; } } } return false ; } 
public int remove ( @Nullable Object key , int occurrences ) { checkNonnegative ( occurrences , " occurrences " ) ; if ( occurrences == 0 ) { return count ( key ) ; } Collection < V > collection = unfiltered.asMap ( ) .get ( key ) ; if ( collection == null ) { return 0 ; } @SuppressWarnings ( " unchecked " ) K k = ( K ) key ; int oldCount = 0 ; Iterator < V > itr = collection.iterator ( ) ; while ( itr.hasNext ( ) ) { V v = itr.next ( ) ; if ( satisfies ( k , v ) ) { oldCount++ ; if ( oldCount < = occurrences ) { itr.remove ( ) ; } } } return oldCount ; } 
public Set < Multiset.Entry < K > > entrySet ( ) { return new Multisets.EntrySet < K > ( ) { @Override Multiset < K > multiset ( ) { return Keys.this ; } @Override public Iterator < Multiset.Entry < K > > iterator ( ) { return Keys.this.entryIterator ( ) ; } @Override public int size ( ) { return FilteredEntryMultimap.this.keySet ( ) .size ( ) ; } private boolean removeEntriesIf ( final Predicate < ? super Multiset.Entry < K > > predicate ) { return FilteredEntryMultimap.this.removeEntriesIf ( new Predicate < Map.Entry < K , Collection < V > > > ( ) { @Override public boolean apply ( Map.Entry < K , Collection < V > > entry ) { return predicate.apply ( Multisets.immutableEntry ( entry.getKey ( ) , entry.getValue ( ) .size ( ) ) ) ; } } ) ; } @Override public boolean removeAll ( Collection < ? > c ) { return removeEntriesIf ( in ( c ) ) ; } @Override public boolean retainAll ( Collection < ? > c ) { return removeEntriesIf ( not ( in ( c ) ) ) ; } } ; } 
private boolean removeEntriesIf ( final Predicate < ? super Multiset.Entry < K > > predicate ) { return FilteredEntryMultimap.this.removeEntriesIf ( new Predicate < Map.Entry < K , Collection < V > > > ( ) { @Override public boolean apply ( Map.Entry < K , Collection < V > > entry ) { return predicate.apply ( Multisets.immutableEntry ( entry.getKey ( ) , entry.getValue ( ) .size ( ) ) ) ; } } ) ; } 
public static < E > FluentIterable < E > from ( final Iterable < E > iterable ) { return ( iterable instanceof FluentIterable ) ? ( FluentIterable < E > ) iterable : new FluentIterable < E > ( iterable ) { @Override public Iterator < E > iterator ( ) { return iterable.iterator ( ) ; } } ; } 
public static < T > FluentIterable < T > concat ( final Iterable < ? extends Iterable < ? extends T > > inputs ) { checkNotNull ( inputs ) ; return new FluentIterable < T > ( ) { @Override public Iterator < T > iterator ( ) { return Iterators.concat ( Iterators.transform ( inputs.iterator ( ) , Iterables. < T > toIterator ( ) ) ) ; } } ; } 
private static < T > FluentIterable < T > concatNoDefensiveCopy ( final Iterable < ? extends T > ... inputs ) { for ( Iterable < ? extends T > input : inputs ) { checkNotNull ( input ) ; } return new FluentIterable < T > ( ) { @Override public Iterator < T > iterator ( ) { return Iterators.concat ( new AbstractIndexedListIterator < Iterator < ? extends T > > ( inputs.length ) { @Override public Iterator < ? extends T > get ( int i ) { return inputs[i].iterator ( ) ; } } ) ; } } ; } 
public Iterator < T > iterator ( ) { return Iterators.concat ( new AbstractIndexedListIterator < Iterator < ? extends T > > ( inputs.length ) { @Override public Iterator < ? extends T > get ( int i ) { return inputs[i].iterator ( ) ; } } ) ; } 
public final Optional < E > last ( ) { Iterable < E > iterable = getDelegate ( ) ; if ( iterable instanceof List ) { List < E > list = ( List < E > ) iterable ; if ( list.isEmpty ( ) ) { return Optional.absent ( ) ; } return Optional.of ( list.get ( list.size ( ) - 1 ) ) ; } Iterator < E > iterator = iterable.iterator ( ) ; if ( !iterator.hasNext ( ) ) { return Optional.absent ( ) ; } if ( iterable instanceof SortedSet ) { SortedSet < E > sortedSet = ( SortedSet < E > ) iterable ; return Optional.of ( sortedSet.last ( ) ) ; } while ( true ) { E current = iterator.next ( ) ; if ( !iterator.hasNext ( ) ) { return Optional.of ( current ) ; } } } 
public boolean offerFirst ( E e , long timeout , TimeUnit unit ) throws InterruptedException { return delegate ( ) .offerFirst ( e , timeout , unit ) ; } 
public boolean offerLast ( E e , long timeout , TimeUnit unit ) throws InterruptedException { return delegate ( ) .offerLast ( e , timeout , unit ) ; } 
public NavigableSet < E > subSet ( E fromElement , boolean fromInclusive , E toElement , boolean toInclusive ) { return delegate ( ) .subSet ( fromElement , fromInclusive , toElement , toInclusive ) ; } 
protected NavigableSet < E > standardSubSet ( E fromElement , boolean fromInclusive , E toElement , boolean toInclusive ) { return tailSet ( fromElement , fromInclusive ) .headSet ( toElement , toInclusive ) ; } 
protected boolean standardRemove ( @Nullable Object object ) { try { @SuppressWarnings ( " unchecked " ) SortedSet < Object > self = ( SortedSet < Object > ) this ; Iterator < Object > iterator = self.tailSet ( object ) .iterator ( ) ; if ( iterator.hasNext ( ) ) { Object ceiling = iterator.next ( ) ; if ( unsafeCompare ( ceiling , object ) == 0 ) { iterator.remove ( ) ; return true ; } } } catch ( ClassCastException | NullPointerException e ) { return false ; } return false ; } 
static < T > GeneralRange < T > range ( Comparator < ? super T > comparator , @Nullable T lower , BoundType lowerType , @Nullable T upper , BoundType upperType ) { return new GeneralRange < T > ( comparator , true , lower , lowerType , true , upper , upperType ) ; } 
GeneralRange < T > intersect ( GeneralRange < T > other ) { checkNotNull ( other ) ; checkArgument ( comparator.equals ( other.comparator ) ) ; boolean hasLowBound = this.hasLowerBound ; @Nullable T lowEnd = getLowerEndpoint ( ) ; BoundType lowType = getLowerBoundType ( ) ; if ( !hasLowerBound ( ) ) { hasLowBound = other.hasLowerBound ; lowEnd = other.getLowerEndpoint ( ) ; lowType = other.getLowerBoundType ( ) ; } else if ( other.hasLowerBound ( ) ) { int cmp = comparator.compare ( getLowerEndpoint ( ) , other.getLowerEndpoint ( ) ) ; if ( cmp < 0 || ( cmp == 0 && other.getLowerBoundType ( ) == OPEN ) ) { lowEnd = other.getLowerEndpoint ( ) ; lowType = other.getLowerBoundType ( ) ; } } boolean hasUpBound = this.hasUpperBound ; @Nullable T upEnd = getUpperEndpoint ( ) ; BoundType upType = getUpperBoundType ( ) ; if ( !hasUpperBound ( ) ) { hasUpBound = other.hasUpperBound ; upEnd = other.getUpperEndpoint ( ) ; upType = other.getUpperBoundType ( ) ; } else if ( other.hasUpperBound ( ) ) { int cmp = comparator.compare ( getUpperEndpoint ( ) , other.getUpperEndpoint ( ) ) ; if ( cmp > 0 || ( cmp == 0 && other.getUpperBoundType ( ) == OPEN ) ) { upEnd = other.getUpperEndpoint ( ) ; upType = other.getUpperBoundType ( ) ; } } if ( hasLowBound && hasUpBound ) { int cmp = comparator.compare ( lowEnd , upEnd ) ; if ( cmp > 0 || ( cmp == 0 && lowType == OPEN && upType == OPEN ) ) { lowEnd = upEnd ; lowType = OPEN ; upType = CLOSED ; } } return new GeneralRange < T > ( comparator , hasLowBound , lowEnd , lowType , hasUpBound , upEnd , upType ) ; } 
private void delete ( BiEntry < K , V > entry ) { int keyBucket = entry.keyHash & mask ; BiEntry < K , V > prevBucketEntry = null ; for ( BiEntry < K , V > bucketEntry = hashTableKToV[keyBucket] ; true ; bucketEntry = bucketEntry.nextInKToVBucket ) { if ( bucketEntry == entry ) { if ( prevBucketEntry == null ) { hashTableKToV[keyBucket] = entry.nextInKToVBucket ; } else { prevBucketEntry.nextInKToVBucket = entry.nextInKToVBucket ; } break ; } prevBucketEntry = bucketEntry ; } int valueBucket = entry.valueHash & mask ; prevBucketEntry = null ; for ( BiEntry < K , V > bucketEntry = hashTableVToK[valueBucket] ; true ; bucketEntry = bucketEntry.nextInVToKBucket ) { if ( bucketEntry == entry ) { if ( prevBucketEntry == null ) { hashTableVToK[valueBucket] = entry.nextInVToKBucket ; } else { prevBucketEntry.nextInVToKBucket = entry.nextInVToKBucket ; } break ; } prevBucketEntry = bucketEntry ; } if ( entry.prevInKeyInsertionOrder == null ) { firstInKeyInsertionOrder = entry.nextInKeyInsertionOrder ; } else { entry.prevInKeyInsertionOrder.nextInKeyInsertionOrder = entry.nextInKeyInsertionOrder ; } if ( entry.nextInKeyInsertionOrder == null ) { lastInKeyInsertionOrder = entry.prevInKeyInsertionOrder ; } else { entry.nextInKeyInsertionOrder.prevInKeyInsertionOrder = entry.prevInKeyInsertionOrder ; } size-- ; modCount++ ; } 
private void insert ( BiEntry < K , V > entry , @Nullable BiEntry < K , V > oldEntryForKey ) { int keyBucket = entry.keyHash & mask ; entry.nextInKToVBucket = hashTableKToV[keyBucket] ; hashTableKToV[keyBucket] = entry ; int valueBucket = entry.valueHash & mask ; entry.nextInVToKBucket = hashTableVToK[valueBucket] ; hashTableVToK[valueBucket] = entry ; if ( oldEntryForKey == null ) { entry.prevInKeyInsertionOrder = lastInKeyInsertionOrder ; entry.nextInKeyInsertionOrder = null ; if ( lastInKeyInsertionOrder == null ) { firstInKeyInsertionOrder = entry ; } else { lastInKeyInsertionOrder.nextInKeyInsertionOrder = entry ; } lastInKeyInsertionOrder = entry ; } else { entry.prevInKeyInsertionOrder = oldEntryForKey.prevInKeyInsertionOrder ; if ( entry.prevInKeyInsertionOrder == null ) { firstInKeyInsertionOrder = entry ; } else { entry.prevInKeyInsertionOrder.nextInKeyInsertionOrder = entry ; } entry.nextInKeyInsertionOrder = oldEntryForKey.nextInKeyInsertionOrder ; if ( entry.nextInKeyInsertionOrder == null ) { lastInKeyInsertionOrder = entry ; } else { entry.nextInKeyInsertionOrder.prevInKeyInsertionOrder = entry ; } } size++ ; modCount++ ; } 
private K putInverse ( @Nullable V value , @Nullable K key , boolean force ) { int valueHash = smearedHash ( value ) ; int keyHash = smearedHash ( key ) ; BiEntry < K , V > oldEntryForValue = seekByValue ( value , valueHash ) ; BiEntry < K , V > oldEntryForKey = seekByKey ( key , keyHash ) ; if ( oldEntryForValue != null && keyHash == oldEntryForValue.keyHash && Objects.equal ( key , oldEntryForValue.key ) ) { return key ; } else if ( oldEntryForKey != null && !force ) { throw new IllegalArgumentException ( " key already present: " + key ) ; } if ( oldEntryForValue != null ) { delete ( oldEntryForValue ) ; } if ( oldEntryForKey != null ) { delete ( oldEntryForKey ) ; } BiEntry < K , V > newEntry = new BiEntry < > ( key , keyHash , value , valueHash ) ; insert ( newEntry , oldEntryForKey ) ; if ( oldEntryForKey != null ) { oldEntryForKey.prevInKeyInsertionOrder = null ; oldEntryForKey.nextInKeyInsertionOrder = null ; } if ( oldEntryForValue != null ) { oldEntryForValue.prevInKeyInsertionOrder = null ; oldEntryForValue.nextInKeyInsertionOrder = null ; } rehashIfNecessary ( ) ; return Maps.keyOrNull ( oldEntryForValue ) ; } 
Iterator < Entry < K , V > > entryIterator ( ) { return new Itr < Entry < K , V > > ( ) { @Override Entry < K , V > output ( BiEntry < K , V > entry ) { return new MapEntry ( entry ) ; } class MapEntry extends AbstractMapEntry < K , V > { BiEntry < K , V > delegate ; MapEntry ( BiEntry < K , V > entry ) { this.delegate = entry ; } @Override public K getKey ( ) { return delegate.key ; } @Override public V getValue ( ) { return delegate.value ; } @Override public V setValue ( V value ) { V oldValue = delegate.value ; int valueHash = smearedHash ( value ) ; if ( valueHash == delegate.valueHash && Objects.equal ( value , oldValue ) ) { return value ; } checkArgument ( seekByValue ( value , valueHash ) == null , " value already present: %s " , value ) ; delete ( delegate ) ; BiEntry < K , V > newEntry = new BiEntry < > ( delegate.key , delegate.keyHash , value , valueHash ) ; insert ( newEntry , delegate ) ; delegate.prevInKeyInsertionOrder = null ; delegate.nextInKeyInsertionOrder = null ; expectedModCount = modCount ; if ( toRemove == delegate ) { toRemove = newEntry ; } delegate = newEntry ; return oldValue ; } } } ; } 
public V setValue ( V value ) { V oldValue = delegate.value ; int valueHash = smearedHash ( value ) ; if ( valueHash == delegate.valueHash && Objects.equal ( value , oldValue ) ) { return value ; } checkArgument ( seekByValue ( value , valueHash ) == null , " value already present: %s " , value ) ; delete ( delegate ) ; BiEntry < K , V > newEntry = new BiEntry < > ( delegate.key , delegate.keyHash , value , valueHash ) ; insert ( newEntry , delegate ) ; delegate.prevInKeyInsertionOrder = null ; delegate.nextInKeyInsertionOrder = null ; expectedModCount = modCount ; if ( toRemove == delegate ) { toRemove = newEntry ; } delegate = newEntry ; return oldValue ; } 
Iterator < Entry < V , K > > entryIterator ( ) { return new Itr < Entry < V , K > > ( ) { @Override Entry < V , K > output ( BiEntry < K , V > entry ) { return new InverseEntry ( entry ) ; } class InverseEntry extends AbstractMapEntry < V , K > { BiEntry < K , V > delegate ; InverseEntry ( BiEntry < K , V > entry ) { this.delegate = entry ; } @Override public V getKey ( ) { return delegate.value ; } @Override public K getValue ( ) { return delegate.key ; } @Override public K setValue ( K key ) { K oldKey = delegate.key ; int keyHash = smearedHash ( key ) ; if ( keyHash == delegate.keyHash && Objects.equal ( key , oldKey ) ) { return key ; } checkArgument ( seekByKey ( key , keyHash ) == null , " value already present: %s " , key ) ; delete ( delegate ) ; BiEntry < K , V > newEntry = new BiEntry < > ( key , keyHash , delegate.value , delegate.valueHash ) ; delegate = newEntry ; insert ( newEntry , null ) ; expectedModCount = modCount ; return oldKey ; } } } ; } 
ImmutableBiMap < K , V > buildJdkBacked ( ) { checkState ( valueComparator == null , " buildJdkBacked is for tests only , doesn't support orderEntriesByValue " ) ; switch ( size ) { case 0: return of ( ) ; case 1: return of ( entries[0].getKey ( ) , entries[0].getValue ( ) ) ; default: entriesUsed = true ; return RegularImmutableBiMap.fromEntryArray ( size , entries ) ; } } 
public static < K , V > ImmutableBiMap < K , V > copyOf ( Iterable < ? extends Entry < ? extends K , ? extends V > > entries ) { @SuppressWarnings ( " unchecked " ) Entry < K , V > [] entryArray = ( Entry < K , V > [] ) Iterables.toArray ( entries , EMPTY_ENTRY_ARRAY ) ; switch ( entryArray.length ) { case 0: return of ( ) ; case 1: Entry < K , V > entry = entryArray[0] ; return of ( entry.getKey ( ) , entry.getValue ( ) ) ; default: return RegularImmutableBiMap.fromEntries ( entryArray ) ; } } 
public static < T , K , V > Collector < T , ? , ImmutableMap < K , V > > toImmutableMap ( Function < ? super T , ? extends K > keyFunction , Function < ? super T , ? extends V > valueFunction ) { throw new UnsupportedOperationException ( ) ; } 
public static < T , K , V > Collector < T , ? , ImmutableMap < K , V > > toImmutableMap ( Function < ? super T , ? extends K > keyFunction , Function < ? super T , ? extends V > valueFunction , BinaryOperator < V > mergeFunction ) { throw new UnsupportedOperationException ( ) ; } 
public final < T > T[] toArray ( T[] other ) { checkNotNull ( other ) ; int size = size ( ) ; if ( other.length < size ) { Object[] internal = internalArray ( ) ; if ( internal != null ) { return Platform.copy ( internal , internalArrayStart ( ) , internalArrayEnd ( ) , other ) ; } other = ObjectArrays.newArray ( other , size ) ; } else if ( other.length > size ) { other[size] = null ; } copyIntoArray ( other , 0 ) ; return other ; } 
public final boolean add ( E e ) { throw new UnsupportedOperationException ( ) ; } 
public final boolean remove ( Object object ) { throw new UnsupportedOperationException ( ) ; } 
public final boolean addAll ( Collection < ? extends E > newElements ) { throw new UnsupportedOperationException ( ) ; } 
public final boolean removeAll ( Collection < ? > oldElements ) { throw new UnsupportedOperationException ( ) ; } 
public final boolean removeIf ( Predicate < ? super E > filter ) { throw new UnsupportedOperationException ( ) ; } 
public final boolean retainAll ( Collection < ? > elementsToKeep ) { throw new UnsupportedOperationException ( ) ; } 
public final void clear ( ) { throw new UnsupportedOperationException ( ) ; } 
public ImmutableList < E > asList ( ) { switch ( size ( ) ) { case 0: return ImmutableList.of ( ) ; case 1: return ImmutableList.of ( iterator ( ) .next ( ) ) ; default: return new RegularImmutableAsList < E > ( this , toArray ( ) ) ; } } 
static < K extends Enum < K > , V > ImmutableMap < K , V > asImmutable ( EnumMap < K , V > map ) { switch ( map.size ( ) ) { case 0: return ImmutableMap.of ( ) ; case 1: Entry < K , V > entry = Iterables.getOnlyElement ( map.entrySet ( ) ) ; return ImmutableMap.of ( entry.getKey ( ) , entry.getValue ( ) ) ; default: return new ImmutableEnumMap < > ( map ) ; } } 
static ImmutableSet asImmutable ( EnumSet set ) { switch ( set.size ( ) ) { case 0: return ImmutableSet.of ( ) ; case 1: return ImmutableSet.of ( Iterables.getOnlyElement ( set ) ) ; default: return new ImmutableEnumSet ( set ) ; } } 
public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 ) { return construct ( e1 , e2 , e3 , e4 , e5 ) ; } 
public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 ) { return construct ( e1 , e2 , e3 , e4 , e5 , e6 ) ; } 
public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E e7 ) { return construct ( e1 , e2 , e3 , e4 , e5 , e6 , e7 ) ; } 
public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E e7 , E e8 ) { return construct ( e1 , e2 , e3 , e4 , e5 , e6 , e7 , e8 ) ; } 
public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E e7 , E e8 , E e9 ) { return construct ( e1 , e2 , e3 , e4 , e5 , e6 , e7 , e8 , e9 ) ; } 
public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E e7 , E e8 , E e9 , E e10 ) { return construct ( e1 , e2 , e3 , e4 , e5 , e6 , e7 , e8 , e9 , e10 ) ; } 
public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E e7 , E e8 , E e9 , E e10 , E e11 ) { return construct ( e1 , e2 , e3 , e4 , e5 , e6 , e7 , e8 , e9 , e10 , e11 ) ; } 
public static < E > ImmutableList < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E e7 , E e8 , E e9 , E e10 , E e11 , E e12 , E... others ) { checkArgument ( others.length < = Integer.MAX_VALUE - 12 , " the total number of elements must fit in an int " ) ; Object[] array = new Object[12 + others.length] ; array[0] = e1 ; array[1] = e2 ; array[2] = e3 ; array[3] = e4 ; array[4] = e5 ; array[5] = e6 ; array[6] = e7 ; array[7] = e8 ; array[8] = e9 ; array[9] = e10 ; array[10] = e11 ; array[11] = e12 ; System.arraycopy ( others , 0 , array , 12 , others.length ) ; return construct ( array ) ; } 
static < E > ImmutableList < E > asImmutableList ( Object[] elements , int length ) { switch ( length ) { case 0: return of ( ) ; case 1: return of ( ( E ) elements[0] ) ; default: if ( length < elements.length ) { elements = Arrays.copyOf ( elements , length ) ; } return new RegularImmutableList < E > ( elements ) ; } } 
public UnmodifiableListIterator < E > listIterator ( int index ) { return new AbstractIndexedListIterator < E > ( size ( ) , index ) { @Override protected E get ( int index ) { return ImmutableList.this.get ( index ) ; } } ; } 
public ImmutableList < E > subList ( int fromIndex , int toIndex ) { checkPositionIndexes ( fromIndex , toIndex , size ( ) ) ; int length = toIndex - fromIndex ; if ( length == size ( ) ) { return this ; } else if ( length == 0 ) { return of ( ) ; } else if ( length == 1 ) { return of ( get ( fromIndex ) ) ; } else { return subListUnchecked ( fromIndex , toIndex ) ; } } 
public static < T , K , V > Collector < T , ? , ImmutableListMultimap < K , V > > flatteningToImmutableListMultimap ( Function < ? super T , ? extends K > keyFunction , Function < ? super T , ? extends Stream < ? extends V > > valuesFunction ) { checkNotNull ( keyFunction ) ; checkNotNull ( valuesFunction ) ; return Collectors.collectingAndThen ( Multimaps.flatteningToMultimap ( input - > checkNotNull ( keyFunction.apply ( input ) ) , input - > valuesFunction.apply ( input ) .peek ( Preconditions::checkNotNull ) , MultimapBuilder.linkedHashKeys ( ) .arrayListValues ( ) :: < K , V > build ) , ImmutableListMultimap::copyOf ) ; } 
public static < K , V > ImmutableListMultimap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 ) { ImmutableListMultimap.Builder < K , V > builder = ImmutableListMultimap.builder ( ) ; builder.put ( k1 , v1 ) ; builder.put ( k2 , v2 ) ; builder.put ( k3 , v3 ) ; return builder.build ( ) ; } 
public static < K , V > ImmutableListMultimap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 ) { ImmutableListMultimap.Builder < K , V > builder = ImmutableListMultimap.builder ( ) ; builder.put ( k1 , v1 ) ; builder.put ( k2 , v2 ) ; builder.put ( k3 , v3 ) ; builder.put ( k4 , v4 ) ; return builder.build ( ) ; } 
public static < K , V > ImmutableListMultimap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 , K k5 , V v5 ) { ImmutableListMultimap.Builder < K , V > builder = ImmutableListMultimap.builder ( ) ; builder.put ( k1 , v1 ) ; builder.put ( k2 , v2 ) ; builder.put ( k3 , v3 ) ; builder.put ( k4 , v4 ) ; builder.put ( k5 , v5 ) ; return builder.build ( ) ; } 
public static < K , V > ImmutableListMultimap < K , V > copyOf ( Multimap < ? extends K , ? extends V > multimap ) { if ( multimap.isEmpty ( ) ) { return of ( ) ; } if ( multimap instanceof ImmutableListMultimap ) { @SuppressWarnings ( " unchecked " ) ImmutableListMultimap < K , V > kvMultimap = ( ImmutableListMultimap < K , V > ) multimap ; if ( !kvMultimap.isPartialView ( ) ) { return kvMultimap ; } } return fromMapEntries ( multimap.asMap ( ) .entrySet ( ) , null ) ; } 
static < K , V > ImmutableListMultimap < K , V > fromMapEntries ( Collection < ? extends Map.Entry < ? extends K , ? extends Collection < ? extends V > > > mapEntries , @Nullable Comparator < ? super V > valueComparator ) { if ( mapEntries.isEmpty ( ) ) { return of ( ) ; } ImmutableMap.Builder < K , ImmutableList < V > > builder = new ImmutableMap.Builder < > ( mapEntries.size ( ) ) ; int size = 0 ; for ( Entry < ? extends K , ? extends Collection < ? extends V > > entry : mapEntries ) { K key = entry.getKey ( ) ; Collection < ? extends V > values = entry.getValue ( ) ; ImmutableList < V > list = ( valueComparator == null ) ? ImmutableList.copyOf ( values ) : ImmutableList.sortedCopyOf ( valueComparator , values ) ; if ( !list.isEmpty ( ) ) { builder.put ( key , list ) ; size += list.size ( ) ; } } return new ImmutableListMultimap < > ( builder.build ( ) , size ) ; } 
public ImmutableList < V > replaceValues ( K key , Iterable < ? extends V > values ) { throw new UnsupportedOperationException ( ) ; } 
private void readObject ( ObjectInputStream stream ) throws IOException , ClassNotFoundException { stream.defaultReadObject ( ) ; int keyCount = stream.readInt ( ) ; if ( keyCount < 0 ) { throw new InvalidObjectException ( " Invalid key count " + keyCount ) ; } ImmutableMap.Builder < Object , ImmutableList < Object > > builder = ImmutableMap.builder ( ) ; int tmpSize = 0 ; for ( int i = 0 ; i < keyCount ; i++ ) { Object key = stream.readObject ( ) ; int valueCount = stream.readInt ( ) ; if ( valueCount < = 0 ) { throw new InvalidObjectException ( " Invalid value count " + valueCount ) ; } ImmutableList.Builder < Object > valuesBuilder = ImmutableList.builder ( ) ; for ( int j = 0 ; j < valueCount ; j++ ) { valuesBuilder.add ( stream.readObject ( ) ) ; } builder.put ( key , valuesBuilder.build ( ) ) ; tmpSize += valueCount ; } ImmutableMap < Object , ImmutableList < Object > > tmpMap ; try { tmpMap = builder.build ( ) ; } catch ( IllegalArgumentException e ) { throw ( InvalidObjectException ) new InvalidObjectException ( e.getMessage ( ) ) .initCause ( e ) ; } FieldSettersHolder.MAP_FIELD_SETTER.set ( this , tmpMap ) ; FieldSettersHolder.SIZE_FIELD_SETTER.set ( this , tmpSize ) ; } 
public static < T , K , V > Collector < T , ? , ImmutableMap < K , V > > toImmutableMap ( Function < ? super T , ? extends K > keyFunction , Function < ? super T , ? extends V > valueFunction ) { return CollectCollectors.toImmutableMap ( keyFunction , valueFunction ) ; } 
public static < T , K , V > Collector < T , ? , ImmutableMap < K , V > > toImmutableMap ( Function < ? super T , ? extends K > keyFunction , Function < ? super T , ? extends V > valueFunction , BinaryOperator < V > mergeFunction ) { checkNotNull ( keyFunction ) ; checkNotNull ( valueFunction ) ; checkNotNull ( mergeFunction ) ; return Collectors.collectingAndThen ( Collectors.toMap ( keyFunction , valueFunction , mergeFunction , LinkedHashMap::new ) , ImmutableMap::copyOf ) ; } 
public static < K , V > ImmutableMap < K , V > of ( K k1 , V v1 , K k2 , V v2 ) { return RegularImmutableMap.fromEntries ( entryOf ( k1 , v1 ) , entryOf ( k2 , v2 ) ) ; } 
public static < K , V > ImmutableMap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 ) { return RegularImmutableMap.fromEntries ( entryOf ( k1 , v1 ) , entryOf ( k2 , v2 ) , entryOf ( k3 , v3 ) ) ; } 
public static < K , V > ImmutableMap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 ) { return RegularImmutableMap.fromEntries ( entryOf ( k1 , v1 ) , entryOf ( k2 , v2 ) , entryOf ( k3 , v3 ) , entryOf ( k4 , v4 ) ) ; } 
public static < K , V > ImmutableMap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 , K k5 , V v5 ) { return RegularImmutableMap.fromEntries ( entryOf ( k1 , v1 ) , entryOf ( k2 , v2 ) , entryOf ( k3 , v3 ) , entryOf ( k4 , v4 ) , entryOf ( k5 , v5 ) ) ; } 
static void checkNoConflict ( boolean safe , String conflictDescription , Entry < ? , ? > entry1 , Entry < ? , ? > entry2 ) { if ( !safe ) { throw conflictException ( conflictDescription , entry1 , entry2 ) ; } } 
public ImmutableMap < K , V > build ( ) { if ( valueComparator != null ) { if ( entriesUsed ) { entries = Arrays.copyOf ( entries , size ) ; } Arrays.sort ( entries , 0 , size , Ordering.from ( valueComparator ) .onResultOf ( Maps. < V > valueFunction ( ) ) ) ; } switch ( size ) { case 0: return of ( ) ; case 1: return of ( entries[0].getKey ( ) , entries[0].getValue ( ) ) ; default: entriesUsed = true ; return RegularImmutableMap.fromEntryArray ( size , entries ) ; } } 
ImmutableMap < K , V > buildJdkBacked ( ) { checkState ( valueComparator == null , " buildJdkBacked is only for testing ; can't use valueComparator " ) ; switch ( size ) { case 0: return of ( ) ; case 1: return of ( entries[0].getKey ( ) , entries[0].getValue ( ) ) ; default: entriesUsed = true ; return JdkBackedImmutableMap.create ( size , entries ) ; } } 
public static < K , V > ImmutableMap < K , V > copyOf ( Iterable < ? extends Entry < ? extends K , ? extends V > > entries ) { @SuppressWarnings ( " unchecked " ) Entry < K , V > [] entryArray = ( Entry < K , V > [] ) Iterables.toArray ( entries , EMPTY_ENTRY_ARRAY ) ; switch ( entryArray.length ) { case 0: return of ( ) ; case 1: Entry < K , V > onlyEntry = entryArray[0] ; return of ( onlyEntry.getKey ( ) , onlyEntry.getValue ( ) ) ; default: return RegularImmutableMap.fromEntries ( entryArray ) ; } } 
ImmutableSet < Entry < K , V > > createEntrySet ( ) { class EntrySetImpl extends ImmutableMapEntrySet < K , V > { @Override ImmutableMap < K , V > map ( ) { return IteratorBasedImmutableMap.this ; } @Override public UnmodifiableIterator < Entry < K , V > > iterator ( ) { return entryIterator ( ) ; } } return new EntrySetImpl ( ) ; } 
public final boolean remove ( Object key , Object value ) { throw new UnsupportedOperationException ( ) ; } 
UnmodifiableIterator < K > keyIterator ( ) { final UnmodifiableIterator < Entry < K , V > > entryIterator = entrySet ( ) .iterator ( ) ; return new UnmodifiableIterator < K > ( ) { @Override public boolean hasNext ( ) { return entryIterator.hasNext ( ) ; } @Override public K next ( ) { return entryIterator.next ( ) .getKey ( ) ; } } ; } 
UnmodifiableIterator < Entry < K , ImmutableSet < V > > > entryIterator ( ) { final Iterator < Entry < K , V > > backingIterator = ImmutableMap.this.entrySet ( ) .iterator ( ) ; return new UnmodifiableIterator < Entry < K , ImmutableSet < V > > > ( ) { @Override public boolean hasNext ( ) { return backingIterator.hasNext ( ) ; } @Override public Entry < K , ImmutableSet < V > > next ( ) { final Entry < K , V > backingEntry = backingIterator.next ( ) ; return new AbstractMapEntry < K , ImmutableSet < V > > ( ) { @Override public K getKey ( ) { return backingEntry.getKey ( ) ; } @Override public ImmutableSet < V > getValue ( ) { return ImmutableSet.of ( backingEntry.getValue ( ) ) ; } } ; } } ; } 
public Entry < K , ImmutableSet < V > > next ( ) { final Entry < K , V > backingEntry = backingIterator.next ( ) ; return new AbstractMapEntry < K , ImmutableSet < V > > ( ) { @Override public K getKey ( ) { return backingEntry.getKey ( ) ; } @Override public ImmutableSet < V > getValue ( ) { return ImmutableSet.of ( backingEntry.getValue ( ) ) ; } } ; } 
public UnmodifiableIterator < V > iterator ( ) { return new UnmodifiableIterator < V > ( ) { final UnmodifiableIterator < Entry < K , V > > entryItr = map.entrySet ( ) .iterator ( ) ; @Override public boolean hasNext ( ) { return entryItr.hasNext ( ) ; } @Override public V next ( ) { return entryItr.next ( ) .getValue ( ) ; } } ; } 
public ImmutableList < V > asList ( ) { final ImmutableList < Entry < K , V > > entryList = map.entrySet ( ) .asList ( ) ; return new ImmutableAsList < V > ( ) { @Override public V get ( int index ) { return entryList.get ( index ) .getValue ( ) ; } @Override ImmutableCollection < V > delegateCollection ( ) { return ImmutableMapValues.this ; } } ; } 
public static < K , V > ImmutableMultimap < K , V > of ( K k1 , V v1 , K k2 , V v2 ) { return ImmutableListMultimap.of ( k1 , v1 , k2 , v2 ) ; } 
public static < K , V > ImmutableMultimap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 ) { return ImmutableListMultimap.of ( k1 , v1 , k2 , v2 , k3 , v3 ) ; } 
public static < K , V > ImmutableMultimap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 ) { return ImmutableListMultimap.of ( k1 , v1 , k2 , v2 , k3 , v3 , k4 , v4 ) ; } 
public static < K , V > ImmutableMultimap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 , K k5 , V v5 ) { return ImmutableListMultimap.of ( k1 , v1 , k2 , v2 , k3 , v3 , k4 , v4 , k5 , v5 ) ; } 
public Builder < K , V > putAll ( K key , Iterable < ? extends V > values ) { if ( key == null ) { throw new NullPointerException ( " null key in entry: null= " + Iterables.toString ( values ) ) ; } Collection < V > valueCollection = builderMap.get ( key ) ; if ( valueCollection != null ) { for ( V value : values ) { checkEntryNotNull ( key , value ) ; valueCollection.add ( value ) ; } return this ; } Iterator < ? extends V > valuesItr = values.iterator ( ) ; if ( !valuesItr.hasNext ( ) ) { return this ; } valueCollection = newMutableValueCollection ( ) ; while ( valuesItr.hasNext ( ) ) { V value = valuesItr.next ( ) ; checkEntryNotNull ( key , value ) ; valueCollection.add ( value ) ; } builderMap.put ( key , valueCollection ) ; return this ; } 
public static < K , V > ImmutableMultimap < K , V > copyOf ( Multimap < ? extends K , ? extends V > multimap ) { if ( multimap instanceof ImmutableMultimap ) { @SuppressWarnings ( " unchecked " ) ImmutableMultimap < K , V > kvMultimap = ( ImmutableMultimap < K , V > ) multimap ; if ( !kvMultimap.isPartialView ( ) ) { return kvMultimap ; } } return ImmutableListMultimap.copyOf ( multimap ) ; } 
public static < K , V > ImmutableMultimap < K , V > copyOf ( Iterable < ? extends Entry < ? extends K , ? extends V > > entries ) { return ImmutableListMultimap.copyOf ( entries ) ; } 
UnmodifiableIterator < V > valueIterator ( ) { return new UnmodifiableIterator < V > ( ) { Iterator < ? extends ImmutableCollection < V > > valueCollectionItr = map.values ( ) .iterator ( ) ; Iterator < V > valueItr = Iterators.emptyIterator ( ) ; @Override public boolean hasNext ( ) { return valueItr.hasNext ( ) || valueCollectionItr.hasNext ( ) ; } @Override public V next ( ) { if ( !valueItr.hasNext ( ) ) { valueItr = valueCollectionItr.next ( ) .iterator ( ) ; } return valueItr.next ( ) ; } } ; } 
public static < E > ImmutableMultiset < E > of ( E e1 , E e2 , E e3 , E e4 ) { return copyFromElements ( e1 , e2 , e3 , e4 ) ; } 
public static < E > ImmutableMultiset < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 ) { return copyFromElements ( e1 , e2 , e3 , e4 , e5 ) ; } 
public static < E > ImmutableMultiset < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E... others ) { return new Builder < E > ( ) .add ( e1 ) .add ( e2 ) .add ( e3 ) .add ( e4 ) .add ( e5 ) .add ( e6 ) .add ( others ) .build ( ) ; } 
public static < E > ImmutableMultiset < E > copyOf ( Iterable < ? extends E > elements ) { if ( elements instanceof ImmutableMultiset ) { @SuppressWarnings ( " unchecked " ) ImmutableMultiset < E > result = ( ImmutableMultiset < E > ) elements ; if ( !result.isPartialView ( ) ) { return result ; } } Multiset < ? extends E > multiset = ( elements instanceof Multiset ) ? Multisets.cast ( elements ) : LinkedHashMultiset.create ( elements ) ; return copyFromEntries ( multiset.entrySet ( ) ) ; } 
public UnmodifiableIterator < E > iterator ( ) { final Iterator < Entry < E > > entryIterator = entrySet ( ) .iterator ( ) ; return new UnmodifiableIterator < E > ( ) { int remaining ; @MonotonicNonNull E element ; @Override public boolean hasNext ( ) { return ( remaining > 0 ) || entryIterator.hasNext ( ) ; } @Override public E next ( ) { if ( remaining < = 0 ) { Entry < E > entry = entryIterator.next ( ) ; element = entry.getElement ( ) ; remaining = entry.getCount ( ) ; } remaining-- ; return element ; } } ; } 
public ImmutableRangeMap < K , V > subRangeMap ( final Range < K > range ) { if ( checkNotNull ( range ) .isEmpty ( ) ) { return ImmutableRangeMap.of ( ) ; } else if ( ranges.isEmpty ( ) || range.encloses ( span ( ) ) ) { return this ; } int lowerIndex = SortedLists.binarySearch ( ranges , Range. < K > upperBoundFn ( ) , range.lowerBound , KeyPresentBehavior.FIRST_AFTER , KeyAbsentBehavior.NEXT_HIGHER ) ; int upperIndex = SortedLists.binarySearch ( ranges , Range. < K > lowerBoundFn ( ) , range.upperBound , KeyPresentBehavior.ANY_PRESENT , KeyAbsentBehavior.NEXT_HIGHER ) ; if ( lowerIndex > = upperIndex ) { return ImmutableRangeMap.of ( ) ; } final int off = lowerIndex ; final int len = upperIndex - lowerIndex ; ImmutableList < Range < K > > subRanges = new ImmutableList < Range < K > > ( ) { @Override public int size ( ) { return len ; } @Override public Range < K > get ( int index ) { checkElementIndex ( index , len ) ; if ( index == 0 || index == len - 1 ) { return ranges.get ( index + off ) .intersection ( range ) ; } else { return ranges.get ( index + off ) ; } } @Override boolean isPartialView ( ) { return true ; } } ; final ImmutableRangeMap < K , V > outer = this ; return new ImmutableRangeMap < K , V > ( subRanges , values.subList ( lowerIndex , upperIndex ) ) { @Override public ImmutableRangeMap < K , V > subRangeMap ( Range < K > subRange ) { if ( range.isConnected ( subRange ) ) { return outer.subRangeMap ( subRange.intersection ( range ) ) ; } else { return ImmutableRangeMap.of ( ) ; } } } ; } 
public static < C extends Comparable > ImmutableRangeSet < C > of ( Range < C > range ) { checkNotNull ( range ) ; if ( range.isEmpty ( ) ) { return of ( ) ; } else if ( range.equals ( Range.all ( ) ) ) { return all ( ) ; } else { return new ImmutableRangeSet < C > ( ImmutableList.of ( range ) ) ; } } 
public static < C extends Comparable > ImmutableRangeSet < C > copyOf ( RangeSet < C > rangeSet ) { checkNotNull ( rangeSet ) ; if ( rangeSet.isEmpty ( ) ) { return of ( ) ; } else if ( rangeSet.encloses ( Range. < C > all ( ) ) ) { return all ( ) ; } if ( rangeSet instanceof ImmutableRangeSet ) { ImmutableRangeSet < C > immutableRangeSet = ( ImmutableRangeSet < C > ) rangeSet ; if ( !immutableRangeSet.isPartialView ( ) ) { return immutableRangeSet ; } } return new ImmutableRangeSet < C > ( ImmutableList.copyOf ( rangeSet.asRanges ( ) ) ) ; } 
public boolean intersects ( Range < C > otherRange ) { int ceilingIndex = SortedLists.binarySearch ( ranges , Range. < C > lowerBoundFn ( ) , otherRange.lowerBound , Ordering.natural ( ) , ANY_PRESENT , NEXT_HIGHER ) ; if ( ceilingIndex < ranges.size ( ) && ranges.get ( ceilingIndex ) .isConnected ( otherRange ) && !ranges.get ( ceilingIndex ) .intersection ( otherRange ) .isEmpty ( ) ) { return true ; } return ceilingIndex > 0 && ranges.get ( ceilingIndex - 1 ) .isConnected ( otherRange ) && !ranges.get ( ceilingIndex - 1 ) .intersection ( otherRange ) .isEmpty ( ) ; } 
public Range < C > get ( int index ) { checkElementIndex ( index , size ) ; Cut < C > lowerBound ; if ( positiveBoundedBelow ) { lowerBound = ( index == 0 ) ? Cut. < C > belowAll ( ) : ranges.get ( index - 1 ) .upperBound ; } else { lowerBound = ranges.get ( index ) .upperBound ; } Cut < C > upperBound ; if ( positiveBoundedAbove && index == size - 1 ) { upperBound = Cut. < C > aboveAll ( ) ; } else { upperBound = ranges.get ( index + ( positiveBoundedBelow ? 0 : 1 ) ) .lowerBound ; } return Range.create ( lowerBound , upperBound ) ; } 
public ImmutableRangeSet < C > complement ( ) { ImmutableRangeSet < C > result = complement ; if ( result != null ) { return result ; } else if ( ranges.isEmpty ( ) ) { return complement = all ( ) ; } else if ( ranges.size ( ) == 1 && ranges.get ( 0 ) .equals ( Range.all ( ) ) ) { return complement = of ( ) ; } else { ImmutableList < Range < C > > complementRanges = new ComplementRanges ( ) ; result = complement = new ImmutableRangeSet < C > ( complementRanges , this ) ; } return result ; } 
private ImmutableList < Range < C > > intersectRanges ( final Range < C > range ) { if ( ranges.isEmpty ( ) || range.isEmpty ( ) ) { return ImmutableList.of ( ) ; } else if ( range.encloses ( span ( ) ) ) { return ranges ; } final int fromIndex ; if ( range.hasLowerBound ( ) ) { fromIndex = SortedLists.binarySearch ( ranges , Range. < C > upperBoundFn ( ) , range.lowerBound , KeyPresentBehavior.FIRST_AFTER , KeyAbsentBehavior.NEXT_HIGHER ) ; } else { fromIndex = 0 ; } int toIndex ; if ( range.hasUpperBound ( ) ) { toIndex = SortedLists.binarySearch ( ranges , Range. < C > lowerBoundFn ( ) , range.upperBound , KeyPresentBehavior.FIRST_PRESENT , KeyAbsentBehavior.NEXT_HIGHER ) ; } else { toIndex = ranges.size ( ) ; } final int length = toIndex - fromIndex ; if ( length == 0 ) { return ImmutableList.of ( ) ; } else { return new ImmutableList < Range < C > > ( ) { @Override public int size ( ) { return length ; } @Override public Range < C > get ( int index ) { checkElementIndex ( index , length ) ; if ( index == 0 || index == length - 1 ) { return ranges.get ( index + fromIndex ) .intersection ( range ) ; } else { return ranges.get ( index + fromIndex ) ; } } @Override boolean isPartialView ( ) { return true ; } } ; } } 
public int size ( ) { Integer result = size ; if ( result == null ) { long total = 0 ; for ( Range < C > range : ranges ) { total += ContiguousSet.create ( range , domain ) .size ( ) ; if ( total > = Integer.MAX_VALUE ) { break ; } } result = size = Ints.saturatedCast ( total ) ; } return result.intValue ( ) ; } 
public UnmodifiableIterator < C > iterator ( ) { return new AbstractIterator < C > ( ) { final Iterator < Range < C > > rangeItr = ranges.iterator ( ) ; Iterator < C > elemItr = Iterators.emptyIterator ( ) ; @Override protected C computeNext ( ) { while ( !elemItr.hasNext ( ) ) { if ( rangeItr.hasNext ( ) ) { elemItr = ContiguousSet.create ( rangeItr.next ( ) , domain ) .iterator ( ) ; } else { return endOfData ( ) ; } } return elemItr.next ( ) ; } } ; } 
public UnmodifiableIterator < C > descendingIterator ( ) { return new AbstractIterator < C > ( ) { final Iterator < Range < C > > rangeItr = ranges.reverse ( ) .iterator ( ) ; Iterator < C > elemItr = Iterators.emptyIterator ( ) ; @Override protected C computeNext ( ) { while ( !elemItr.hasNext ( ) ) { if ( rangeItr.hasNext ( ) ) { elemItr = ContiguousSet.create ( rangeItr.next ( ) , domain ) .descendingIterator ( ) ; } else { return endOfData ( ) ; } } return elemItr.next ( ) ; } } ; } 
public ImmutableRangeSet < C > build ( ) { ImmutableList.Builder < Range < C > > mergedRangesBuilder = new ImmutableList.Builder < > ( ranges.size ( ) ) ; Collections.sort ( ranges , Range. < C > rangeLexOrdering ( ) ) ; PeekingIterator < Range < C > > peekingItr = Iterators.peekingIterator ( ranges.iterator ( ) ) ; while ( peekingItr.hasNext ( ) ) { Range < C > range = peekingItr.next ( ) ; while ( peekingItr.hasNext ( ) ) { Range < C > nextRange = peekingItr.peek ( ) ; if ( range.isConnected ( nextRange ) ) { checkArgument ( range.intersection ( nextRange ) .isEmpty ( ) , " Overlapping ranges not permitted but found %s overlapping %s " , range , nextRange ) ; range = range.span ( peekingItr.next ( ) ) ; } else { break ; } } mergedRangesBuilder.add ( range ) ; } ImmutableList < Range < C > > mergedRanges = mergedRangesBuilder.build ( ) ; if ( mergedRanges.isEmpty ( ) ) { return of ( ) ; } else if ( mergedRanges.size ( ) == 1 && Iterables.getOnlyElement ( mergedRanges ) .equals ( Range.all ( ) ) ) { return all ( ) ; } else { return new ImmutableRangeSet < C > ( mergedRanges ) ; } } 
public static < E > ImmutableSet < E > of ( E e1 , E e2 , E e3 ) { return construct ( 3 , 3 , e1 , e2 , e3 ) ; } 
public static < E > ImmutableSet < E > of ( E e1 , E e2 , E e3 , E e4 ) { return construct ( 4 , 4 , e1 , e2 , e3 , e4 ) ; } 
public static < E > ImmutableSet < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 ) { return construct ( 5 , 5 , e1 , e2 , e3 , e4 , e5 ) ; } 
public static < E > ImmutableSet < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E... others ) { checkArgument ( others.length < = Integer.MAX_VALUE - 6 , " the total number of elements must fit in an int " ) ; final int paramCount = 6 ; Object[] elements = new Object[paramCount + others.length] ; elements[0] = e1 ; elements[1] = e2 ; elements[2] = e3 ; elements[3] = e4 ; elements[4] = e5 ; elements[5] = e6 ; System.arraycopy ( others , 0 , elements , paramCount , others.length ) ; return construct ( elements.length , elements.length , elements ) ; } 
private static < E > ImmutableSet < E > construct ( int n , int expectedSize , Object... elements ) { switch ( n ) { case 0: return of ( ) ; case 1: @SuppressWarnings ( " unchecked " ) E elem = ( E ) elements[0] ; return of ( elem ) ; default: SetBuilderImpl < E > builder = new RegularSetBuilderImpl < E > ( expectedSize ) ; for ( int i = 0 ; i < n ; i++ ) { @SuppressWarnings ( " unchecked " ) E e = ( E ) checkNotNull ( elements[i] ) ; builder = builder.add ( e ) ; } return builder.review ( ) .build ( ) ; } } 
public static < E > ImmutableSet < E > copyOf ( Collection < ? extends E > elements ) { if ( elements instanceof ImmutableSet && ! ( elements instanceof SortedSet ) ) { @SuppressWarnings ( " unchecked " ) ImmutableSet < E > set = ( ImmutableSet < E > ) elements ; if ( !set.isPartialView ( ) ) { return set ; } } else if ( elements instanceof EnumSet ) { return copyOfEnumSet ( ( EnumSet ) elements ) ; } Object[] array = elements.toArray ( ) ; if ( elements instanceof Set ) { return construct ( array.length , array.length , array ) ; } else { return constructUnknownDuplication ( array.length , array ) ; } } 
ImmutableList < E > createAsList ( ) { return new ImmutableAsList < E > ( ) { @Override public E get ( int index ) { return Indexed.this.get ( index ) ; } @Override Indexed < E > delegateCollection ( ) { return Indexed.this ; } } ; } 
static Object[] rebuildHashTable ( int newTableSize , Object[] elements , int n ) { Object[] hashTable = new Object[newTableSize] ; int mask = hashTable.length - 1 ; for ( int i = 0 ; i < n ; i++ ) { Object e = elements[i] ; int j0 = Hashing.smear ( e.hashCode ( ) ) ; for ( int j = j0 ; ; j++ ) { int index = j & mask ; if ( hashTable[index] == null ) { hashTable[index] = e ; break ; } } } return hashTable ; } 
static boolean hashFloodingDetected ( Object[] hashTable ) { int maxRunBeforeFallback = maxRunBeforeFallback ( hashTable.length ) ; int endOfStartRun ; for ( endOfStartRun = 0 ; endOfStartRun < hashTable.length ; ) { if ( hashTable[endOfStartRun] == null ) { break ; } endOfStartRun++ ; if ( endOfStartRun > maxRunBeforeFallback ) { return true ; } } int startOfEndRun ; for ( startOfEndRun = hashTable.length - 1 ; startOfEndRun > endOfStartRun ; startOfEndRun-- ) { if ( hashTable[startOfEndRun] == null ) { break ; } if ( endOfStartRun + ( hashTable.length - 1 - startOfEndRun ) > maxRunBeforeFallback ) { return true ; } } int testBlockSize = maxRunBeforeFallback / 2 ; blockLoop: for ( int i = endOfStartRun + 1 ; i + testBlockSize < = startOfEndRun ; i += testBlockSize ) { for ( int j = 0 ; j < testBlockSize ; j++ ) { if ( hashTable[i + j] == null ) { continue blockLoop ; } } return true ; } return false ; } 
SetBuilderImpl < E > add ( E e ) { checkNotNull ( e ) ; int eHash = e.hashCode ( ) ; int i0 = Hashing.smear ( eHash ) ; int mask = hashTable.length - 1 ; for ( int i = i0 ; i - i0 < maxRunBeforeFallback ; i++ ) { int index = i & mask ; Object tableEntry = hashTable[index] ; if ( tableEntry == null ) { addDedupedElement ( e ) ; hashTable[index] = e ; hashCode += eHash ; ensureTableCapacity ( distinct ) ; return this ; } else if ( tableEntry.equals ( e ) ) { return this ; } } return new JdkBackedSetBuilderImpl < E > ( this ) .add ( e ) ; } 
ImmutableSet < E > build ( ) { switch ( distinct ) { case 0: return of ( ) ; case 1: return of ( dedupedElements[0] ) ; default: return new JdkBackedImmutableSet < E > ( delegate , ImmutableList.asImmutableList ( dedupedElements , distinct ) ) ; } } 
public static < T , K , V > Collector < T , ? , ImmutableSetMultimap < K , V > > toImmutableSetMultimap ( Function < ? super T , ? extends K > keyFunction , Function < ? super T , ? extends V > valueFunction ) { checkNotNull ( keyFunction , " keyFunction " ) ; checkNotNull ( valueFunction , " valueFunction " ) ; return Collector.of ( ImmutableSetMultimap:: < K , V > builder , ( builder , t ) - > builder.put ( keyFunction.apply ( t ) , valueFunction.apply ( t ) ) , ImmutableSetMultimap.Builder::combine , ImmutableSetMultimap.Builder::build ) ; } 
public static < T , K , V > Collector < T , ? , ImmutableSetMultimap < K , V > > flatteningToImmutableSetMultimap ( Function < ? super T , ? extends K > keyFunction , Function < ? super T , ? extends Stream < ? extends V > > valuesFunction ) { checkNotNull ( keyFunction ) ; checkNotNull ( valuesFunction ) ; return Collectors.collectingAndThen ( Multimaps.flatteningToMultimap ( input - > checkNotNull ( keyFunction.apply ( input ) ) , input - > valuesFunction.apply ( input ) .peek ( Preconditions::checkNotNull ) , MultimapBuilder.linkedHashKeys ( ) .linkedHashSetValues ( ) :: < K , V > build ) , ImmutableSetMultimap::copyOf ) ; } 
public static < K , V > ImmutableSetMultimap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 ) { ImmutableSetMultimap.Builder < K , V > builder = ImmutableSetMultimap.builder ( ) ; builder.put ( k1 , v1 ) ; builder.put ( k2 , v2 ) ; builder.put ( k3 , v3 ) ; return builder.build ( ) ; } 
public static < K , V > ImmutableSetMultimap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 ) { ImmutableSetMultimap.Builder < K , V > builder = ImmutableSetMultimap.builder ( ) ; builder.put ( k1 , v1 ) ; builder.put ( k2 , v2 ) ; builder.put ( k3 , v3 ) ; builder.put ( k4 , v4 ) ; return builder.build ( ) ; } 
public static < K , V > ImmutableSetMultimap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 , K k5 , V v5 ) { ImmutableSetMultimap.Builder < K , V > builder = ImmutableSetMultimap.builder ( ) ; builder.put ( k1 , v1 ) ; builder.put ( k2 , v2 ) ; builder.put ( k3 , v3 ) ; builder.put ( k4 , v4 ) ; builder.put ( k5 , v5 ) ; return builder.build ( ) ; } 
static < K , V > ImmutableSetMultimap < K , V > fromMapEntries ( Collection < ? extends Map.Entry < ? extends K , ? extends Collection < ? extends V > > > mapEntries , @Nullable Comparator < ? super V > valueComparator ) { if ( mapEntries.isEmpty ( ) ) { return of ( ) ; } ImmutableMap.Builder < K , ImmutableSet < V > > builder = new ImmutableMap.Builder < > ( mapEntries.size ( ) ) ; int size = 0 ; for ( Entry < ? extends K , ? extends Collection < ? extends V > > entry : mapEntries ) { K key = entry.getKey ( ) ; Collection < ? extends V > values = entry.getValue ( ) ; ImmutableSet < V > set = valueSet ( valueComparator , values ) ; if ( !set.isEmpty ( ) ) { builder.put ( key , set ) ; size += set.size ( ) ; } } return new ImmutableSetMultimap < > ( builder.build ( ) , size , valueComparator ) ; } 
private void readObject ( ObjectInputStream stream ) throws IOException , ClassNotFoundException { stream.defaultReadObject ( ) ; Comparator < Object > valueComparator = ( Comparator < Object > ) stream.readObject ( ) ; int keyCount = stream.readInt ( ) ; if ( keyCount < 0 ) { throw new InvalidObjectException ( " Invalid key count " + keyCount ) ; } ImmutableMap.Builder < Object , ImmutableSet < Object > > builder = ImmutableMap.builder ( ) ; int tmpSize = 0 ; for ( int i = 0 ; i < keyCount ; i++ ) { Object key = stream.readObject ( ) ; int valueCount = stream.readInt ( ) ; if ( valueCount < = 0 ) { throw new InvalidObjectException ( " Invalid value count " + valueCount ) ; } ImmutableSet.Builder < Object > valuesBuilder = valuesBuilder ( valueComparator ) ; for ( int j = 0 ; j < valueCount ; j++ ) { valuesBuilder.add ( stream.readObject ( ) ) ; } ImmutableSet < Object > valueSet = valuesBuilder.build ( ) ; if ( valueSet.size ( ) != valueCount ) { throw new InvalidObjectException ( " Duplicate key-value pairs exist for key " + key ) ; } builder.put ( key , valueSet ) ; tmpSize += valueCount ; } ImmutableMap < Object , ImmutableSet < Object > > tmpMap ; try { tmpMap = builder.build ( ) ; } catch ( IllegalArgumentException e ) { throw ( InvalidObjectException ) new InvalidObjectException ( e.getMessage ( ) ) .initCause ( e ) ; } FieldSettersHolder.MAP_FIELD_SETTER.set ( this , tmpMap ) ; FieldSettersHolder.SIZE_FIELD_SETTER.set ( this , tmpSize ) ; SetFieldSettersHolder.EMPTY_SET_FIELD_SETTER.set ( this , emptySet ( valueComparator ) ) ; } 
public static < T , K , V > Collector < T , ? , ImmutableSortedMap < K , V > > toImmutableSortedMap ( Comparator < ? super K > comparator , Function < ? super T , ? extends K > keyFunction , Function < ? super T , ? extends V > valueFunction ) { return CollectCollectors.toImmutableSortedMap ( comparator , keyFunction , valueFunction ) ; } 
public static < T , K , V > Collector < T , ? , ImmutableSortedMap < K , V > > toImmutableSortedMap ( Comparator < ? super K > comparator , Function < ? super T , ? extends K > keyFunction , Function < ? super T , ? extends V > valueFunction , BinaryOperator < V > mergeFunction ) { checkNotNull ( comparator ) ; checkNotNull ( keyFunction ) ; checkNotNull ( valueFunction ) ; checkNotNull ( mergeFunction ) ; return Collectors.collectingAndThen ( Collectors.toMap ( keyFunction , valueFunction , mergeFunction , ( ) - > new TreeMap < K , V > ( comparator ) ) , ImmutableSortedMap::copyOfSorted ) ; } 
public static < K extends Comparable < ? super K > , V > ImmutableSortedMap < K , V > of ( K k1 , V v1 , K k2 , V v2 ) { return ofEntries ( entryOf ( k1 , v1 ) , entryOf ( k2 , v2 ) ) ; } 
public static < K extends Comparable < ? super K > , V > ImmutableSortedMap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 ) { return ofEntries ( entryOf ( k1 , v1 ) , entryOf ( k2 , v2 ) , entryOf ( k3 , v3 ) ) ; } 
public static < K extends Comparable < ? super K > , V > ImmutableSortedMap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 ) { return ofEntries ( entryOf ( k1 , v1 ) , entryOf ( k2 , v2 ) , entryOf ( k3 , v3 ) , entryOf ( k4 , v4 ) ) ; } 
public static < K extends Comparable < ? super K > , V > ImmutableSortedMap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 , K k5 , V v5 ) { return ofEntries ( entryOf ( k1 , v1 ) , entryOf ( k2 , v2 ) , entryOf ( k3 , v3 ) , entryOf ( k4 , v4 ) , entryOf ( k5 , v5 ) ) ; } 
public static < K , V > ImmutableSortedMap < K , V > copyOf ( Iterable < ? extends Entry < ? extends K , ? extends V > > entries , Comparator < ? super K > comparator ) { return fromEntries ( checkNotNull ( comparator ) , false , entries ) ; } 
private static < K , V > ImmutableSortedMap < K , V > copyOfInternal ( Map < ? extends K , ? extends V > map , Comparator < ? super K > comparator ) { boolean sameComparator = false ; if ( map instanceof SortedMap ) { SortedMap < ? , ? > sortedMap = ( SortedMap < ? , ? > ) map ; Comparator < ? > comparator2 = sortedMap.comparator ( ) ; sameComparator = ( comparator2 == null ) ? comparator == NATURAL_ORDER : comparator.equals ( comparator2 ) ; } if ( sameComparator && ( map instanceof ImmutableSortedMap ) ) { @SuppressWarnings ( " unchecked " ) ImmutableSortedMap < K , V > kvMap = ( ImmutableSortedMap < K , V > ) map ; if ( !kvMap.isPartialView ( ) ) { return kvMap ; } } return fromEntries ( comparator , sameComparator , map.entrySet ( ) ) ; } 
private static < K , V > ImmutableSortedMap < K , V > fromEntries ( Comparator < ? super K > comparator , boolean sameComparator , Iterable < ? extends Entry < ? extends K , ? extends V > > entries ) { @SuppressWarnings ( " unchecked " ) Entry < K , V > [] entryArray = ( Entry[] ) Iterables.toArray ( entries , EMPTY_ENTRY_ARRAY ) ; return fromEntries ( comparator , sameComparator , entryArray , entryArray.length ) ; } 
private static < K , V > ImmutableSortedMap < K , V > fromEntries ( final Comparator < ? super K > comparator , boolean sameComparator , Entry < K , V > [] entryArray , int size ) { switch ( size ) { case 0: return emptyMap ( comparator ) ; case 1: return ImmutableSortedMap. < K , V > of ( comparator , entryArray[0].getKey ( ) , entryArray[0].getValue ( ) ) ; default: Object[] keys = new Object[size] ; Object[] values = new Object[size] ; if ( sameComparator ) { for ( int i = 0 ; i < size ; i++ ) { Object key = entryArray[i].getKey ( ) ; Object value = entryArray[i].getValue ( ) ; checkEntryNotNull ( key , value ) ; keys[i] = key ; values[i] = value ; } } else { Arrays.sort ( entryArray , 0 , size , new Comparator < Entry < K , V > > ( ) { @Override public int compare ( Entry < K , V > e1 , Entry < K , V > e2 ) { return comparator.compare ( e1.getKey ( ) , e2.getKey ( ) ) ; } } ) ; K prevKey = entryArray[0].getKey ( ) ; keys[0] = prevKey ; values[0] = entryArray[0].getValue ( ) ; checkEntryNotNull ( keys[0] , values[0] ) ; for ( int i = 1 ; i < size ; i++ ) { K key = entryArray[i].getKey ( ) ; V value = entryArray[i].getValue ( ) ; checkEntryNotNull ( key , value ) ; keys[i] = key ; values[i] = value ; checkNoConflict ( comparator.compare ( prevKey , key ) != 0 , " key " , entryArray[i - 1] , entryArray[i] ) ; prevKey = key ; } } return new ImmutableSortedMap < > ( new RegularImmutableSortedSet < K > ( new RegularImmutableList < K > ( keys ) , comparator ) , new RegularImmutableList < V > ( values ) ) ; } } 
public ImmutableSortedMap < K , V > build ( ) { switch ( size ) { case 0: return emptyMap ( comparator ) ; case 1: return of ( comparator , entries[0].getKey ( ) , entries[0].getValue ( ) ) ; default: return fromEntries ( comparator , false , entries , size ) ; } } 
ImmutableSet < Entry < K , V > > createEntrySet ( ) { class EntrySet extends ImmutableMapEntrySet < K , V > { @Override public UnmodifiableIterator < Entry < K , V > > iterator ( ) { return asList ( ) .iterator ( ) ; } @Override public Spliterator < Entry < K , V > > spliterator ( ) { return asList ( ) .spliterator ( ) ; } @Override public void forEach ( Consumer < ? super Entry < K , V > > action ) { asList ( ) .forEach ( action ) ; } @Override ImmutableList < Entry < K , V > > createAsList ( ) { return new ImmutableAsList < Entry < K , V > > ( ) { @Override public Entry < K , V > get ( int index ) { return new AbstractMap.SimpleImmutableEntry < > ( keySet.asList ( ) .get ( index ) , valueList.get ( index ) ) ; } @Override public Spliterator < Entry < K , V > > spliterator ( ) { return CollectSpliterators.indexed ( size ( ) , ImmutableSet.SPLITERATOR_CHARACTERISTICS , this::get ) ; } @Override ImmutableCollection < Entry < K , V > > delegateCollection ( ) { return EntrySet.this ; } } ; } @Override ImmutableMap < K , V > map ( ) { return ImmutableSortedMap.this ; } } return isEmpty ( ) ? ImmutableSet. < Entry < K , V > > of ( ) : new EntrySet ( ) ; } 
ImmutableList < Entry < K , V > > createAsList ( ) { return new ImmutableAsList < Entry < K , V > > ( ) { @Override public Entry < K , V > get ( int index ) { return new AbstractMap.SimpleImmutableEntry < > ( keySet.asList ( ) .get ( index ) , valueList.get ( index ) ) ; } @Override public Spliterator < Entry < K , V > > spliterator ( ) { return CollectSpliterators.indexed ( size ( ) , ImmutableSet.SPLITERATOR_CHARACTERISTICS , this::get ) ; } @Override ImmutableCollection < Entry < K , V > > delegateCollection ( ) { return EntrySet.this ; } } ; } 
public static < K , V > ImmutableSortedMap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 ) { throw new UnsupportedOperationException ( ) ; } 
public static < K , V > ImmutableSortedMap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 ) { throw new UnsupportedOperationException ( ) ; } 
public static < K , V > ImmutableSortedMap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 , K k5 , V v5 ) { throw new UnsupportedOperationException ( ) ; } 
public static < T , E > Collector < T , ? , ImmutableSortedMultiset < E > > toImmutableSortedMultiset ( Comparator < ? super E > comparator , Function < ? super T , ? extends E > elementFunction , ToIntFunction < ? super T > countFunction ) { checkNotNull ( comparator ) ; checkNotNull ( elementFunction ) ; checkNotNull ( countFunction ) ; return Collector.of ( ( ) - > TreeMultiset.create ( comparator ) , ( multiset , t ) - > multiset.add ( checkNotNull ( elementFunction.apply ( t ) ) , countFunction.applyAsInt ( t ) ) , ( multiset1 , multiset2 ) - > { multiset1.addAll ( multiset2 ) ; return multiset1 ; } , ( Multiset < E > multiset ) - > copyOfSortedEntries ( comparator , multiset.entrySet ( ) ) ) ; } 
public static < E extends Comparable < ? super E > > ImmutableSortedMultiset < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 ) { return copyOf ( Ordering.natural ( ) , Arrays.asList ( e1 , e2 , e3 , e4 , e5 ) ) ; } 
public static < E extends Comparable < ? super E > > ImmutableSortedMultiset < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E... remaining ) { int size = remaining.length + 6 ; List < E > all = Lists.newArrayListWithCapacity ( size ) ; Collections.addAll ( all , e1 , e2 , e3 , e4 , e5 , e6 ) ; Collections.addAll ( all , remaining ) ; return copyOf ( Ordering.natural ( ) , all ) ; } 
public static < E > ImmutableSortedMultiset < E > copyOf ( Comparator < ? super E > comparator , Iterable < ? extends E > elements ) { if ( elements instanceof ImmutableSortedMultiset ) { @SuppressWarnings ( " unchecked " ) ImmutableSortedMultiset < E > multiset = ( ImmutableSortedMultiset < E > ) elements ; if ( comparator.equals ( multiset.comparator ( ) ) ) { if ( multiset.isPartialView ( ) ) { return copyOfSortedEntries ( comparator , multiset.entrySet ( ) .asList ( ) ) ; } else { return multiset ; } } } elements = Lists.newArrayList ( elements ) ; TreeMultiset < E > sortedCopy = TreeMultiset.create ( checkNotNull ( comparator ) ) ; Iterables.addAll ( sortedCopy , elements ) ; return copyOfSortedEntries ( comparator , sortedCopy.entrySet ( ) ) ; } 
private static < E > ImmutableSortedMultiset < E > copyOfSortedEntries ( Comparator < ? super E > comparator , Collection < Entry < E > > entries ) { if ( entries.isEmpty ( ) ) { return emptyMultiset ( comparator ) ; } ImmutableList.Builder < E > elementsBuilder = new ImmutableList.Builder < E > ( entries.size ( ) ) ; long[] cumulativeCounts = new long[entries.size ( ) + 1] ; int i = 0 ; for ( Entry < E > entry : entries ) { elementsBuilder.add ( entry.getElement ( ) ) ; cumulativeCounts[i + 1] = cumulativeCounts[i] + entry.getCount ( ) ; i++ ; } return new RegularImmutableSortedMultiset < E > ( new RegularImmutableSortedSet < E > ( elementsBuilder.build ( ) , comparator ) , cumulativeCounts , 0 , entries.size ( ) ) ; } 
public static < T , E > Collector < T , ? , ImmutableMultiset < E > > toImmutableMultiset ( Function < ? super T , ? extends E > elementFunction , ToIntFunction < ? super T > countFunction ) { throw new UnsupportedOperationException ( ) ; } 
public static < E > ImmutableSortedMultiset < E > of ( E e1 , E e2 , E e3 , E e4 ) { throw new UnsupportedOperationException ( ) ; } 
public static < E > ImmutableSortedMultiset < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 ) { throw new UnsupportedOperationException ( ) ; } 
public static < E > ImmutableSortedMultiset < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E... remaining ) { throw new UnsupportedOperationException ( ) ; } 
public static < E extends Comparable < ? super E > > ImmutableSortedSet < E > of ( E e1 , E e2 , E e3 , E e4 ) { return construct ( Ordering.natural ( ) , 4 , e1 , e2 , e3 , e4 ) ; } 
public static < E extends Comparable < ? super E > > ImmutableSortedSet < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 ) { return construct ( Ordering.natural ( ) , 5 , e1 , e2 , e3 , e4 , e5 ) ; } 
public static < E extends Comparable < ? super E > > ImmutableSortedSet < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E... remaining ) { Comparable[] contents = new Comparable[6 + remaining.length] ; contents[0] = e1 ; contents[1] = e2 ; contents[2] = e3 ; contents[3] = e4 ; contents[4] = e5 ; contents[5] = e6 ; System.arraycopy ( remaining , 0 , contents , 6 , remaining.length ) ; return construct ( Ordering.natural ( ) , contents.length , ( E[] ) contents ) ; } 
public static < E > ImmutableSortedSet < E > copyOf ( Comparator < ? super E > comparator , Iterable < ? extends E > elements ) { checkNotNull ( comparator ) ; boolean hasSameComparator = SortedIterables.hasSameComparator ( comparator , elements ) ; if ( hasSameComparator && ( elements instanceof ImmutableSortedSet ) ) { @SuppressWarnings ( " unchecked " ) ImmutableSortedSet < E > original = ( ImmutableSortedSet < E > ) elements ; if ( !original.isPartialView ( ) ) { return original ; } } @SuppressWarnings ( " unchecked " ) E[] array = ( E[] ) Iterables.toArray ( elements ) ; return construct ( comparator , array.length , array ) ; } 
static < E > ImmutableSortedSet < E > construct ( Comparator < ? super E > comparator , int n , E... contents ) { if ( n == 0 ) { return emptySet ( comparator ) ; } checkElementsNotNull ( contents , n ) ; Arrays.sort ( contents , 0 , n , comparator ) ; int uniques = 1 ; for ( int i = 1 ; i < n ; i++ ) { E cur = contents[i] ; E prev = contents[uniques - 1] ; if ( comparator.compare ( cur , prev ) != 0 ) { contents[uniques++] = cur ; } } Arrays.fill ( contents , uniques , n , null ) ; return new RegularImmutableSortedSet < E > ( ImmutableList. < E > asImmutableList ( contents , uniques ) , comparator ) ; } 
private void sortAndDedup ( ) { if ( n == 0 ) { return ; } Arrays.sort ( elements , 0 , n , comparator ) ; int unique = 1 ; for ( int i = 1 ; i < n ; i++ ) { int cmp = comparator.compare ( elements[unique - 1] , elements[i] ) ; if ( cmp < 0 ) { elements[unique++] = elements[i] ; } else if ( cmp > 0 ) { throw new AssertionError ( " Comparator " + comparator + " compare method violates its contract " ) ; } } Arrays.fill ( elements , unique , n , null ) ; n = unique ; } 
public Spliterator < E > spliterator ( ) { return new Spliterators.AbstractSpliterator < E > ( size ( ) , SPLITERATOR_CHARACTERISTICS | Spliterator.SIZED ) { final UnmodifiableIterator < E > iterator = iterator ( ) ; @Override public boolean tryAdvance ( Consumer < ? super E > action ) { if ( iterator.hasNext ( ) ) { action.accept ( iterator.next ( ) ) ; return true ; } else { return false ; } } @Override public Comparator < ? super E > getComparator ( ) { return comparator ; } } ; } 
public static < E > ImmutableSortedSet < E > of ( E e1 , E e2 , E e3 , E e4 ) { throw new UnsupportedOperationException ( ) ; } 
public static < E > ImmutableSortedSet < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 ) { throw new UnsupportedOperationException ( ) ; } 
public static < E > ImmutableSortedSet < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E... remaining ) { throw new UnsupportedOperationException ( ) ; } 
public static < T , R , C , V > Collector < T , ? , ImmutableTable < R , C , V > > toImmutableTable ( Function < ? super T , ? extends R > rowFunction , Function < ? super T , ? extends C > columnFunction , Function < ? super T , ? extends V > valueFunction ) { checkNotNull ( rowFunction , " rowFunction " ) ; checkNotNull ( columnFunction , " columnFunction " ) ; checkNotNull ( valueFunction , " valueFunction " ) ; return Collector.of ( ( ) - > new ImmutableTable.Builder < R , C , V > ( ) , ( builder , t ) - > builder.put ( rowFunction.apply ( t ) , columnFunction.apply ( t ) , valueFunction.apply ( t ) ) , ( b1 , b2 ) - > b1.combine ( b2 ) , b - > b.build ( ) ) ; } 
public static < T , R , C , V > Collector < T , ? , ImmutableTable < R , C , V > > toImmutableTable ( Function < ? super T , ? extends R > rowFunction , Function < ? super T , ? extends C > columnFunction , Function < ? super T , ? extends V > valueFunction , BinaryOperator < V > mergeFunction ) { checkNotNull ( rowFunction , " rowFunction " ) ; checkNotNull ( columnFunction , " columnFunction " ) ; checkNotNull ( valueFunction , " valueFunction " ) ; checkNotNull ( mergeFunction , " mergeFunction " ) ; return Collector.of ( ( ) - > new CollectorState < R , C , V > ( ) , ( state , input ) - > state.put ( rowFunction.apply ( input ) , columnFunction.apply ( input ) , valueFunction.apply ( input ) , mergeFunction ) , ( s1 , s2 ) - > s1.combine ( s2 , mergeFunction ) , state - > state.toTable ( ) ) ; } 
private static < R , C , V > ImmutableTable < R , C , V > copyOf ( Iterable < ? extends Cell < ? extends R , ? extends C , ? extends V > > cells ) { ImmutableTable.Builder < R , C , V > builder = ImmutableTable.builder ( ) ; for ( Cell < ? extends R , ? extends C , ? extends V > cell : cells ) { builder.put ( cell ) ; } return builder.build ( ) ; } 
public ImmutableTable < R , C , V > build ( ) { int size = cells.size ( ) ; switch ( size ) { case 0: return of ( ) ; case 1: return new SingletonImmutableTable < > ( Iterables.getOnlyElement ( cells ) ) ; default: return RegularImmutableTable.forCells ( cells , rowComparator , columnComparator ) ; } } 
ImmutableList < E > createAsList ( ) { return new ImmutableAsList < E > ( ) { @Override public E get ( int index ) { return IndexedImmutableSet.this.get ( index ) ; } @Override boolean isPartialView ( ) { return IndexedImmutableSet.this.isPartialView ( ) ; } @Override public int size ( ) { return IndexedImmutableSet.this.size ( ) ; } @Override ImmutableCollection < E > delegateCollection ( ) { return IndexedImmutableSet.this ; } } ; } 
public static < T > Iterable < List < T > > partition ( final Iterable < T > iterable , final int size ) { checkNotNull ( iterable ) ; checkArgument ( size > 0 ) ; return new FluentIterable < List < T > > ( ) { @Override public Iterator < List < T > > iterator ( ) { return Iterators.partition ( iterable.iterator ( ) , size ) ; } } ; } 
public static < T > Iterable < T > filter ( final Iterable < T > unfiltered , final Predicate < ? super T > retainIfTrue ) { checkNotNull ( unfiltered ) ; checkNotNull ( retainIfTrue ) ; return new FluentIterable < T > ( ) { @Override public Iterator < T > iterator ( ) { return Iterators.filter ( unfiltered.iterator ( ) , retainIfTrue ) ; } @Override public void forEach ( Consumer < ? super T > action ) { checkNotNull ( action ) ; unfiltered.forEach ( ( T a ) - > { if ( retainIfTrue.test ( a ) ) { action.accept ( a ) ; } } ) ; } @Override public Spliterator < T > spliterator ( ) { return CollectSpliterators.filter ( unfiltered.spliterator ( ) , retainIfTrue ) ; } } ; } 
public static < F , T > Iterable < T > transform ( final Iterable < F > fromIterable , final Function < ? super F , ? extends T > function ) { checkNotNull ( fromIterable ) ; checkNotNull ( function ) ; return new FluentIterable < T > ( ) { @Override public Iterator < T > iterator ( ) { return Iterators.transform ( fromIterable.iterator ( ) , function ) ; } @Override public void forEach ( Consumer < ? super T > action ) { checkNotNull ( action ) ; fromIterable.forEach ( ( F f ) - > action.accept ( function.apply ( f ) ) ) ; } @Override public Spliterator < T > spliterator ( ) { return CollectSpliterators.map ( fromIterable.spliterator ( ) , function ) ; } } ; } 
public static < T > Iterable < T > skip ( final Iterable < T > iterable , final int numberToSkip ) { checkNotNull ( iterable ) ; checkArgument ( numberToSkip > = 0 , " number to skip cannot be negative " ) ; return new FluentIterable < T > ( ) { @Override public Iterator < T > iterator ( ) { if ( iterable instanceof List ) { final List < T > list = ( List < T > ) iterable ; int toSkip = Math.min ( list.size ( ) , numberToSkip ) ; return list.subList ( toSkip , list.size ( ) ) .iterator ( ) ; } final Iterator < T > iterator = iterable.iterator ( ) ; Iterators.advance ( iterator , numberToSkip ) ; return new Iterator < T > ( ) { boolean atStart = true ; @Override public boolean hasNext ( ) { return iterator.hasNext ( ) ; } @Override public T next ( ) { T result = iterator.next ( ) ; atStart = false ; return result ; } @Override public void remove ( ) { checkRemove ( !atStart ) ; iterator.remove ( ) ; } } ; } @Override public Spliterator < T > spliterator ( ) { if ( iterable instanceof List ) { final List < T > list = ( List < T > ) iterable ; int toSkip = Math.min ( list.size ( ) , numberToSkip ) ; return list.subList ( toSkip , list.size ( ) ) .spliterator ( ) ; } else { return Streams.stream ( iterable ) .skip ( numberToSkip ) .spliterator ( ) ; } } } ; } 
public Iterator < T > iterator ( ) { if ( iterable instanceof List ) { final List < T > list = ( List < T > ) iterable ; int toSkip = Math.min ( list.size ( ) , numberToSkip ) ; return list.subList ( toSkip , list.size ( ) ) .iterator ( ) ; } final Iterator < T > iterator = iterable.iterator ( ) ; Iterators.advance ( iterator , numberToSkip ) ; return new Iterator < T > ( ) { boolean atStart = true ; @Override public boolean hasNext ( ) { return iterator.hasNext ( ) ; } @Override public T next ( ) { T result = iterator.next ( ) ; atStart = false ; return result ; } @Override public void remove ( ) { checkRemove ( !atStart ) ; iterator.remove ( ) ; } } ; } 
public static < T > Iterable < T > limit ( final Iterable < T > iterable , final int limitSize ) { checkNotNull ( iterable ) ; checkArgument ( limitSize > = 0 , " limit is negative " ) ; return new FluentIterable < T > ( ) { @Override public Iterator < T > iterator ( ) { return Iterators.limit ( iterable.iterator ( ) , limitSize ) ; } @Override public Spliterator < T > spliterator ( ) { return Streams.stream ( iterable ) .limit ( limitSize ) .spliterator ( ) ; } } ; } 
public static < T > Iterable < T > consumingIterable ( final Iterable < T > iterable ) { checkNotNull ( iterable ) ; return new FluentIterable < T > ( ) { @Override public Iterator < T > iterator ( ) { return ( iterable instanceof Queue ) ? new ConsumingQueueIterator < > ( ( Queue < T > ) iterable ) : Iterators.consumingIterator ( iterable.iterator ( ) ) ; } @Override public String toString ( ) { return " Iterables.consumingIterable ( ... ) " ; } } ; } 
public static < T > Iterable < T > mergeSorted ( final Iterable < ? extends Iterable < ? extends T > > iterables , final Comparator < ? super T > comparator ) { checkNotNull ( iterables , " iterables " ) ; checkNotNull ( comparator , " comparator " ) ; Iterable < T > iterable = new FluentIterable < T > ( ) { @Override public Iterator < T > iterator ( ) { return Iterators.mergeSorted ( Iterables.transform ( iterables , Iterables. < T > toIterator ( ) ) , comparator ) ; } } ; return new UnmodifiableIterable < > ( iterable ) ; } 
public static < T > UnmodifiableIterator < T > unmodifiableIterator ( final Iterator < ? extends T > iterator ) { checkNotNull ( iterator ) ; if ( iterator instanceof UnmodifiableIterator ) { @SuppressWarnings ( " unchecked " ) UnmodifiableIterator < T > result = ( UnmodifiableIterator < T > ) iterator ; return result ; } return new UnmodifiableIterator < T > ( ) { @Override public boolean hasNext ( ) { return iterator.hasNext ( ) ; } @Override public T next ( ) { return iterator.next ( ) ; } } ; } 
public static < T > Iterator < T > cycle ( final Iterable < T > iterable ) { checkNotNull ( iterable ) ; return new Iterator < T > ( ) { Iterator < T > iterator = emptyModifiableIterator ( ) ; @Override public boolean hasNext ( ) { return iterator.hasNext ( ) || iterable.iterator ( ) .hasNext ( ) ; } @Override public T next ( ) { if ( !iterator.hasNext ( ) ) { iterator = iterable.iterator ( ) ; if ( !iterator.hasNext ( ) ) { throw new NoSuchElementException ( ) ; } } return iterator.next ( ) ; } @Override public void remove ( ) { iterator.remove ( ) ; } } ; } 
private static < T > Iterator < T > consumingForArray ( final T... elements ) { return new UnmodifiableIterator < T > ( ) { int index = 0 ; @Override public boolean hasNext ( ) { return index < elements.length ; } @Override public T next ( ) { if ( !hasNext ( ) ) { throw new NoSuchElementException ( ) ; } T result = elements[index] ; elements[index] = null ; index++ ; return result ; } } ; } 
public static < T > Iterator < T > concat ( Iterator < ? extends T > a , Iterator < ? extends T > b , Iterator < ? extends T > c , Iterator < ? extends T > d ) { checkNotNull ( a ) ; checkNotNull ( b ) ; checkNotNull ( c ) ; checkNotNull ( d ) ; return concat ( consumingForArray ( a , b , c , d ) ) ; } 
private static < T > UnmodifiableIterator < List < T > > partitionImpl ( final Iterator < T > iterator , final int size , final boolean pad ) { checkNotNull ( iterator ) ; checkArgument ( size > 0 ) ; return new UnmodifiableIterator < List < T > > ( ) { @Override public boolean hasNext ( ) { return iterator.hasNext ( ) ; } @Override public List < T > next ( ) { if ( !hasNext ( ) ) { throw new NoSuchElementException ( ) ; } Object[] array = new Object[size] ; int count = 0 ; for ( ; count < size && iterator.hasNext ( ) ; count++ ) { array[count] = iterator.next ( ) ; } for ( int i = count ; i < size ; i++ ) { array[i] = null ; } @SuppressWarnings ( " unchecked " ) List < T > list = Collections.unmodifiableList ( ( List < T > ) Arrays.asList ( array ) ) ; return ( pad || count == size ) ? list : list.subList ( 0 , count ) ; } } ; } 
public List < T > next ( ) { if ( !hasNext ( ) ) { throw new NoSuchElementException ( ) ; } Object[] array = new Object[size] ; int count = 0 ; for ( ; count < size && iterator.hasNext ( ) ; count++ ) { array[count] = iterator.next ( ) ; } for ( int i = count ; i < size ; i++ ) { array[i] = null ; } @SuppressWarnings ( " unchecked " ) List < T > list = Collections.unmodifiableList ( ( List < T > ) Arrays.asList ( array ) ) ; return ( pad || count == size ) ? list : list.subList ( 0 , count ) ; } 
public static < T > UnmodifiableIterator < T > filter ( final Iterator < T > unfiltered , final Predicate < ? super T > retainIfTrue ) { checkNotNull ( unfiltered ) ; checkNotNull ( retainIfTrue ) ; return new AbstractIterator < T > ( ) { @Override protected T computeNext ( ) { while ( unfiltered.hasNext ( ) ) { T element = unfiltered.next ( ) ; if ( retainIfTrue.apply ( element ) ) { return element ; } } return endOfData ( ) ; } } ; } 
public static < F , T > Iterator < T > transform ( final Iterator < F > fromIterator , final Function < ? super F , ? extends T > function ) { checkNotNull ( function ) ; return new TransformedIterator < F , T > ( fromIterator ) { @Override T transform ( F from ) { return function.apply ( from ) ; } } ; } 
public static < T > Iterator < T > limit ( final Iterator < T > iterator , final int limitSize ) { checkNotNull ( iterator ) ; checkArgument ( limitSize > = 0 , " limit is negative " ) ; return new Iterator < T > ( ) { private int count ; @Override public boolean hasNext ( ) { return count < limitSize && iterator.hasNext ( ) ; } @Override public T next ( ) { if ( !hasNext ( ) ) { throw new NoSuchElementException ( ) ; } count++ ; return iterator.next ( ) ; } @Override public void remove ( ) { iterator.remove ( ) ; } } ; } 
public static < T > Iterator < T > consumingIterator ( final Iterator < T > iterator ) { checkNotNull ( iterator ) ; return new UnmodifiableIterator < T > ( ) { @Override public boolean hasNext ( ) { return iterator.hasNext ( ) ; } @Override public T next ( ) { T next = iterator.next ( ) ; iterator.remove ( ) ; return next ; } @Override public String toString ( ) { return " Iterators.consumingIterator ( ... ) " ; } } ; } 
public static < T > UnmodifiableIterator < T > singletonIterator ( @Nullable final T value ) { return new UnmodifiableIterator < T > ( ) { boolean done ; @Override public boolean hasNext ( ) { return !done ; } @Override public T next ( ) { if ( done ) { throw new NoSuchElementException ( ) ; } done = true ; return value ; } } ; } 
public static < T > UnmodifiableIterator < T > forEnumeration ( final Enumeration < T > enumeration ) { checkNotNull ( enumeration ) ; return new UnmodifiableIterator < T > ( ) { @Override public boolean hasNext ( ) { return enumeration.hasMoreElements ( ) ; } @Override public T next ( ) { return enumeration.nextElement ( ) ; } } ; } 
public static < T > Enumeration < T > asEnumeration ( final Iterator < T > iterator ) { checkNotNull ( iterator ) ; return new Enumeration < T > ( ) { @Override public boolean hasMoreElements ( ) { return iterator.hasNext ( ) ; } @Override public T nextElement ( ) { return iterator.next ( ) ; } } ; } 
public static < T > UnmodifiableIterator < T > mergeSorted ( Iterable < ? extends Iterator < ? extends T > > iterators , Comparator < ? super T > comparator ) { checkNotNull ( iterators , " iterators " ) ; checkNotNull ( comparator , " comparator " ) ; return new MergingIterator < T > ( iterators , comparator ) ; } 
public boolean hasNext ( ) { while ( !checkNotNull ( iterator ) .hasNext ( ) ) { topMetaIterator = getTopMetaIterator ( ) ; if ( topMetaIterator == null ) { return false ; } iterator = topMetaIterator.next ( ) ; if ( iterator instanceof ConcatenatedIterator ) { @SuppressWarnings ( " unchecked " ) ConcatenatedIterator < T > topConcat = ( ConcatenatedIterator < T > ) iterator ; iterator = topConcat.iterator ; if ( this.metaIterators == null ) { this.metaIterators = new ArrayDeque < > ( ) ; } this.metaIterators.addFirst ( this.topMetaIterator ) ; if ( topConcat.metaIterators != null ) { while ( !topConcat.metaIterators.isEmpty ( ) ) { this.metaIterators.addFirst ( topConcat.metaIterators.removeLast ( ) ) ; } } this.topMetaIterator = topConcat.topMetaIterator ; } } return true ; } 
static < K , V > ImmutableBiMap < K , V > create ( int n , Entry < K , V > [] entryArray ) { Map < K , V > forwardDelegate = Maps.newHashMapWithExpectedSize ( n ) ; Map < V , K > backwardDelegate = Maps.newHashMapWithExpectedSize ( n ) ; for ( int i = 0 ; i < n ; i++ ) { Entry < K , V > e = RegularImmutableMap.makeImmutable ( entryArray[i] ) ; entryArray[i] = e ; V oldValue = forwardDelegate.putIfAbsent ( e.getKey ( ) , e.getValue ( ) ) ; if ( oldValue != null ) { throw conflictException ( " key " , e.getKey ( ) + " = " + oldValue , entryArray[i] ) ; } K oldKey = backwardDelegate.putIfAbsent ( e.getValue ( ) , e.getKey ( ) ) ; if ( oldKey != null ) { throw conflictException ( " value " , oldKey + " = " + e.getValue ( ) , entryArray[i] ) ; } } ImmutableList < Entry < K , V > > entryList = ImmutableList.asImmutableList ( entryArray , n ) ; return new JdkBackedImmutableBiMap < > ( entryList , forwardDelegate , backwardDelegate ) ; } 
static < E > ImmutableMultiset < E > create ( Collection < ? extends Entry < ? extends E > > entries ) { @SuppressWarnings ( " unchecked " ) Entry < E > [] entriesArray = entries.toArray ( new Entry[0] ) ; Map < E , Integer > delegateMap = Maps.newHashMapWithExpectedSize ( entriesArray.length ) ; long size = 0 ; for ( int i = 0 ; i < entriesArray.length ; i++ ) { Entry < E > entry = entriesArray[i] ; int count = entry.getCount ( ) ; size += count ; E element = checkNotNull ( entry.getElement ( ) ) ; delegateMap.put ( element , count ) ; if ( ! ( entry instanceof Multisets.ImmutableEntry ) ) { entriesArray[i] = Multisets.immutableEntry ( element , count ) ; } } return new JdkBackedImmutableMultiset < > ( delegateMap , ImmutableList.asImmutableList ( entriesArray ) , size ) ; } 
public int compare ( Iterable < T > leftIterable , Iterable < T > rightIterable ) { Iterator < T > left = leftIterable.iterator ( ) ; Iterator < T > right = rightIterable.iterator ( ) ; while ( left.hasNext ( ) ) { if ( !right.hasNext ( ) ) { return LEFT_IS_GREATER ; } int result = elementOrder.compare ( left.next ( ) , right.next ( ) ) ; if ( result != 0 ) { return result ; } } if ( right.hasNext ( ) ) { return RIGHT_IS_GREATER ; } return 0 ; } 
public static < K , V > LinkedHashMultimap < K , V > create ( Multimap < ? extends K , ? extends V > multimap ) { LinkedHashMultimap < K , V > result = create ( multimap.keySet ( ) .size ( ) , DEFAULT_VALUE_SET_CAPACITY ) ; result.putAll ( multimap ) ; return result ; } 
public boolean add ( @Nullable V value ) { int smearedHash = Hashing.smearedHash ( value ) ; int bucket = smearedHash & mask ( ) ; ValueEntry < K , V > rowHead = hashTable[bucket] ; for ( ValueEntry < K , V > entry = rowHead ; entry != null ; entry = entry.nextInValueBucket ) { if ( entry.matchesValue ( value , smearedHash ) ) { return false ; } } ValueEntry < K , V > newEntry = new ValueEntry < > ( key , value , smearedHash , rowHead ) ; succeedsInValueSet ( lastEntry , newEntry ) ; succeedsInValueSet ( newEntry , this ) ; succeedsInMultimap ( multimapHeaderEntry.getPredecessorInMultimap ( ) , newEntry ) ; succeedsInMultimap ( newEntry , multimapHeaderEntry ) ; hashTable[bucket] = newEntry ; size++ ; modCount++ ; rehashIfNecessary ( ) ; return true ; } 
public boolean remove ( @Nullable Object o ) { int smearedHash = Hashing.smearedHash ( o ) ; int bucket = smearedHash & mask ( ) ; ValueEntry < K , V > prev = null ; for ( ValueEntry < K , V > entry = hashTable[bucket] ; entry != null ; prev = entry , entry = entry.nextInValueBucket ) { if ( entry.matchesValue ( o , smearedHash ) ) { if ( prev == null ) { hashTable[bucket] = entry.nextInValueBucket ; } else { prev.nextInValueBucket = entry.nextInValueBucket ; } deleteFromValueSet ( entry ) ; deleteFromMultimap ( entry ) ; size-- ; modCount++ ; return true ; } } return false ; } 
Iterator < Entry < K , V > > entryIterator ( ) { return new Iterator < Entry < K , V > > ( ) { ValueEntry < K , V > nextEntry = multimapHeaderEntry.successorInMultimap ; @Nullable ValueEntry < K , V > toRemove ; @Override public boolean hasNext ( ) { return nextEntry != multimapHeaderEntry ; } @Override public Entry < K , V > next ( ) { if ( !hasNext ( ) ) { throw new NoSuchElementException ( ) ; } ValueEntry < K , V > result = nextEntry ; toRemove = result ; nextEntry = nextEntry.successorInMultimap ; return result ; } @Override public void remove ( ) { checkRemove ( toRemove != null ) ; LinkedHashMultimap.this.remove ( toRemove.getKey ( ) , toRemove.getValue ( ) ) ; toRemove = null ; } } ; } 
private void readObject ( ObjectInputStream stream ) throws IOException , ClassNotFoundException { stream.defaultReadObject ( ) ; multimapHeaderEntry = new ValueEntry < > ( null , null , 0 , null ) ; succeedsInMultimap ( multimapHeaderEntry , multimapHeaderEntry ) ; valueSetCapacity = DEFAULT_VALUE_SET_CAPACITY ; int distinctKeys = stream.readInt ( ) ; Map < K , Collection < V > > map = Platform.newLinkedHashMapWithExpectedSize ( 12 ) ; for ( int i = 0 ; i < distinctKeys ; i++ ) { @SuppressWarnings ( " unchecked " ) K key = ( K ) stream.readObject ( ) ; map.put ( key , createCollection ( key ) ) ; } int entries = stream.readInt ( ) ; for ( int i = 0 ; i < entries ; i++ ) { @SuppressWarnings ( " unchecked " ) K key = ( K ) stream.readObject ( ) ; @SuppressWarnings ( " unchecked " ) V value = ( V ) stream.readObject ( ) ; map.get ( key ) .add ( value ) ; } setMap ( map ) ; } 
private Node < K , V > addNode ( @Nullable K key , @Nullable V value , @Nullable Node < K , V > nextSibling ) { Node < K , V > node = new Node < > ( key , value ) ; if ( head == null ) { head = tail = node ; keyToKeyList.put ( key , new KeyList < K , V > ( node ) ) ; modCount++ ; } else if ( nextSibling == null ) { tail.next = node ; node.previous = tail ; tail = node ; KeyList < K , V > keyList = keyToKeyList.get ( key ) ; if ( keyList == null ) { keyToKeyList.put ( key , keyList = new KeyList < > ( node ) ) ; modCount++ ; } else { keyList.count++ ; Node < K , V > keyTail = keyList.tail ; keyTail.nextSibling = node ; node.previousSibling = keyTail ; keyList.tail = node ; } } else { KeyList < K , V > keyList = keyToKeyList.get ( key ) ; keyList.count++ ; node.previous = nextSibling.previous ; node.previousSibling = nextSibling.previousSibling ; node.next = nextSibling ; node.nextSibling = nextSibling ; if ( nextSibling.previousSibling == null ) { keyToKeyList.get ( key ) .head = node ; } else { nextSibling.previousSibling.nextSibling = node ; } if ( nextSibling.previous == null ) { head = node ; } else { nextSibling.previous.next = node ; } nextSibling.previous = node ; nextSibling.previousSibling = node ; } size++ ; return node ; } 
private void removeNode ( Node < K , V > node ) { if ( node.previous != null ) { node.previous.next = node.next ; } else { head = node.next ; } if ( node.next != null ) { node.next.previous = node.previous ; } else { tail = node.previous ; } if ( node.previousSibling == null && node.nextSibling == null ) { KeyList < K , V > keyList = keyToKeyList.remove ( node.key ) ; keyList.count = 0 ; modCount++ ; } else { KeyList < K , V > keyList = keyToKeyList.get ( node.key ) ; keyList.count-- ; if ( node.previousSibling == null ) { keyList.head = node.nextSibling ; } else { node.previousSibling.nextSibling = node.nextSibling ; } if ( node.nextSibling == null ) { keyList.tail = node.previousSibling ; } else { node.nextSibling.previousSibling = node.previousSibling ; } } size-- ; } 
Set < K > createKeySet ( ) { @WeakOuter class KeySetImpl extends Sets.ImprovedAbstractSet < K > { @Override public int size ( ) { return keyToKeyList.size ( ) ; } @Override public Iterator < K > iterator ( ) { return new DistinctKeyIterator ( ) ; } @Override public boolean contains ( Object key ) { return containsKey ( key ) ; } @Override public boolean remove ( Object o ) { return !LinkedListMultimap.this.removeAll ( o ) .isEmpty ( ) ; } } return new KeySetImpl ( ) ; } 
List < V > createValues ( ) { @WeakOuter class ValuesImpl extends AbstractSequentialList < V > { @Override public int size ( ) { return size ; } @Override public ListIterator < V > listIterator ( int index ) { final NodeIterator nodeItr = new NodeIterator ( index ) ; return new TransformedListIterator < Entry < K , V > , V > ( nodeItr ) { @Override V transform ( Entry < K , V > entry ) { return entry.getValue ( ) ; } @Override public void set ( V value ) { nodeItr.setValue ( value ) ; } } ; } } return new ValuesImpl ( ) ; } 
public ListIterator < V > listIterator ( int index ) { final NodeIterator nodeItr = new NodeIterator ( index ) ; return new TransformedListIterator < Entry < K , V > , V > ( nodeItr ) { @Override V transform ( Entry < K , V > entry ) { return entry.getValue ( ) ; } @Override public void set ( V value ) { nodeItr.setValue ( value ) ; } } ; } 
public ListIterator < T > listIterator ( int index ) { return new TransformedListIterator < F , T > ( fromList.listIterator ( index ) ) { @Override T transform ( F from ) { return function.apply ( from ) ; } } ; } 
public static < T > List < T > reverse ( List < T > list ) { if ( list instanceof ImmutableList ) { return ( ( ImmutableList < T > ) list ) .reverse ( ) ; } else if ( list instanceof ReverseList ) { return ( ( ReverseList < T > ) list ) .getForwardList ( ) ; } else if ( list instanceof RandomAccess ) { return new RandomAccessReverseList < > ( list ) ; } else { return new ReverseList < > ( list ) ; } } 
public ListIterator < T > listIterator ( int index ) { int start = reversePosition ( index ) ; final ListIterator < T > forwardIterator = forwardList.listIterator ( start ) ; return new ListIterator < T > ( ) { boolean canRemoveOrSet ; @Override public void add ( T e ) { forwardIterator.add ( e ) ; forwardIterator.previous ( ) ; canRemoveOrSet = false ; } @Override public boolean hasNext ( ) { return forwardIterator.hasPrevious ( ) ; } @Override public boolean hasPrevious ( ) { return forwardIterator.hasNext ( ) ; } @Override public T next ( ) { if ( !hasNext ( ) ) { throw new NoSuchElementException ( ) ; } canRemoveOrSet = true ; return forwardIterator.previous ( ) ; } @Override public int nextIndex ( ) { return reversePosition ( forwardIterator.nextIndex ( ) ) ; } @Override public T previous ( ) { if ( !hasPrevious ( ) ) { throw new NoSuchElementException ( ) ; } canRemoveOrSet = true ; return forwardIterator.next ( ) ; } @Override public int previousIndex ( ) { return nextIndex ( ) - 1 ; } @Override public void remove ( ) { checkRemove ( canRemoveOrSet ) ; forwardIterator.remove ( ) ; canRemoveOrSet = false ; } @Override public void set ( T e ) { checkState ( canRemoveOrSet ) ; forwardIterator.set ( e ) ; } } ; } 
static boolean equalsImpl ( List < ? > thisList , @Nullable Object other ) { if ( other == checkNotNull ( thisList ) ) { return true ; } if ( ! ( other instanceof List ) ) { return false ; } List < ? > otherList = ( List < ? > ) other ; int size = thisList.size ( ) ; if ( size != otherList.size ( ) ) { return false ; } if ( thisList instanceof RandomAccess && otherList instanceof RandomAccess ) { for ( int i = 0 ; i < size ; i++ ) { if ( !Objects.equal ( thisList.get ( i ) , otherList.get ( i ) ) ) { return false ; } } return true ; } else { return Iterators.elementsEqual ( thisList.iterator ( ) , otherList.iterator ( ) ) ; } } 
private static int indexOfRandomAccess ( List < ? > list , @Nullable Object element ) { int size = list.size ( ) ; if ( element == null ) { for ( int i = 0 ; i < size ; i++ ) { if ( list.get ( i ) == null ) { return i ; } } } else { for ( int i = 0 ; i < size ; i++ ) { if ( element.equals ( list.get ( i ) ) ) { return i ; } } } return -1 ; } 
private static int lastIndexOfRandomAccess ( List < ? > list , @Nullable Object element ) { if ( element == null ) { for ( int i = list.size ( ) - 1 ; i > = 0 ; i-- ) { if ( list.get ( i ) == null ) { return i ; } } } else { for ( int i = list.size ( ) - 1 ; i > = 0 ; i-- ) { if ( element.equals ( list.get ( i ) ) ) { return i ; } } } return -1 ; } 
static < E > List < E > subListImpl ( final List < E > list , int fromIndex , int toIndex ) { List < E > wrapper ; if ( list instanceof RandomAccess ) { wrapper = new RandomAccessListWrapper < E > ( list ) { @Override public ListIterator < E > listIterator ( int index ) { return backingList.listIterator ( index ) ; } private static final long serialVersionUID = 0 ; } ; } else { wrapper = new AbstractListWrapper < E > ( list ) { @Override public ListIterator < E > listIterator ( int index ) { return backingList.listIterator ( index ) ; } private static final long serialVersionUID = 0 ; } ; } return wrapper.subList ( fromIndex , toIndex ) ; } 
public String toString ( ) { MoreObjects.ToStringHelper s = MoreObjects.toStringHelper ( this ) ; if ( initialCapacity != UNSET_INT ) { s.add ( " initialCapacity " , initialCapacity ) ; } if ( concurrencyLevel != UNSET_INT ) { s.add ( " concurrencyLevel " , concurrencyLevel ) ; } if ( keyStrength != null ) { s.add ( " keyStrength " , Ascii.toLowerCase ( keyStrength.toString ( ) ) ) ; } if ( valueStrength != null ) { s.add ( " valueStrength " , Ascii.toLowerCase ( valueStrength.toString ( ) ) ) ; } if ( keyEquivalence != null ) { s.addValue ( " keyEquivalence " ) ; } return s.toString ( ) ; } 
static < K , V > MapMakerInternalMap < K , V , ? extends InternalEntry < K , V , ? > , ? > create ( MapMaker builder ) { if ( builder.getKeyStrength ( ) == Strength.STRONG && builder.getValueStrength ( ) == Strength.STRONG ) { return new MapMakerInternalMap < > ( builder , StrongKeyStrongValueEntry.Helper. < K , V > instance ( ) ) ; } if ( builder.getKeyStrength ( ) == Strength.STRONG && builder.getValueStrength ( ) == Strength.WEAK ) { return new MapMakerInternalMap < > ( builder , StrongKeyWeakValueEntry.Helper. < K , V > instance ( ) ) ; } if ( builder.getKeyStrength ( ) == Strength.WEAK && builder.getValueStrength ( ) == Strength.STRONG ) { return new MapMakerInternalMap < > ( builder , WeakKeyStrongValueEntry.Helper. < K , V > instance ( ) ) ; } if ( builder.getKeyStrength ( ) == Strength.WEAK && builder.getValueStrength ( ) == Strength.WEAK ) { return new MapMakerInternalMap < > ( builder , WeakKeyWeakValueEntry.Helper. < K , V > instance ( ) ) ; } throw new AssertionError ( ) ; } 
static < K > MapMakerInternalMap < K , Dummy , ? extends InternalEntry < K , Dummy , ? > , ? > createWithDummyValues ( MapMaker builder ) { if ( builder.getKeyStrength ( ) == Strength.STRONG && builder.getValueStrength ( ) == Strength.STRONG ) { return new MapMakerInternalMap < > ( builder , StrongKeyDummyValueEntry.Helper. < K > instance ( ) ) ; } if ( builder.getKeyStrength ( ) == Strength.WEAK && builder.getValueStrength ( ) == Strength.STRONG ) { return new MapMakerInternalMap < > ( builder , WeakKeyDummyValueEntry.Helper. < K > instance ( ) ) ; } if ( builder.getValueStrength ( ) == Strength.WEAK ) { throw new IllegalArgumentException ( " Map cannot have both weak and dummy values " ) ; } throw new AssertionError ( ) ; } 
public StrongKeyStrongValueSegment < K , V > newSegment ( MapMakerInternalMap < K , V , StrongKeyStrongValueEntry < K , V > , StrongKeyStrongValueSegment < K , V > > map , int initialCapacity , int maxSegmentSize ) { return new StrongKeyStrongValueSegment < > ( map , initialCapacity , maxSegmentSize ) ; } 
public StrongKeyStrongValueEntry < K , V > copy ( StrongKeyStrongValueSegment < K , V > segment , StrongKeyStrongValueEntry < K , V > entry , @Nullable StrongKeyStrongValueEntry < K , V > newNext ) { return entry.copy ( newNext ) ; } 
public void setValue ( StrongKeyStrongValueSegment < K , V > segment , StrongKeyStrongValueEntry < K , V > entry , V value ) { entry.setValue ( value ) ; } 
public StrongKeyStrongValueEntry < K , V > newEntry ( StrongKeyStrongValueSegment < K , V > segment , K key , int hash , @Nullable StrongKeyStrongValueEntry < K , V > next ) { return new StrongKeyStrongValueEntry < > ( key , hash , next ) ; } 
public StrongKeyWeakValueEntry < K , V > copy ( StrongKeyWeakValueSegment < K , V > segment , StrongKeyWeakValueEntry < K , V > entry , @Nullable StrongKeyWeakValueEntry < K , V > newNext ) { if ( Segment.isCollected ( entry ) ) { return null ; } return entry.copy ( segment.queueForValues , newNext ) ; } 
public StrongKeyWeakValueEntry < K , V > newEntry ( StrongKeyWeakValueSegment < K , V > segment , K key , int hash , @Nullable StrongKeyWeakValueEntry < K , V > next ) { return new StrongKeyWeakValueEntry < > ( key , hash , next ) ; } 
public StrongKeyDummyValueSegment < K > newSegment ( MapMakerInternalMap < K , Dummy , StrongKeyDummyValueEntry < K > , StrongKeyDummyValueSegment < K > > map , int initialCapacity , int maxSegmentSize ) { return new StrongKeyDummyValueSegment < K > ( map , initialCapacity , maxSegmentSize ) ; } 
public StrongKeyDummyValueEntry < K > copy ( StrongKeyDummyValueSegment < K > segment , StrongKeyDummyValueEntry < K > entry , @Nullable StrongKeyDummyValueEntry < K > newNext ) { return entry.copy ( newNext ) ; } 
public void setValue ( StrongKeyDummyValueSegment < K > segment , StrongKeyDummyValueEntry < K > entry , Dummy value ) { } 
public WeakKeyDummyValueSegment < K > newSegment ( MapMakerInternalMap < K , Dummy , WeakKeyDummyValueEntry < K > , WeakKeyDummyValueSegment < K > > map , int initialCapacity , int maxSegmentSize ) { return new WeakKeyDummyValueSegment < K > ( map , initialCapacity , maxSegmentSize ) ; } 
public WeakKeyDummyValueEntry < K > copy ( WeakKeyDummyValueSegment < K > segment , WeakKeyDummyValueEntry < K > entry , @Nullable WeakKeyDummyValueEntry < K > newNext ) { if ( entry.getKey ( ) == null ) { return null ; } return entry.copy ( segment.queueForKeys , newNext ) ; } 
public WeakKeyDummyValueEntry < K > newEntry ( WeakKeyDummyValueSegment < K > segment , K key , int hash , @Nullable WeakKeyDummyValueEntry < K > next ) { return new WeakKeyDummyValueEntry < K > ( segment.queueForKeys , key , hash , next ) ; } 
public WeakKeyStrongValueSegment < K , V > newSegment ( MapMakerInternalMap < K , V , WeakKeyStrongValueEntry < K , V > , WeakKeyStrongValueSegment < K , V > > map , int initialCapacity , int maxSegmentSize ) { return new WeakKeyStrongValueSegment < > ( map , initialCapacity , maxSegmentSize ) ; } 
public WeakKeyStrongValueEntry < K , V > copy ( WeakKeyStrongValueSegment < K , V > segment , WeakKeyStrongValueEntry < K , V > entry , @Nullable WeakKeyStrongValueEntry < K , V > newNext ) { if ( entry.getKey ( ) == null ) { return null ; } return entry.copy ( segment.queueForKeys , newNext ) ; } 
public WeakKeyStrongValueEntry < K , V > newEntry ( WeakKeyStrongValueSegment < K , V > segment , K key , int hash , @Nullable WeakKeyStrongValueEntry < K , V > next ) { return new WeakKeyStrongValueEntry < > ( segment.queueForKeys , key , hash , next ) ; } 
public WeakKeyWeakValueSegment < K , V > newSegment ( MapMakerInternalMap < K , V , WeakKeyWeakValueEntry < K , V > , WeakKeyWeakValueSegment < K , V > > map , int initialCapacity , int maxSegmentSize ) { return new WeakKeyWeakValueSegment < > ( map , initialCapacity , maxSegmentSize ) ; } 
public WeakKeyWeakValueEntry < K , V > copy ( WeakKeyWeakValueSegment < K , V > segment , WeakKeyWeakValueEntry < K , V > entry , @Nullable WeakKeyWeakValueEntry < K , V > newNext ) { if ( entry.getKey ( ) == null ) { return null ; } if ( Segment.isCollected ( entry ) ) { return null ; } return entry.copy ( segment.queueForKeys , segment.queueForValues , newNext ) ; } 
public void clear ( ) { } 
void drainKeyReferenceQueue ( ReferenceQueue < K > keyReferenceQueue ) { Reference < ? extends K > ref ; int i = 0 ; while ( ( ref = keyReferenceQueue.poll ( ) ) != null ) { @SuppressWarnings ( " unchecked " ) E entry = ( E ) ref ; map.reclaimKey ( entry ) ; if ( ++i == DRAIN_MAX ) { break ; } } } 
void drainValueReferenceQueue ( ReferenceQueue < V > valueReferenceQueue ) { Reference < ? extends V > ref ; int i = 0 ; while ( ( ref = valueReferenceQueue.poll ( ) ) != null ) { @SuppressWarnings ( " unchecked " ) WeakValueReference < K , V , E > valueReference = ( WeakValueReference < K , V , E > ) ref ; map.reclaimValue ( valueReference ) ; if ( ++i == DRAIN_MAX ) { break ; } } } 
E getEntry ( Object key , int hash ) { if ( count != 0 ) { for ( E e = getFirst ( hash ) ; e != null ; e = e.getNext ( ) ) { if ( e.getHash ( ) != hash ) { continue ; } K entryKey = e.getKey ( ) ; if ( entryKey == null ) { tryDrainReferenceQueues ( ) ; continue ; } if ( map.keyEquivalence.equivalent ( key , entryKey ) ) { return e ; } } } return null ; } 
boolean containsValue ( Object value ) { try { if ( count != 0 ) { AtomicReferenceArray < E > table = this.table ; int length = table.length ( ) ; for ( int i = 0 ; i < length ; ++i ) { for ( E e = table.get ( i ) ; e != null ; e = e.getNext ( ) ) { V entryValue = getLiveValue ( e ) ; if ( entryValue == null ) { continue ; } if ( map.valueEquivalence ( ) .equivalent ( value , entryValue ) ) { return true ; } } } } return false ; } finally { postReadCleanup ( ) ; } } 
V put ( K key , int hash , V value , boolean onlyIfAbsent ) { lock ( ) ; try { preWriteCleanup ( ) ; int newCount = this.count + 1 ; if ( newCount > this.threshold ) { expand ( ) ; newCount = this.count + 1 ; } AtomicReferenceArray < E > table = this.table ; int index = hash & ( table.length ( ) - 1 ) ; E first = table.get ( index ) ; for ( E e = first ; e != null ; e = e.getNext ( ) ) { K entryKey = e.getKey ( ) ; if ( e.getHash ( ) == hash && entryKey != null && map.keyEquivalence.equivalent ( key , entryKey ) ) { V entryValue = e.getValue ( ) ; if ( entryValue == null ) { ++modCount ; setValue ( e , value ) ; newCount = this.count ; this.count = newCount ; return null ; } else if ( onlyIfAbsent ) { return entryValue ; } else { ++modCount ; setValue ( e , value ) ; return entryValue ; } } } ++modCount ; E newEntry = map.entryHelper.newEntry ( self ( ) , key , hash , first ) ; setValue ( newEntry , value ) ; table.set ( index , newEntry ) ; this.count = newCount ; return null ; } finally { unlock ( ) ; } } 
void expand ( ) { AtomicReferenceArray < E > oldTable = table ; int oldCapacity = oldTable.length ( ) ; if ( oldCapacity > = MAXIMUM_CAPACITY ) { return ; } int newCount = count ; AtomicReferenceArray < E > newTable = newEntryArray ( oldCapacity < < 1 ) ; threshold = newTable.length ( ) * 3 / 4 ; int newMask = newTable.length ( ) - 1 ; for ( int oldIndex = 0 ; oldIndex < oldCapacity ; ++oldIndex ) { E head = oldTable.get ( oldIndex ) ; if ( head != null ) { E next = head.getNext ( ) ; int headIndex = head.getHash ( ) & newMask ; if ( next == null ) { newTable.set ( headIndex , head ) ; } else { E tail = head ; int tailIndex = headIndex ; for ( E e = next ; e != null ; e = e.getNext ( ) ) { int newIndex = e.getHash ( ) & newMask ; if ( newIndex != tailIndex ) { tailIndex = newIndex ; tail = e ; } } newTable.set ( tailIndex , tail ) ; for ( E e = head ; e != tail ; e = e.getNext ( ) ) { int newIndex = e.getHash ( ) & newMask ; E newNext = newTable.get ( newIndex ) ; E newFirst = copyEntry ( e , newNext ) ; if ( newFirst != null ) { newTable.set ( newIndex , newFirst ) ; } else { newCount-- ; } } } } } table = newTable ; this.count = newCount ; } 
boolean replace ( K key , int hash , V oldValue , V newValue ) { lock ( ) ; try { preWriteCleanup ( ) ; AtomicReferenceArray < E > table = this.table ; int index = hash & ( table.length ( ) - 1 ) ; E first = table.get ( index ) ; for ( E e = first ; e != null ; e = e.getNext ( ) ) { K entryKey = e.getKey ( ) ; if ( e.getHash ( ) == hash && entryKey != null && map.keyEquivalence.equivalent ( key , entryKey ) ) { V entryValue = e.getValue ( ) ; if ( entryValue == null ) { if ( isCollected ( e ) ) { int newCount = this.count - 1 ; ++modCount ; E newFirst = removeFromChain ( first , e ) ; newCount = this.count - 1 ; table.set ( index , newFirst ) ; this.count = newCount ; } return false ; } if ( map.valueEquivalence ( ) .equivalent ( oldValue , entryValue ) ) { ++modCount ; setValue ( e , newValue ) ; return true ; } else { return false ; } } } return false ; } finally { unlock ( ) ; } } 
V replace ( K key , int hash , V newValue ) { lock ( ) ; try { preWriteCleanup ( ) ; AtomicReferenceArray < E > table = this.table ; int index = hash & ( table.length ( ) - 1 ) ; E first = table.get ( index ) ; for ( E e = first ; e != null ; e = e.getNext ( ) ) { K entryKey = e.getKey ( ) ; if ( e.getHash ( ) == hash && entryKey != null && map.keyEquivalence.equivalent ( key , entryKey ) ) { V entryValue = e.getValue ( ) ; if ( entryValue == null ) { if ( isCollected ( e ) ) { int newCount = this.count - 1 ; ++modCount ; E newFirst = removeFromChain ( first , e ) ; newCount = this.count - 1 ; table.set ( index , newFirst ) ; this.count = newCount ; } return null ; } ++modCount ; setValue ( e , newValue ) ; return entryValue ; } } return null ; } finally { unlock ( ) ; } } 
V remove ( Object key , int hash ) { lock ( ) ; try { preWriteCleanup ( ) ; int newCount = this.count - 1 ; AtomicReferenceArray < E > table = this.table ; int index = hash & ( table.length ( ) - 1 ) ; E first = table.get ( index ) ; for ( E e = first ; e != null ; e = e.getNext ( ) ) { K entryKey = e.getKey ( ) ; if ( e.getHash ( ) == hash && entryKey != null && map.keyEquivalence.equivalent ( key , entryKey ) ) { V entryValue = e.getValue ( ) ; if ( entryValue != null ) { } else if ( isCollected ( e ) ) { } else { return null ; } ++modCount ; E newFirst = removeFromChain ( first , e ) ; newCount = this.count - 1 ; table.set ( index , newFirst ) ; this.count = newCount ; return entryValue ; } } return null ; } finally { unlock ( ) ; } } 
boolean remove ( Object key , int hash , Object value ) { lock ( ) ; try { preWriteCleanup ( ) ; int newCount = this.count - 1 ; AtomicReferenceArray < E > table = this.table ; int index = hash & ( table.length ( ) - 1 ) ; E first = table.get ( index ) ; for ( E e = first ; e != null ; e = e.getNext ( ) ) { K entryKey = e.getKey ( ) ; if ( e.getHash ( ) == hash && entryKey != null && map.keyEquivalence.equivalent ( key , entryKey ) ) { V entryValue = e.getValue ( ) ; boolean explicitRemoval = false ; if ( map.valueEquivalence ( ) .equivalent ( value , entryValue ) ) { explicitRemoval = true ; } else if ( isCollected ( e ) ) { } else { return false ; } ++modCount ; E newFirst = removeFromChain ( first , e ) ; newCount = this.count - 1 ; table.set ( index , newFirst ) ; this.count = newCount ; return explicitRemoval ; } } return false ; } finally { unlock ( ) ; } } 
void clear ( ) { if ( count != 0 ) { lock ( ) ; try { AtomicReferenceArray < E > table = this.table ; for ( int i = 0 ; i < table.length ( ) ; ++i ) { table.set ( i , null ) ; } maybeClearReferenceQueues ( ) ; readCount.set ( 0 ) ; ++modCount ; count = 0 ; } finally { unlock ( ) ; } } } 
boolean reclaimKey ( E entry , int hash ) { lock ( ) ; try { int newCount = count - 1 ; AtomicReferenceArray < E > table = this.table ; int index = hash & ( table.length ( ) - 1 ) ; E first = table.get ( index ) ; for ( E e = first ; e != null ; e = e.getNext ( ) ) { if ( e == entry ) { ++modCount ; E newFirst = removeFromChain ( first , e ) ; newCount = this.count - 1 ; table.set ( index , newFirst ) ; this.count = newCount ; return true ; } } return false ; } finally { unlock ( ) ; } } 
boolean reclaimValue ( K key , int hash , WeakValueReference < K , V , E > valueReference ) { lock ( ) ; try { int newCount = this.count - 1 ; AtomicReferenceArray < E > table = this.table ; int index = hash & ( table.length ( ) - 1 ) ; E first = table.get ( index ) ; for ( E e = first ; e != null ; e = e.getNext ( ) ) { K entryKey = e.getKey ( ) ; if ( e.getHash ( ) == hash && entryKey != null && map.keyEquivalence.equivalent ( key , entryKey ) ) { WeakValueReference < K , V , E > v = ( ( WeakValueEntry < K , V , E > ) e ) .getValueReference ( ) ; if ( v == valueReference ) { ++modCount ; E newFirst = removeFromChain ( first , e ) ; newCount = this.count - 1 ; table.set ( index , newFirst ) ; this.count = newCount ; return true ; } return false ; } } return false ; } finally { unlock ( ) ; } } 
boolean clearValueForTesting ( K key , int hash , WeakValueReference < K , V , ? extends InternalEntry < K , V , ? > > valueReference ) { lock ( ) ; try { AtomicReferenceArray < E > table = this.table ; int index = hash & ( table.length ( ) - 1 ) ; E first = table.get ( index ) ; for ( E e = first ; e != null ; e = e.getNext ( ) ) { K entryKey = e.getKey ( ) ; if ( e.getHash ( ) == hash && entryKey != null && map.keyEquivalence.equivalent ( key , entryKey ) ) { WeakValueReference < K , V , E > v = ( ( WeakValueEntry < K , V , E > ) e ) .getValueReference ( ) ; if ( v == valueReference ) { E newFirst = removeFromChain ( first , e ) ; table.set ( index , newFirst ) ; return true ; } return false ; } } return false ; } finally { unlock ( ) ; } } 
boolean removeEntryForTesting ( E entry ) { int hash = entry.getHash ( ) ; int newCount = this.count - 1 ; AtomicReferenceArray < E > table = this.table ; int index = hash & ( table.length ( ) - 1 ) ; E first = table.get ( index ) ; for ( E e = first ; e != null ; e = e.getNext ( ) ) { if ( e == entry ) { ++modCount ; E newFirst = removeFromChain ( first , e ) ; newCount = this.count - 1 ; table.set ( index , newFirst ) ; this.count = newCount ; return true ; } } return false ; } 
public void setWeakValueReferenceForTesting ( InternalEntry < K , V , ? > e , WeakValueReference < K , V , ? extends InternalEntry < K , V , ? > > valueReference ) { StrongKeyWeakValueEntry < K , V > entry = castForTesting ( e ) ; @SuppressWarnings ( " unchecked " ) WeakValueReference < K , V , StrongKeyWeakValueEntry < K , V > > newValueReference = ( WeakValueReference < K , V , StrongKeyWeakValueEntry < K , V > > ) valueReference ; WeakValueReference < K , V , StrongKeyWeakValueEntry < K , V > > previous = entry.valueReference ; entry.valueReference = newValueReference ; previous.clear ( ) ; } 
public boolean isEmpty ( ) { long sum = 0L ; Segment < K , V , E , S > [] segments = this.segments ; for ( int i = 0 ; i < segments.length ; ++i ) { if ( segments[i].count != 0 ) { return false ; } sum += segments[i].modCount ; } if ( sum != 0L ) { for ( int i = 0 ; i < segments.length ; ++i ) { if ( segments[i].count != 0 ) { return false ; } sum -= segments[i].modCount ; } if ( sum != 0L ) { return false ; } } return true ; } 
public boolean containsValue ( @Nullable Object value ) { if ( value == null ) { return false ; } final Segment < K , V , E , S > [] segments = this.segments ; long last = -1L ; for ( int i = 0 ; i < CONTAINS_VALUE_RETRIES ; i++ ) { long sum = 0L ; for ( Segment < K , V , E , S > segment : segments ) { int unused = segment.count ; AtomicReferenceArray < E > table = segment.table ; for ( int j = 0 ; j < table.length ( ) ; j++ ) { for ( E e = table.get ( j ) ; e != null ; e = e.getNext ( ) ) { V v = segment.getLiveValue ( e ) ; if ( v != null && valueEquivalence ( ) .equivalent ( value , v ) ) { return true ; } } } sum += segment.modCount ; } if ( sum == last ) { break ; } last = sum ; } return false ; } 
boolean advanceTo ( E entry ) { try { K key = entry.getKey ( ) ; V value = getLiveValue ( entry ) ; if ( value != null ) { nextExternal = new WriteThroughEntry ( key , value ) ; return true ; } else { return false ; } } finally { currentSegment.postReadCleanup ( ) ; } } 
static < K , V > Iterator < K > keyIterator ( Iterator < Entry < K , V > > entryIterator ) { return new TransformedIterator < Entry < K , V > , K > ( entryIterator ) { @Override K transform ( Entry < K , V > entry ) { return entry.getKey ( ) ; } } ; } 
static < K , V > Iterator < V > valueIterator ( Iterator < Entry < K , V > > entryIterator ) { return new TransformedIterator < Entry < K , V > , V > ( entryIterator ) { @Override V transform ( Entry < K , V > entry ) { return entry.getValue ( ) ; } } ; } 
public static < K extends Enum < K > , V > ImmutableMap < K , V > immutableEnumMap ( Map < K , ? extends V > map ) { if ( map instanceof ImmutableEnumMap ) { @SuppressWarnings ( " unchecked " ) ImmutableEnumMap < K , V > result = ( ImmutableEnumMap < K , V > ) map ; return result ; } Iterator < ? extends Entry < K , ? extends V > > entryItr = map.entrySet ( ) .iterator ( ) ; if ( !entryItr.hasNext ( ) ) { return ImmutableMap.of ( ) ; } Entry < K , ? extends V > entry1 = entryItr.next ( ) ; K key1 = entry1.getKey ( ) ; V value1 = entry1.getValue ( ) ; checkEntryNotNull ( key1 , value1 ) ; Class < K > clazz = key1.getDeclaringClass ( ) ; EnumMap < K , V > enumMap = new EnumMap < > ( clazz ) ; enumMap.put ( key1 , value1 ) ; while ( entryItr.hasNext ( ) ) { Entry < K , ? extends V > entry = entryItr.next ( ) ; K key = entry.getKey ( ) ; V value = entry.getValue ( ) ; checkEntryNotNull ( key , value ) ; enumMap.put ( key , value ) ; } return ImmutableEnumMap.asImmutable ( enumMap ) ; } 
public static < T , K extends Enum < K > , V > Collector < T , ? , ImmutableMap < K , V > > toImmutableEnumMap ( java.util.function.Function < ? super T , ? extends K > keyFunction , java.util.function.Function < ? super T , ? extends V > valueFunction ) { checkNotNull ( keyFunction ) ; checkNotNull ( valueFunction ) ; return Collector.of ( ( ) - > new Accumulator < K , V > ( ( v1 , v2 ) - > { throw new IllegalArgumentException ( " Multiple values for key: " + v1 + " , " + v2 ) ; } ) , ( accum , t ) - > { K key = checkNotNull ( keyFunction.apply ( t ) , " Null key for input %s " , t ) ; V newValue = checkNotNull ( valueFunction.apply ( t ) , " Null value for input %s " , t ) ; accum.put ( key , newValue ) ; } , Accumulator::combine , Accumulator::toImmutableMap , Collector.Characteristics.UNORDERED ) ; } 
public static < T , K extends Enum < K > , V > Collector < T , ? , ImmutableMap < K , V > > toImmutableEnumMap ( java.util.function.Function < ? super T , ? extends K > keyFunction , java.util.function.Function < ? super T , ? extends V > valueFunction , BinaryOperator < V > mergeFunction ) { checkNotNull ( keyFunction ) ; checkNotNull ( valueFunction ) ; checkNotNull ( mergeFunction ) ; return Collector.of ( ( ) - > new Accumulator < K , V > ( mergeFunction ) , ( accum , t ) - > { K key = checkNotNull ( keyFunction.apply ( t ) , " Null key for input %s " , t ) ; V newValue = checkNotNull ( valueFunction.apply ( t ) , " Null value for input %s " , t ) ; accum.put ( key , newValue ) ; } , Accumulator::combine , Accumulator::toImmutableMap ) ; } 
private static < K , V > void doDifference ( Map < ? extends K , ? extends V > left , Map < ? extends K , ? extends V > right , Equivalence < ? super V > valueEquivalence , Map < K , V > onlyOnLeft , Map < K , V > onlyOnRight , Map < K , V > onBoth , Map < K , MapDifference.ValueDifference < V > > differences ) { for ( Entry < ? extends K , ? extends V > entry : left.entrySet ( ) ) { K leftKey = entry.getKey ( ) ; V leftValue = entry.getValue ( ) ; if ( right.containsKey ( leftKey ) ) { V rightValue = onlyOnRight.remove ( leftKey ) ; if ( valueEquivalence.equivalent ( leftValue , rightValue ) ) { onBoth.put ( leftKey , leftValue ) ; } else { differences.put ( leftKey , ValueDifferenceImpl.create ( leftValue , rightValue ) ) ; } } else { onlyOnLeft.put ( leftKey , leftValue ) ; } } } 
static < K , V > Iterator < Entry < K , V > > asMapEntryIterator ( Set < K > set , final Function < ? super K , V > function ) { return new TransformedIterator < K , Entry < K , V > > ( set.iterator ( ) ) { @Override Entry < K , V > transform ( final K key ) { return immutableEntry ( key , function.apply ( key ) ) ; } } ; } 
public boolean add ( E element ) { throw new UnsupportedOperationException ( ) ; } 
public boolean addAll ( Collection < ? extends E > es ) { throw new UnsupportedOperationException ( ) ; } 
private static < E > SortedSet < E > removeOnlySortedSet ( final SortedSet < E > set ) { return new ForwardingSortedSet < E > ( ) { @Override protected SortedSet < E > delegate ( ) { return set ; } @Override public boolean add ( E element ) { throw new UnsupportedOperationException ( ) ; } @Override public boolean addAll ( Collection < ? extends E > es ) { throw new UnsupportedOperationException ( ) ; } @Override public SortedSet < E > headSet ( E toElement ) { return removeOnlySortedSet ( super.headSet ( toElement ) ) ; } @Override public SortedSet < E > subSet ( E fromElement , E toElement ) { return removeOnlySortedSet ( super.subSet ( fromElement , toElement ) ) ; } @Override public SortedSet < E > tailSet ( E fromElement ) { return removeOnlySortedSet ( super.tailSet ( fromElement ) ) ; } } ; } 
private static < E > NavigableSet < E > removeOnlyNavigableSet ( final NavigableSet < E > set ) { return new ForwardingNavigableSet < E > ( ) { @Override protected NavigableSet < E > delegate ( ) { return set ; } @Override public boolean add ( E element ) { throw new UnsupportedOperationException ( ) ; } @Override public boolean addAll ( Collection < ? extends E > es ) { throw new UnsupportedOperationException ( ) ; } @Override public SortedSet < E > headSet ( E toElement ) { return removeOnlySortedSet ( super.headSet ( toElement ) ) ; } @Override public NavigableSet < E > headSet ( E toElement , boolean inclusive ) { return removeOnlyNavigableSet ( super.headSet ( toElement , inclusive ) ) ; } @Override public SortedSet < E > subSet ( E fromElement , E toElement ) { return removeOnlySortedSet ( super.subSet ( fromElement , toElement ) ) ; } @Override public NavigableSet < E > subSet ( E fromElement , boolean fromInclusive , E toElement , boolean toInclusive ) { return removeOnlyNavigableSet ( super.subSet ( fromElement , fromInclusive , toElement , toInclusive ) ) ; } @Override public SortedSet < E > tailSet ( E fromElement ) { return removeOnlySortedSet ( super.tailSet ( fromElement ) ) ; } @Override public NavigableSet < E > tailSet ( E fromElement , boolean inclusive ) { return removeOnlyNavigableSet ( super.tailSet ( fromElement , inclusive ) ) ; } @Override public NavigableSet < E > descendingSet ( ) { return removeOnlyNavigableSet ( super.descendingSet ( ) ) ; } } ; } 
public static < K , V > ImmutableMap < K , V > toMap ( Iterator < K > keys , Function < ? super K , V > valueFunction ) { checkNotNull ( valueFunction ) ; Map < K , V > builder = newLinkedHashMap ( ) ; while ( keys.hasNext ( ) ) { K key = keys.next ( ) ; builder.put ( key , valueFunction.apply ( key ) ) ; } return ImmutableMap.copyOf ( builder ) ; } 
public static < K , V > ImmutableMap < K , V > uniqueIndex ( Iterator < V > values , Function < ? super V , K > keyFunction ) { checkNotNull ( keyFunction ) ; ImmutableMap.Builder < K , V > builder = ImmutableMap.builder ( ) ; while ( values.hasNext ( ) ) { V value = values.next ( ) ; builder.put ( keyFunction.apply ( value ) , value ) ; } try { return builder.build ( ) ; } catch ( IllegalArgumentException duplicateKeys ) { throw new IllegalArgumentException ( duplicateKeys.getMessage ( ) + " . To index multiple values under a key , use Multimaps.index. " ) ; } } 
static < K , V > Entry < K , V > unmodifiableEntry ( final Entry < ? extends K , ? extends V > entry ) { checkNotNull ( entry ) ; return new AbstractMapEntry < K , V > ( ) { @Override public K getKey ( ) { return entry.getKey ( ) ; } @Override public V getValue ( ) { return entry.getValue ( ) ; } } ; } 
static < K , V1 , V2 > EntryTransformer < K , V1 , V2 > asEntryTransformer ( final Function < ? super V1 , V2 > function ) { checkNotNull ( function ) ; return new EntryTransformer < K , V1 , V2 > ( ) { @Override public V2 transformEntry ( K key , V1 value ) { return function.apply ( value ) ; } } ; } 
static < K , V1 , V2 > Function < V1 , V2 > asValueToValueFunction ( final EntryTransformer < ? super K , V1 , V2 > transformer , final K key ) { checkNotNull ( transformer ) ; return new Function < V1 , V2 > ( ) { @Override public V2 apply ( @Nullable V1 v1 ) { return transformer.transformEntry ( key , v1 ) ; } } ; } 
static < K , V1 , V2 > Function < Entry < K , V1 > , V2 > asEntryToValueFunction ( final EntryTransformer < ? super K , ? super V1 , V2 > transformer ) { checkNotNull ( transformer ) ; return new Function < Entry < K , V1 > , V2 > ( ) { @Override public V2 apply ( Entry < K , V1 > entry ) { return transformer.transformEntry ( entry.getKey ( ) , entry.getValue ( ) ) ; } } ; } 
static < V2 , K , V1 > Entry < K , V2 > transformEntry ( final EntryTransformer < ? super K , ? super V1 , V2 > transformer , final Entry < K , V1 > entry ) { checkNotNull ( transformer ) ; checkNotNull ( entry ) ; return new AbstractMapEntry < K , V2 > ( ) { @Override public K getKey ( ) { return entry.getKey ( ) ; } @Override public V2 getValue ( ) { return transformer.transformEntry ( entry.getKey ( ) , entry.getValue ( ) ) ; } } ; } 
static < K , V1 , V2 > Function < Entry < K , V1 > , Entry < K , V2 > > asEntryToEntryFunction ( final EntryTransformer < ? super K , ? super V1 , V2 > transformer ) { checkNotNull ( transformer ) ; return new Function < Entry < K , V1 > , Entry < K , V2 > > ( ) { @Override public Entry < K , V2 > apply ( final Entry < K , V1 > entry ) { return transformEntry ( transformer , entry ) ; } } ; } 
public static < K , V > NavigableMap < K , V > filterEntries ( NavigableMap < K , V > unfiltered , Predicate < ? super Entry < K , V > > entryPredicate ) { checkNotNull ( entryPredicate ) ; return ( unfiltered instanceof FilteredEntryNavigableMap ) ? filterFiltered ( ( FilteredEntryNavigableMap < K , V > ) unfiltered , entryPredicate ) : new FilteredEntryNavigableMap < K , V > ( checkNotNull ( unfiltered ) , entryPredicate ) ; } 
public static < K , V > BiMap < K , V > filterEntries ( BiMap < K , V > unfiltered , Predicate < ? super Entry < K , V > > entryPredicate ) { checkNotNull ( unfiltered ) ; checkNotNull ( entryPredicate ) ; return ( unfiltered instanceof FilteredEntryBiMap ) ? filterFiltered ( ( FilteredEntryBiMap < K , V > ) unfiltered , entryPredicate ) : new FilteredEntryBiMap < K , V > ( unfiltered , entryPredicate ) ; } 
public Iterator < Entry < K , V > > iterator ( ) { return new TransformedIterator < Entry < K , V > , Entry < K , V > > ( filteredEntrySet.iterator ( ) ) { @Override Entry < K , V > transform ( final Entry < K , V > entry ) { return new ForwardingMapEntry < K , V > ( ) { @Override protected Entry < K , V > delegate ( ) { return entry ; } @Override public V setValue ( V newValue ) { checkArgument ( apply ( getKey ( ) , newValue ) ) ; return super.setValue ( newValue ) ; } } ; } } ; } 
Entry < K , V > transform ( final Entry < K , V > entry ) { return new ForwardingMapEntry < K , V > ( ) { @Override protected Entry < K , V > delegate ( ) { return entry ; } @Override public V setValue ( V newValue ) { checkArgument ( apply ( getKey ( ) , newValue ) ) ; return super.setValue ( newValue ) ; } } ; } 
public NavigableSet < K > navigableKeySet ( ) { return new Maps.NavigableKeySet < K , V > ( this ) { @Override public boolean removeAll ( Collection < ? > collection ) { return FilteredEntryMap.removeAllKeys ( unfiltered , entryPredicate , collection ) ; } @Override public boolean retainAll ( Collection < ? > collection ) { return FilteredEntryMap.retainAllKeys ( unfiltered , entryPredicate , collection ) ; } } ; } 
private static < K , V > Predicate < Entry < V , K > > inversePredicate ( final Predicate < ? super Entry < K , V > > forwardPredicate ) { return new Predicate < Entry < V , K > > ( ) { @Override public boolean apply ( Entry < V , K > input ) { return forwardPredicate.apply ( Maps.immutableEntry ( input.getValue ( ) , input.getKey ( ) ) ) ; } } ; } 
public Set < Entry < K , V > > entrySet ( ) { return new EntrySet < K , V > ( ) { @Override Map < K , V > map ( ) { return IteratorBasedAbstractMap.this ; } @Override public Iterator < Entry < K , V > > iterator ( ) { return entryIterator ( ) ; } @Override public Spliterator < Entry < K , V > > spliterator ( ) { return entrySpliterator ( ) ; } @Override public void forEach ( Consumer < ? super Entry < K , V > > action ) { forEachEntry ( action ) ; } } ; } 
Set < Entry < K , V > > createEntrySet ( ) { @WeakOuter class EntrySetImpl extends EntrySet < K , V > { @Override Map < K , V > map ( ) { return DescendingMap.this ; } @Override public Iterator < Entry < K , V > > iterator ( ) { return entryIterator ( ) ; } } return new EntrySetImpl ( ) ; } 
public static < K extends Comparable < ? super K > , V > NavigableMap < K , V > subMap ( NavigableMap < K , V > map , Range < K > range ) { if ( map.comparator ( ) != null && map.comparator ( ) != Ordering.natural ( ) && range.hasLowerBound ( ) && range.hasUpperBound ( ) ) { checkArgument ( map.comparator ( ) .compare ( range.lowerEndpoint ( ) , range.upperEndpoint ( ) ) < = 0 , " map is using a custom comparator which is inconsistent with the natural ordering. " ) ; } if ( range.hasLowerBound ( ) && range.hasUpperBound ( ) ) { return map.subMap ( range.lowerEndpoint ( ) , range.lowerBoundType ( ) == BoundType.CLOSED , range.upperEndpoint ( ) , range.upperBoundType ( ) == BoundType.CLOSED ) ; } else if ( range.hasLowerBound ( ) ) { return map.tailMap ( range.lowerEndpoint ( ) , range.lowerBoundType ( ) == BoundType.CLOSED ) ; } else if ( range.hasUpperBound ( ) ) { return map.headMap ( range.upperEndpoint ( ) , range.upperBoundType ( ) == BoundType.CLOSED ) ; } return checkNotNull ( map ) ; } 
private int getMaxElementIndex ( ) { switch ( size ) { case 1: return 0 ; case 2: return 1 ; default: return ( maxHeap.compareElements ( 1 , 2 ) < = 0 ) ? 1 : 2 ; } } 
public E peekLast ( ) { return isEmpty ( ) ? null : elementData ( getMaxElementIndex ( ) ) ; } 
MoveDesc < E > removeAt ( int index ) { checkPositionIndex ( index , size ) ; modCount++ ; size-- ; if ( size == index ) { queue[size] = null ; return null ; } E actualLastElement = elementData ( size ) ; int lastElementAt = heapForIndex ( size ) .swapWithConceptuallyLastElement ( actualLastElement ) ; if ( lastElementAt == index ) { queue[size] = null ; return null ; } E toTrickle = elementData ( size ) ; queue[size] = null ; MoveDesc < E > changes = fillHole ( index , toTrickle ) ; if ( lastElementAt < index ) { if ( changes == null ) { return new MoveDesc < E > ( actualLastElement , toTrickle ) ; } else { return new MoveDesc < E > ( actualLastElement , changes.replaced ) ; } } return changes ; } 
private MoveDesc < E > fillHole ( int index , E toTrickle ) { Heap heap = heapForIndex ( index ) ; int vacated = heap.fillHoleAt ( index ) ; int bubbledTo = heap.bubbleUpAlternatingLevels ( vacated , toTrickle ) ; if ( bubbledTo == vacated ) { return heap.tryCrossOverAndBubbleUp ( index , vacated , toTrickle ) ; } else { return ( bubbledTo < index ) ? new MoveDesc < E > ( toTrickle , elementData ( index ) ) : null ; } } 
MoveDesc < E > tryCrossOverAndBubbleUp ( int removeIndex , int vacated , E toTrickle ) { int crossOver = crossOver ( vacated , toTrickle ) ; if ( crossOver == vacated ) { return null ; } E parent ; if ( crossOver < removeIndex ) { parent = elementData ( removeIndex ) ; } else { parent = elementData ( getParentIndex ( removeIndex ) ) ; } if ( otherHeap.bubbleUpAlternatingLevels ( crossOver , toTrickle ) < removeIndex ) { return new MoveDesc < E > ( toTrickle , parent ) ; } else { return null ; } } 
int crossOverUp ( int index , E x ) { if ( index == 0 ) { queue[0] = x ; return 0 ; } int parentIndex = getParentIndex ( index ) ; E parentElement = elementData ( parentIndex ) ; if ( parentIndex != 0 ) { int grandparentIndex = getParentIndex ( parentIndex ) ; int uncleIndex = getRightChildIndex ( grandparentIndex ) ; if ( uncleIndex != parentIndex && getLeftChildIndex ( uncleIndex ) > = size ) { E uncleElement = elementData ( uncleIndex ) ; if ( ordering.compare ( uncleElement , parentElement ) < 0 ) { parentIndex = uncleIndex ; parentElement = uncleElement ; } } } if ( ordering.compare ( parentElement , x ) < 0 ) { queue[index] = parentElement ; queue[parentIndex] = x ; return parentIndex ; } queue[index] = x ; return index ; } 
int swapWithConceptuallyLastElement ( E actualLastElement ) { int parentIndex = getParentIndex ( size ) ; if ( parentIndex != 0 ) { int grandparentIndex = getParentIndex ( parentIndex ) ; int uncleIndex = getRightChildIndex ( grandparentIndex ) ; if ( uncleIndex != parentIndex && getLeftChildIndex ( uncleIndex ) > = size ) { E uncleElement = elementData ( uncleIndex ) ; if ( ordering.compare ( uncleElement , actualLastElement ) < 0 ) { queue[uncleIndex] = actualLastElement ; queue[size] = uncleElement ; return uncleIndex ; } } } return size ; } 
public E next ( ) { checkModCount ( ) ; nextNotInSkipMe ( cursor + 1 ) ; if ( nextCursor < size ( ) ) { cursor = nextCursor ; canRemove = true ; return elementData ( cursor ) ; } else if ( forgetMeNot != null ) { cursor = size ( ) ; lastFromForgetMeNot = forgetMeNot.poll ( ) ; if ( lastFromForgetMeNot != null ) { canRemove = true ; return lastFromForgetMeNot ; } } throw new NoSuchElementException ( " iterator moved past last element in queue. " ) ; } 
public void remove ( ) { checkRemove ( canRemove ) ; checkModCount ( ) ; canRemove = false ; expectedModCount++ ; if ( cursor < size ( ) ) { MoveDesc < E > moved = removeAt ( cursor ) ; if ( moved != null ) { if ( forgetMeNot == null ) { forgetMeNot = new ArrayDeque < E > ( ) ; skipMe = new ArrayList < E > ( 3 ) ; } if ( !foundAndRemovedExactReference ( skipMe , moved.toTrickle ) ) { forgetMeNot.add ( moved.toTrickle ) ; } if ( !foundAndRemovedExactReference ( forgetMeNot , moved.replaced ) ) { skipMe.add ( moved.replaced ) ; } } cursor-- ; nextCursor-- ; } else { checkState ( removeExact ( lastFromForgetMeNot ) ) ; lastFromForgetMeNot = null ; } } 
ToOptionalState combine ( ToOptionalState other ) { if ( element == null ) { return other ; } else if ( other.element == null ) { return this ; } else { if ( extras == null ) { extras = new ArrayList < > ( ) ; } extras.add ( other.element ) ; if ( other.extras != null ) { this.extras.addAll ( other.extras ) ; } if ( extras.size ( ) > MAX_EXTRAS ) { extras.subList ( MAX_EXTRAS , extras.size ( ) ) .clear ( ) ; throw multiples ( true ) ; } return this ; } } 
public static MultimapBuilderWithKeys < Object > linkedHashKeys ( final int expectedKeys ) { checkNonnegative ( expectedKeys , " expectedKeys " ) ; return new MultimapBuilderWithKeys < Object > ( ) { @Override < K , V > Map < K , Collection < V > > createMap ( ) { return Platform.newLinkedHashMapWithExpectedSize ( expectedKeys ) ; } } ; } 
public static < K0 extends Enum < K0 > > MultimapBuilderWithKeys < K0 > enumKeys ( final Class < K0 > keyClass ) { checkNotNull ( keyClass ) ; return new MultimapBuilderWithKeys < K0 > ( ) { @SuppressWarnings ( " unchecked " ) @Override < K extends K0 , V > Map < K , Collection < V > > createMap ( ) { return ( Map < K , Collection < V > > ) new EnumMap < K0 , Collection < V > > ( keyClass ) ; } } ; } 
public ListMultimapBuilder < K0 , Object > linkedListValues ( ) { return new ListMultimapBuilder < K0 , Object > ( ) { @Override public < K extends K0 , V > ListMultimap < K , V > build ( ) { return Multimaps.newListMultimap ( MultimapBuilderWithKeys.this. < K , V > createMap ( ) , LinkedListSupplier. < V > instance ( ) ) ; } } ; } 
public SetMultimapBuilder < K0 , Object > hashSetValues ( final int expectedValuesPerKey ) { checkNonnegative ( expectedValuesPerKey , " expectedValuesPerKey " ) ; return new SetMultimapBuilder < K0 , Object > ( ) { @Override public < K extends K0 , V > SetMultimap < K , V > build ( ) { return Multimaps.newSetMultimap ( MultimapBuilderWithKeys.this. < K , V > createMap ( ) , new HashSetSupplier < V > ( expectedValuesPerKey ) ) ; } } ; } 
public < V0 > SortedSetMultimapBuilder < K0 , V0 > treeSetValues ( final Comparator < V0 > comparator ) { checkNotNull ( comparator , " comparator " ) ; return new SortedSetMultimapBuilder < K0 , V0 > ( ) { @Override public < K extends K0 , V extends V0 > SortedSetMultimap < K , V > build ( ) { return Multimaps.newSortedSetMultimap ( MultimapBuilderWithKeys.this. < K , V > createMap ( ) , new TreeSetSupplier < V > ( comparator ) ) ; } } ; } 
public static < T , K , V , M extends Multimap < K , V > > Collector < T , ? , M > toMultimap ( java.util.function.Function < ? super T , ? extends K > keyFunction , java.util.function.Function < ? super T , ? extends V > valueFunction , java.util.function.Supplier < M > multimapSupplier ) { checkNotNull ( keyFunction ) ; checkNotNull ( valueFunction ) ; checkNotNull ( multimapSupplier ) ; return Collector.of ( multimapSupplier , ( multimap , input ) - > multimap.put ( keyFunction.apply ( input ) , valueFunction.apply ( input ) ) , ( multimap1 , multimap2 ) - > { multimap1.putAll ( multimap2 ) ; return multimap1 ; } ) ; } 
public static < T , K , V , M extends Multimap < K , V > > Collector < T , ? , M > flatteningToMultimap ( java.util.function.Function < ? super T , ? extends K > keyFunction , java.util.function.Function < ? super T , ? extends Stream < ? extends V > > valueFunction , java.util.function.Supplier < M > multimapSupplier ) { checkNotNull ( keyFunction ) ; checkNotNull ( valueFunction ) ; checkNotNull ( multimapSupplier ) ; return Collector.of ( multimapSupplier , ( multimap , input ) - > { K key = keyFunction.apply ( input ) ; Collection < V > valuesForKey = multimap.get ( key ) ; valueFunction.apply ( input ) .forEachOrdered ( valuesForKey::add ) ; } , ( multimap1 , multimap2 ) - > { multimap1.putAll ( multimap2 ) ; return multimap1 ; } ) ; } 
Collection < V > wrapCollection ( K key , Collection < V > collection ) { if ( collection instanceof List ) { return wrapList ( key , ( List < V > ) collection , null ) ; } else if ( collection instanceof NavigableSet ) { return new WrappedNavigableSet ( key , ( NavigableSet < V > ) collection , null ) ; } else if ( collection instanceof SortedSet ) { return new WrappedSortedSet ( key , ( SortedSet < V > ) collection , null ) ; } else if ( collection instanceof Set ) { return new WrappedSet ( key , ( Set < V > ) collection ) ; } else { return new WrappedCollection ( key , collection , null ) ; } } 
public static < K , V > ListMultimap < K , V > newListMultimap ( Map < K , Collection < V > > map , final Supplier < ? extends List < V > > factory ) { return new CustomListMultimap < > ( map , factory ) ; } 
 < E > Collection < E > unmodifiableCollectionSubclass ( Collection < E > collection ) { if ( collection instanceof NavigableSet ) { return Sets.unmodifiableNavigableSet ( ( NavigableSet < E > ) collection ) ; } else if ( collection instanceof SortedSet ) { return Collections.unmodifiableSortedSet ( ( SortedSet < E > ) collection ) ; } else { return Collections.unmodifiableSet ( ( Set < E > ) collection ) ; } } 
public static < K , V > SortedSetMultimap < K , V > newSortedSetMultimap ( Map < K , Collection < V > > map , final Supplier < ? extends SortedSet < V > > factory ) { return new CustomSortedSetMultimap < > ( map , factory ) ; } 
public static < K , V , M extends Multimap < K , V > > M invertFrom ( Multimap < ? extends V , ? extends K > source , M dest ) { checkNotNull ( dest ) ; for ( Map.Entry < ? extends V , ? extends K > entry : source.entries ( ) ) { dest.put ( entry.getValue ( ) , entry.getKey ( ) ) ; } return dest ; } 
public Map < K , Collection < V > > asMap ( ) { Map < K , Collection < V > > result = map ; if ( result == null ) { result = map = Collections.unmodifiableMap ( Maps.transformValues ( delegate.asMap ( ) , new Function < Collection < V > , Collection < V > > ( ) { @Override public Collection < V > apply ( Collection < V > collection ) { return unmodifiableValueCollection ( collection ) ; } } ) ) ; } return result ; } 
public List < V > replaceValues ( K key , Iterable < ? extends V > values ) { throw new UnsupportedOperationException ( ) ; } 
public Set < V > replaceValues ( K key , Iterable < ? extends V > values ) { throw new UnsupportedOperationException ( ) ; } 
public SortedSet < V > removeAll ( Object key ) { throw new UnsupportedOperationException ( ) ; } 
public SortedSet < V > replaceValues ( K key , Iterable < ? extends V > values ) { throw new UnsupportedOperationException ( ) ; } 
public Set < V > get ( final K key ) { return new Sets.ImprovedAbstractSet < V > ( ) { @Override public Iterator < V > iterator ( ) { return new Iterator < V > ( ) { int i ; @Override public boolean hasNext ( ) { return ( i == 0 ) && map.containsKey ( key ) ; } @Override public V next ( ) { if ( !hasNext ( ) ) { throw new NoSuchElementException ( ) ; } i++ ; return map.get ( key ) ; } @Override public void remove ( ) { checkRemove ( i == 1 ) ; i = -1 ; map.remove ( key ) ; } } ; } @Override public int size ( ) { return map.containsKey ( key ) ? 1 : 0 ; } } ; } 
public Iterator < V > iterator ( ) { return new Iterator < V > ( ) { int i ; @Override public boolean hasNext ( ) { return ( i == 0 ) && map.containsKey ( key ) ; } @Override public V next ( ) { if ( !hasNext ( ) ) { throw new NoSuchElementException ( ) ; } i++ ; return map.get ( key ) ; } @Override public void remove ( ) { checkRemove ( i == 1 ) ; i = -1 ; map.remove ( key ) ; } } ; } 
public static < K , V1 , V2 > Multimap < K , V2 > transformEntries ( Multimap < K , V1 > fromMap , EntryTransformer < ? super K , ? super V1 , V2 > transformer ) { return new TransformedEntriesMultimap < > ( fromMap , transformer ) ; } 
public static < K , V1 , V2 > ListMultimap < K , V2 > transformEntries ( ListMultimap < K , V1 > fromMap , EntryTransformer < ? super K , ? super V1 , V2 > transformer ) { return new TransformedEntriesListMultimap < > ( fromMap , transformer ) ; } 
Map < K , Collection < V2 > > createAsMap ( ) { return Maps.transformEntries ( fromMultimap.asMap ( ) , new EntryTransformer < K , Collection < V1 > , Collection < V2 > > ( ) { @Override public Collection < V2 > transformEntry ( K key , Collection < V1 > value ) { return transform ( key , value ) ; } } ) ; } 
public boolean putAll ( Multimap < ? extends K , ? extends V2 > multimap ) { throw new UnsupportedOperationException ( ) ; } 
public Collection < V2 > replaceValues ( K key , Iterable < ? extends V2 > values ) { throw new UnsupportedOperationException ( ) ; } 
public static < K , V > ImmutableListMultimap < K , V > index ( Iterator < V > values , Function < ? super V , K > keyFunction ) { checkNotNull ( keyFunction ) ; ImmutableListMultimap.Builder < K , V > builder = ImmutableListMultimap.builder ( ) ; while ( values.hasNext ( ) ) { V value = values.next ( ) ; checkNotNull ( value , values ) ; builder.put ( keyFunction.apply ( value ) , value ) ; } return builder.build ( ) ; } 
Iterator < Multiset.Entry < K > > entryIterator ( ) { return new TransformedIterator < Map.Entry < K , Collection < V > > , Multiset.Entry < K > > ( multimap.asMap ( ) .entrySet ( ) .iterator ( ) ) { @Override Multiset.Entry < K > transform ( final Map.Entry < K , Collection < V > > backingEntry ) { return new Multisets.AbstractEntry < K > ( ) { @Override public K getElement ( ) { return backingEntry.getKey ( ) ; } @Override public int getCount ( ) { return backingEntry.getValue ( ) .size ( ) ; } } ; } } ; } 
Multiset.Entry < K > transform ( final Map.Entry < K , Collection < V > > backingEntry ) { return new Multisets.AbstractEntry < K > ( ) { @Override public K getElement ( ) { return backingEntry.getKey ( ) ; } @Override public int getCount ( ) { return backingEntry.getValue ( ) .size ( ) ; } } ; } 
public int remove ( @Nullable Object element , int occurrences ) { checkNonnegative ( occurrences , " occurrences " ) ; if ( occurrences == 0 ) { return count ( element ) ; } Collection < V > values = Maps.safeGet ( multimap.asMap ( ) , element ) ; if ( values == null ) { return 0 ; } int oldCount = values.size ( ) ; if ( occurrences > = oldCount ) { values.clear ( ) ; } else { Iterator < V > iterator = values.iterator ( ) ; for ( int i = 0 ; i < occurrences ; i++ ) { iterator.next ( ) ; iterator.remove ( ) ; } } return oldCount ; } 
public static < K , V > Multimap < K , V > filterKeys ( Multimap < K , V > unfiltered , final Predicate < ? super K > keyPredicate ) { if ( unfiltered instanceof SetMultimap ) { return filterKeys ( ( SetMultimap < K , V > ) unfiltered , keyPredicate ) ; } else if ( unfiltered instanceof ListMultimap ) { return filterKeys ( ( ListMultimap < K , V > ) unfiltered , keyPredicate ) ; } else if ( unfiltered instanceof FilteredKeyMultimap ) { FilteredKeyMultimap < K , V > prev = ( FilteredKeyMultimap < K , V > ) unfiltered ; return new FilteredKeyMultimap < > ( prev.unfiltered , Predicates. < K > and ( prev.keyPredicate , keyPredicate ) ) ; } else if ( unfiltered instanceof FilteredMultimap ) { FilteredMultimap < K , V > prev = ( FilteredMultimap < K , V > ) unfiltered ; return filterFiltered ( prev , Maps. < K > keyPredicateOnEntries ( keyPredicate ) ) ; } else { return new FilteredKeyMultimap < > ( unfiltered , keyPredicate ) ; } } 
public static < K , V > SetMultimap < K , V > filterKeys ( SetMultimap < K , V > unfiltered , final Predicate < ? super K > keyPredicate ) { if ( unfiltered instanceof FilteredKeySetMultimap ) { FilteredKeySetMultimap < K , V > prev = ( FilteredKeySetMultimap < K , V > ) unfiltered ; return new FilteredKeySetMultimap < > ( prev.unfiltered ( ) , Predicates. < K > and ( prev.keyPredicate , keyPredicate ) ) ; } else if ( unfiltered instanceof FilteredSetMultimap ) { FilteredSetMultimap < K , V > prev = ( FilteredSetMultimap < K , V > ) unfiltered ; return filterFiltered ( prev , Maps. < K > keyPredicateOnEntries ( keyPredicate ) ) ; } else { return new FilteredKeySetMultimap < > ( unfiltered , keyPredicate ) ; } } 
public static < K , V > ListMultimap < K , V > filterKeys ( ListMultimap < K , V > unfiltered , final Predicate < ? super K > keyPredicate ) { if ( unfiltered instanceof FilteredKeyListMultimap ) { FilteredKeyListMultimap < K , V > prev = ( FilteredKeyListMultimap < K , V > ) unfiltered ; return new FilteredKeyListMultimap < > ( prev.unfiltered ( ) , Predicates. < K > and ( prev.keyPredicate , keyPredicate ) ) ; } else { return new FilteredKeyListMultimap < > ( unfiltered , keyPredicate ) ; } } 
public static < K , V > Multimap < K , V > filterEntries ( Multimap < K , V > unfiltered , Predicate < ? super Entry < K , V > > entryPredicate ) { checkNotNull ( entryPredicate ) ; if ( unfiltered instanceof SetMultimap ) { return filterEntries ( ( SetMultimap < K , V > ) unfiltered , entryPredicate ) ; } return ( unfiltered instanceof FilteredMultimap ) ? filterFiltered ( ( FilteredMultimap < K , V > ) unfiltered , entryPredicate ) : new FilteredEntryMultimap < K , V > ( checkNotNull ( unfiltered ) , entryPredicate ) ; } 
public Set < E > elementSet ( ) { Set < E > es = elementSet ; return ( es == null ) ? elementSet = createElementSet ( ) : es ; } 
public int add ( E element , int occurences ) { throw new UnsupportedOperationException ( ) ; } 
public boolean addAll ( Collection < ? extends E > elementsToAdd ) { throw new UnsupportedOperationException ( ) ; } 
public boolean remove ( Object element ) { throw new UnsupportedOperationException ( ) ; } 
public int remove ( Object element , int occurrences ) { throw new UnsupportedOperationException ( ) ; } 
public boolean removeAll ( Collection < ? > elementsToRemove ) { throw new UnsupportedOperationException ( ) ; } 
public boolean retainAll ( Collection < ? > elementsToRetain ) { throw new UnsupportedOperationException ( ) ; } 
public int setCount ( E element , int count ) { throw new UnsupportedOperationException ( ) ; } 
public boolean setCount ( E element , int oldCount , int newCount ) { throw new UnsupportedOperationException ( ) ; } 
Set < Entry < E > > createEntrySet ( ) { return Sets.filter ( unfiltered.entrySet ( ) , new Predicate < Entry < E > > ( ) { @Override public boolean apply ( Entry < E > entry ) { return predicate.apply ( entry.getElement ( ) ) ; } } ) ; } 
public static < E > Multiset < E > union ( final Multiset < ? extends E > multiset1 , final Multiset < ? extends E > multiset2 ) { checkNotNull ( multiset1 ) ; checkNotNull ( multiset2 ) ; return new ViewMultiset < E > ( ) { @Override public boolean contains ( @Nullable Object element ) { return multiset1.contains ( element ) || multiset2.contains ( element ) ; } @Override public boolean isEmpty ( ) { return multiset1.isEmpty ( ) && multiset2.isEmpty ( ) ; } @Override public int count ( Object element ) { return Math.max ( multiset1.count ( element ) , multiset2.count ( element ) ) ; } @Override Set < E > createElementSet ( ) { return Sets.union ( multiset1.elementSet ( ) , multiset2.elementSet ( ) ) ; } @Override Iterator < E > elementIterator ( ) { throw new AssertionError ( " should never be called " ) ; } @Override Iterator < Entry < E > > entryIterator ( ) { final Iterator < ? extends Entry < ? extends E > > iterator1 = multiset1.entrySet ( ) .iterator ( ) ; final Iterator < ? extends Entry < ? extends E > > iterator2 = multiset2.entrySet ( ) .iterator ( ) ; return new AbstractIterator < Entry < E > > ( ) { @Override protected Entry < E > computeNext ( ) { if ( iterator1.hasNext ( ) ) { Entry < ? extends E > entry1 = iterator1.next ( ) ; E element = entry1.getElement ( ) ; int count = Math.max ( entry1.getCount ( ) , multiset2.count ( element ) ) ; return immutableEntry ( element , count ) ; } while ( iterator2.hasNext ( ) ) { Entry < ? extends E > entry2 = iterator2.next ( ) ; E element = entry2.getElement ( ) ; if ( !multiset1.contains ( element ) ) { return immutableEntry ( element , entry2.getCount ( ) ) ; } } return endOfData ( ) ; } } ; } } ; } 
Iterator < Entry < E > > entryIterator ( ) { final Iterator < ? extends Entry < ? extends E > > iterator1 = multiset1.entrySet ( ) .iterator ( ) ; final Iterator < ? extends Entry < ? extends E > > iterator2 = multiset2.entrySet ( ) .iterator ( ) ; return new AbstractIterator < Entry < E > > ( ) { @Override protected Entry < E > computeNext ( ) { if ( iterator1.hasNext ( ) ) { Entry < ? extends E > entry1 = iterator1.next ( ) ; E element = entry1.getElement ( ) ; int count = Math.max ( entry1.getCount ( ) , multiset2.count ( element ) ) ; return immutableEntry ( element , count ) ; } while ( iterator2.hasNext ( ) ) { Entry < ? extends E > entry2 = iterator2.next ( ) ; E element = entry2.getElement ( ) ; if ( !multiset1.contains ( element ) ) { return immutableEntry ( element , entry2.getCount ( ) ) ; } } return endOfData ( ) ; } } ; } 
protected Entry < E > computeNext ( ) { if ( iterator1.hasNext ( ) ) { Entry < ? extends E > entry1 = iterator1.next ( ) ; E element = entry1.getElement ( ) ; int count = Math.max ( entry1.getCount ( ) , multiset2.count ( element ) ) ; return immutableEntry ( element , count ) ; } while ( iterator2.hasNext ( ) ) { Entry < ? extends E > entry2 = iterator2.next ( ) ; E element = entry2.getElement ( ) ; if ( !multiset1.contains ( element ) ) { return immutableEntry ( element , entry2.getCount ( ) ) ; } } return endOfData ( ) ; } 
public static < E > Multiset < E > intersection ( final Multiset < E > multiset1 , final Multiset < ? > multiset2 ) { checkNotNull ( multiset1 ) ; checkNotNull ( multiset2 ) ; return new ViewMultiset < E > ( ) { @Override public int count ( Object element ) { int count1 = multiset1.count ( element ) ; return ( count1 == 0 ) ? 0 : Math.min ( count1 , multiset2.count ( element ) ) ; } @Override Set < E > createElementSet ( ) { return Sets.intersection ( multiset1.elementSet ( ) , multiset2.elementSet ( ) ) ; } @Override Iterator < E > elementIterator ( ) { throw new AssertionError ( " should never be called " ) ; } @Override Iterator < Entry < E > > entryIterator ( ) { final Iterator < Entry < E > > iterator1 = multiset1.entrySet ( ) .iterator ( ) ; return new AbstractIterator < Entry < E > > ( ) { @Override protected Entry < E > computeNext ( ) { while ( iterator1.hasNext ( ) ) { Entry < E > entry1 = iterator1.next ( ) ; E element = entry1.getElement ( ) ; int count = Math.min ( entry1.getCount ( ) , multiset2.count ( element ) ) ; if ( count > 0 ) { return immutableEntry ( element , count ) ; } } return endOfData ( ) ; } } ; } } ; } 
Iterator < Entry < E > > entryIterator ( ) { final Iterator < Entry < E > > iterator1 = multiset1.entrySet ( ) .iterator ( ) ; return new AbstractIterator < Entry < E > > ( ) { @Override protected Entry < E > computeNext ( ) { while ( iterator1.hasNext ( ) ) { Entry < E > entry1 = iterator1.next ( ) ; E element = entry1.getElement ( ) ; int count = Math.min ( entry1.getCount ( ) , multiset2.count ( element ) ) ; if ( count > 0 ) { return immutableEntry ( element , count ) ; } } return endOfData ( ) ; } } ; } 
public static < E > Multiset < E > sum ( final Multiset < ? extends E > multiset1 , final Multiset < ? extends E > multiset2 ) { checkNotNull ( multiset1 ) ; checkNotNull ( multiset2 ) ; return new ViewMultiset < E > ( ) { @Override public boolean contains ( @Nullable Object element ) { return multiset1.contains ( element ) || multiset2.contains ( element ) ; } @Override public boolean isEmpty ( ) { return multiset1.isEmpty ( ) && multiset2.isEmpty ( ) ; } @Override public int size ( ) { return IntMath.saturatedAdd ( multiset1.size ( ) , multiset2.size ( ) ) ; } @Override public int count ( Object element ) { return multiset1.count ( element ) + multiset2.count ( element ) ; } @Override Set < E > createElementSet ( ) { return Sets.union ( multiset1.elementSet ( ) , multiset2.elementSet ( ) ) ; } @Override Iterator < E > elementIterator ( ) { throw new AssertionError ( " should never be called " ) ; } @Override Iterator < Entry < E > > entryIterator ( ) { final Iterator < ? extends Entry < ? extends E > > iterator1 = multiset1.entrySet ( ) .iterator ( ) ; final Iterator < ? extends Entry < ? extends E > > iterator2 = multiset2.entrySet ( ) .iterator ( ) ; return new AbstractIterator < Entry < E > > ( ) { @Override protected Entry < E > computeNext ( ) { if ( iterator1.hasNext ( ) ) { Entry < ? extends E > entry1 = iterator1.next ( ) ; E element = entry1.getElement ( ) ; int count = entry1.getCount ( ) + multiset2.count ( element ) ; return immutableEntry ( element , count ) ; } while ( iterator2.hasNext ( ) ) { Entry < ? extends E > entry2 = iterator2.next ( ) ; E element = entry2.getElement ( ) ; if ( !multiset1.contains ( element ) ) { return immutableEntry ( element , entry2.getCount ( ) ) ; } } return endOfData ( ) ; } } ; } } ; } 
Iterator < Entry < E > > entryIterator ( ) { final Iterator < ? extends Entry < ? extends E > > iterator1 = multiset1.entrySet ( ) .iterator ( ) ; final Iterator < ? extends Entry < ? extends E > > iterator2 = multiset2.entrySet ( ) .iterator ( ) ; return new AbstractIterator < Entry < E > > ( ) { @Override protected Entry < E > computeNext ( ) { if ( iterator1.hasNext ( ) ) { Entry < ? extends E > entry1 = iterator1.next ( ) ; E element = entry1.getElement ( ) ; int count = entry1.getCount ( ) + multiset2.count ( element ) ; return immutableEntry ( element , count ) ; } while ( iterator2.hasNext ( ) ) { Entry < ? extends E > entry2 = iterator2.next ( ) ; E element = entry2.getElement ( ) ; if ( !multiset1.contains ( element ) ) { return immutableEntry ( element , entry2.getCount ( ) ) ; } } return endOfData ( ) ; } } ; } 
protected Entry < E > computeNext ( ) { if ( iterator1.hasNext ( ) ) { Entry < ? extends E > entry1 = iterator1.next ( ) ; E element = entry1.getElement ( ) ; int count = entry1.getCount ( ) + multiset2.count ( element ) ; return immutableEntry ( element , count ) ; } while ( iterator2.hasNext ( ) ) { Entry < ? extends E > entry2 = iterator2.next ( ) ; E element = entry2.getElement ( ) ; if ( !multiset1.contains ( element ) ) { return immutableEntry ( element , entry2.getCount ( ) ) ; } } return endOfData ( ) ; } 
public static < E > Multiset < E > difference ( final Multiset < E > multiset1 , final Multiset < ? > multiset2 ) { checkNotNull ( multiset1 ) ; checkNotNull ( multiset2 ) ; return new ViewMultiset < E > ( ) { @Override public int count ( @Nullable Object element ) { int count1 = multiset1.count ( element ) ; return ( count1 == 0 ) ? 0 : Math.max ( 0 , count1 - multiset2.count ( element ) ) ; } @Override public void clear ( ) { throw new UnsupportedOperationException ( ) ; } @Override Iterator < E > elementIterator ( ) { final Iterator < Entry < E > > iterator1 = multiset1.entrySet ( ) .iterator ( ) ; return new AbstractIterator < E > ( ) { @Override protected E computeNext ( ) { while ( iterator1.hasNext ( ) ) { Entry < E > entry1 = iterator1.next ( ) ; E element = entry1.getElement ( ) ; if ( entry1.getCount ( ) > multiset2.count ( element ) ) { return element ; } } return endOfData ( ) ; } } ; } @Override Iterator < Entry < E > > entryIterator ( ) { final Iterator < Entry < E > > iterator1 = multiset1.entrySet ( ) .iterator ( ) ; return new AbstractIterator < Entry < E > > ( ) { @Override protected Entry < E > computeNext ( ) { while ( iterator1.hasNext ( ) ) { Entry < E > entry1 = iterator1.next ( ) ; E element = entry1.getElement ( ) ; int count = entry1.getCount ( ) - multiset2.count ( element ) ; if ( count > 0 ) { return immutableEntry ( element , count ) ; } } return endOfData ( ) ; } } ; } @Override int distinctElements ( ) { return Iterators.size ( entryIterator ( ) ) ; } } ; } 
Iterator < E > elementIterator ( ) { final Iterator < Entry < E > > iterator1 = multiset1.entrySet ( ) .iterator ( ) ; return new AbstractIterator < E > ( ) { @Override protected E computeNext ( ) { while ( iterator1.hasNext ( ) ) { Entry < E > entry1 = iterator1.next ( ) ; E element = entry1.getElement ( ) ; if ( entry1.getCount ( ) > multiset2.count ( element ) ) { return element ; } } return endOfData ( ) ; } } ; } 
Iterator < Entry < E > > entryIterator ( ) { final Iterator < Entry < E > > iterator1 = multiset1.entrySet ( ) .iterator ( ) ; return new AbstractIterator < Entry < E > > ( ) { @Override protected Entry < E > computeNext ( ) { while ( iterator1.hasNext ( ) ) { Entry < E > entry1 = iterator1.next ( ) ; E element = entry1.getElement ( ) ; int count = entry1.getCount ( ) - multiset2.count ( element ) ; if ( count > 0 ) { return immutableEntry ( element , count ) ; } } return endOfData ( ) ; } } ; } 
private static < E > boolean retainOccurrencesImpl ( Multiset < E > multisetToModify , Multiset < ? > occurrencesToRetain ) { checkNotNull ( multisetToModify ) ; checkNotNull ( occurrencesToRetain ) ; Iterator < Entry < E > > entryIterator = multisetToModify.entrySet ( ) .iterator ( ) ; boolean changed = false ; while ( entryIterator.hasNext ( ) ) { Entry < E > entry = entryIterator.next ( ) ; int retainCount = occurrencesToRetain.count ( entry.getElement ( ) ) ; if ( retainCount == 0 ) { entryIterator.remove ( ) ; changed = true ; } else if ( retainCount < entry.getCount ( ) ) { multisetToModify.setCount ( entry.getElement ( ) , retainCount ) ; changed = true ; } } return changed ; } 
public static boolean removeOccurrences ( Multiset < ? > multisetToModify , Multiset < ? > occurrencesToRemove ) { checkNotNull ( multisetToModify ) ; checkNotNull ( occurrencesToRemove ) ; boolean changed = false ; Iterator < ? extends Entry < ? > > entryIterator = multisetToModify.entrySet ( ) .iterator ( ) ; while ( entryIterator.hasNext ( ) ) { Entry < ? > entry = entryIterator.next ( ) ; int removeCount = occurrencesToRemove.count ( entry.getElement ( ) ) ; if ( removeCount > = entry.getCount ( ) ) { entryIterator.remove ( ) ; changed = true ; } else if ( removeCount > 0 ) { multisetToModify.remove ( entry.getElement ( ) , removeCount ) ; changed = true ; } } return changed ; } 
static boolean equalsImpl ( Multiset < ? > multiset , @Nullable Object object ) { if ( object == multiset ) { return true ; } if ( object instanceof Multiset ) { Multiset < ? > that = ( Multiset < ? > ) object ; if ( multiset.size ( ) != that.size ( ) || multiset.entrySet ( ) .size ( ) != that.entrySet ( ) .size ( ) ) { return false ; } for ( Entry < ? > entry : that.entrySet ( ) ) { if ( multiset.count ( entry.getElement ( ) ) != entry.getCount ( ) ) { return false ; } } return true ; } return false ; } 
static < E > Iterator < E > elementIterator ( Iterator < Entry < E > > entryIterator ) { return new TransformedIterator < Entry < E > , E > ( entryIterator ) { @Override E transform ( Entry < E > entry ) { return entry.getElement ( ) ; } } ; } 
public Set < Entry < Class < ? extends B > , B > > entrySet ( ) { return new ForwardingSet < Entry < Class < ? extends B > , B > > ( ) { @Override protected Set < Entry < Class < ? extends B > , B > > delegate ( ) { return MutableClassToInstanceMap.this.delegate ( ) .entrySet ( ) ; } @Override public Spliterator < Entry < Class < ? extends B > , B > > spliterator ( ) { return CollectSpliterators.map ( delegate ( ) .spliterator ( ) , MutableClassToInstanceMap::checkedEntry ) ; } @Override public Iterator < Entry < Class < ? extends B > , B > > iterator ( ) { return new TransformedIterator < Entry < Class < ? extends B > , B > , Entry < Class < ? extends B > , B > > ( delegate ( ) .iterator ( ) ) { @Override Entry < Class < ? extends B > , B > transform ( Entry < Class < ? extends B > , B > from ) { return checkedEntry ( from ) ; } } ; } @Override public Object[] toArray ( ) { return standardToArray ( ) ; } @Override public < T > T[] toArray ( T[] array ) { return standardToArray ( array ) ; } } ; } 
public int compare ( Object left , Object right ) { if ( left == right ) { return 0 ; } else if ( left == null ) { return -1 ; } else if ( right == null ) { return 1 ; } int leftCode = identityHashCode ( left ) ; int rightCode = identityHashCode ( right ) ; if ( leftCode != rightCode ) { return leftCode < rightCode ? -1 : 1 ; } int result = getUid ( left ) .compareTo ( getUid ( right ) ) ; if ( result == 0 ) { throw new AssertionError ( ) ; } return result ; } 
public < E extends T > List < E > leastOf ( Iterable < E > iterable , int k ) { if ( iterable instanceof Collection ) { Collection < E > collection = ( Collection < E > ) iterable ; if ( collection.size ( ) < = 2L * k ) { @SuppressWarnings ( " unchecked " ) E[] array = ( E[] ) collection.toArray ( ) ; Arrays.sort ( array , this ) ; if ( array.length > k ) { array = Arrays.copyOf ( array , k ) ; } return Collections.unmodifiableList ( Arrays.asList ( array ) ) ; } } return leastOf ( iterable.iterator ( ) , k ) ; } 
public < E extends T > List < E > leastOf ( Iterator < E > iterator , int k ) { checkNotNull ( iterator ) ; checkNonnegative ( k , " k " ) ; if ( k == 0 || !iterator.hasNext ( ) ) { return Collections.emptyList ( ) ; } else if ( k > = Integer.MAX_VALUE / 2 ) { ArrayList < E > list = Lists.newArrayList ( iterator ) ; Collections.sort ( list , this ) ; if ( list.size ( ) > k ) { list.subList ( k , list.size ( ) ) .clear ( ) ; } list.trimToSize ( ) ; return Collections.unmodifiableList ( list ) ; } else { TopKSelector < E > selector = TopKSelector.least ( k , this ) ; selector.offerAll ( iterator ) ; return selector.topK ( ) ; } } 
public static < E > int drain ( BlockingQueue < E > q , Collection < ? super E > buffer , int numElements , long timeout , TimeUnit unit ) throws InterruptedException { Preconditions.checkNotNull ( buffer ) ; long deadline = System.nanoTime ( ) + unit.toNanos ( timeout ) ; int added = 0 ; while ( added < numElements ) { added += q.drainTo ( buffer , numElements - added ) ; if ( added < numElements ) { E e = q.poll ( deadline - System.nanoTime ( ) , TimeUnit.NANOSECONDS ) ; if ( e == null ) { break ; } buffer.add ( e ) ; added++ ; } } return added ; } 
public static < E > int drainUninterruptibly ( BlockingQueue < E > q , Collection < ? super E > buffer , int numElements , long timeout , TimeUnit unit ) { Preconditions.checkNotNull ( buffer ) ; long deadline = System.nanoTime ( ) + unit.toNanos ( timeout ) ; int added = 0 ; boolean interrupted = false ; try { while ( added < numElements ) { added += q.drainTo ( buffer , numElements - added ) ; if ( added < numElements ) { E e ; while ( true ) { try { e = q.poll ( deadline - System.nanoTime ( ) , TimeUnit.NANOSECONDS ) ; break ; } catch ( InterruptedException ex ) { interrupted = true ; } } if ( e == null ) { break ; } buffer.add ( e ) ; added++ ; } } } finally { if ( interrupted ) { Thread.currentThread ( ) .interrupt ( ) ; } } return added ; } 
public static < C extends Comparable < ? > > Range < C > upTo ( C endpoint , BoundType boundType ) { switch ( boundType ) { case OPEN: return lessThan ( endpoint ) ; case CLOSED: return atMost ( endpoint ) ; default: throw new AssertionError ( ) ; } } 
public static < C extends Comparable < ? > > Range < C > downTo ( C endpoint , BoundType boundType ) { switch ( boundType ) { case OPEN: return greaterThan ( endpoint ) ; case CLOSED: return atLeast ( endpoint ) ; default: throw new AssertionError ( ) ; } } 
public static < C extends Comparable < ? > > Range < C > encloseAll ( Iterable < C > values ) { checkNotNull ( values ) ; if ( values instanceof SortedSet ) { SortedSet < ? extends C > set = cast ( values ) ; Comparator < ? > comparator = set.comparator ( ) ; if ( Ordering.natural ( ) .equals ( comparator ) || comparator == null ) { return closed ( set.first ( ) , set.last ( ) ) ; } } Iterator < C > valueIterator = values.iterator ( ) ; C min = checkNotNull ( valueIterator.next ( ) ) ; C max = min ; while ( valueIterator.hasNext ( ) ) { C value = checkNotNull ( valueIterator.next ( ) ) ; min = Ordering.natural ( ) .min ( min , value ) ; max = Ordering.natural ( ) .max ( max , value ) ; } return closed ( min , max ) ; } 
public boolean containsAll ( Iterable < ? extends C > values ) { if ( Iterables.isEmpty ( values ) ) { return true ; } if ( values instanceof SortedSet ) { SortedSet < ? extends C > set = cast ( values ) ; Comparator < ? > comparator = set.comparator ( ) ; if ( Ordering.natural ( ) .equals ( comparator ) || comparator == null ) { return contains ( set.first ( ) ) && contains ( set.last ( ) ) ; } } for ( C value : values ) { if ( !contains ( value ) ) { return false ; } } return true ; } 
public Range < C > span ( Range < C > other ) { int lowerCmp = lowerBound.compareTo ( other.lowerBound ) ; int upperCmp = upperBound.compareTo ( other.upperBound ) ; if ( lowerCmp < = 0 && upperCmp > = 0 ) { return this ; } else if ( lowerCmp > = 0 && upperCmp < = 0 ) { return other ; } else { Cut < C > newLower = ( lowerCmp < = 0 ) ? lowerBound : other.lowerBound ; Cut < C > newUpper = ( upperCmp > = 0 ) ? upperBound : other.upperBound ; return create ( newLower , newUpper ) ; } } 
public UnmodifiableIterator < C > iterator ( ) { return new AbstractSequentialIterator < C > ( first ( ) ) { final C last = last ( ) ; @Override protected C computeNext ( C previous ) { return equalsOrThrow ( previous , last ) ? null : domain.next ( previous ) ; } } ; } 
public UnmodifiableIterator < C > descendingIterator ( ) { return new AbstractSequentialIterator < C > ( last ( ) ) { final C first = first ( ) ; @Override protected C computeNext ( C previous ) { return equalsOrThrow ( previous , first ) ? null : domain.previous ( previous ) ; } } ; } 
static < K , V > ImmutableMap < K , V > fromEntryArray ( int n , Entry < K , V > [] entryArray ) { checkPositionIndex ( n , entryArray.length ) ; if ( n == 0 ) { return ( RegularImmutableMap < K , V > ) EMPTY ; } Entry < K , V > [] entries ; if ( n == entryArray.length ) { entries = entryArray ; } else { entries = createEntryArray ( n ) ; } int tableSize = Hashing.closedTableSize ( n , MAX_LOAD_FACTOR ) ; ImmutableMapEntry < K , V > [] table = createEntryArray ( tableSize ) ; int mask = tableSize - 1 ; for ( int entryIndex = 0 ; entryIndex < n ; entryIndex++ ) { Entry < K , V > entry = entryArray[entryIndex] ; K key = entry.getKey ( ) ; V value = entry.getValue ( ) ; checkEntryNotNull ( key , value ) ; int tableIndex = Hashing.smear ( key.hashCode ( ) ) & mask ; @Nullable ImmutableMapEntry < K , V > existing = table[tableIndex] ; ImmutableMapEntry < K , V > newEntry = ( existing == null ) ? makeImmutable ( entry , key , value ) : new NonTerminalImmutableMapEntry < K , V > ( key , value , existing ) ; table[tableIndex] = newEntry ; entries[entryIndex] = newEntry ; int bucketSize = checkNoConflictInKeyBucket ( key , newEntry , existing ) ; if ( bucketSize > MAX_HASH_BUCKET_LENGTH ) { return JdkBackedImmutableMap.create ( n , entryArray ) ; } } return new RegularImmutableMap < > ( entries , table , mask ) ; } 
static < V > V get ( @Nullable Object key , ImmutableMapEntry < ? , V > @Nullable [] keyTable , int mask ) { if ( key == null || keyTable == null ) { return null ; } int index = Hashing.smear ( key.hashCode ( ) ) & mask ; for ( ImmutableMapEntry < ? , V > entry = keyTable[index] ; entry != null ; entry = entry.getNextInKeyBucket ( ) ) { Object candidateKey = entry.getKey ( ) ; if ( key.equals ( candidateKey ) ) { return entry.getValue ( ) ; } } return null ; } 
static < E > ImmutableMultiset < E > create ( Collection < ? extends Entry < ? extends E > > entries ) { int distinct = entries.size ( ) ; @SuppressWarnings ( " unchecked " ) Multisets.ImmutableEntry < E > [] entryArray = new Multisets.ImmutableEntry[distinct] ; if ( distinct == 0 ) { return new RegularImmutableMultiset < > ( entryArray , null , 0 , 0 , ImmutableSet.of ( ) ) ; } int tableSize = Hashing.closedTableSize ( distinct , MAX_LOAD_FACTOR ) ; int mask = tableSize - 1 ; @SuppressWarnings ( " unchecked " ) Multisets.ImmutableEntry < E > [] hashTable = new Multisets.ImmutableEntry[tableSize] ; int index = 0 ; int hashCode = 0 ; long size = 0 ; for ( Entry < ? extends E > entry : entries ) { E element = checkNotNull ( entry.getElement ( ) ) ; int count = entry.getCount ( ) ; int hash = element.hashCode ( ) ; int bucket = Hashing.smear ( hash ) & mask ; Multisets.ImmutableEntry < E > bucketHead = hashTable[bucket] ; Multisets.ImmutableEntry < E > newEntry ; if ( bucketHead == null ) { boolean canReuseEntry = entry instanceof Multisets.ImmutableEntry && ! ( entry instanceof NonTerminalEntry ) ; newEntry = canReuseEntry ? ( Multisets.ImmutableEntry < E > ) entry : new Multisets.ImmutableEntry < E > ( element , count ) ; } else { newEntry = new NonTerminalEntry < E > ( element , count , bucketHead ) ; } hashCode += hash ^ count ; entryArray[index++] = newEntry ; hashTable[bucket] = newEntry ; size += count ; } return hashFloodingDetected ( hashTable ) ? JdkBackedImmutableMultiset.create ( ImmutableList.asImmutableList ( entryArray ) ) : new RegularImmutableMultiset < E > ( entryArray , hashTable , Ints.saturatedCast ( size ) , hashCode , null ) ; } 
public boolean containsAll ( Collection < ? > targets ) { if ( targets instanceof Multiset ) { targets = ( ( Multiset < ? > ) targets ) .elementSet ( ) ; } if ( !SortedIterables.hasSameComparator ( comparator ( ) , targets ) || ( targets.size ( ) < = 1 ) ) { return super.containsAll ( targets ) ; } Iterator < E > thisIterator = iterator ( ) ; Iterator < ? > thatIterator = targets.iterator ( ) ; if ( !thisIterator.hasNext ( ) ) { return false ; } Object target = thatIterator.next ( ) ; E current = thisIterator.next ( ) ; try { while ( true ) { int cmp = unsafeCompare ( current , target ) ; if ( cmp < 0 ) { if ( !thisIterator.hasNext ( ) ) { return false ; } current = thisIterator.next ( ) ; } else if ( cmp == 0 ) { if ( !thatIterator.hasNext ( ) ) { return true ; } target = thatIterator.next ( ) ; } else if ( cmp > 0 ) { return false ; } } } catch ( NullPointerException | ClassCastException e ) { return false ; } } 
public boolean equals ( @Nullable Object object ) { if ( object == this ) { return true ; } if ( ! ( object instanceof Set ) ) { return false ; } Set < ? > that = ( Set < ? > ) object ; if ( size ( ) != that.size ( ) ) { return false ; } else if ( isEmpty ( ) ) { return true ; } if ( SortedIterables.hasSameComparator ( comparator , that ) ) { Iterator < ? > otherIterator = that.iterator ( ) ; try { Iterator < E > iterator = iterator ( ) ; while ( iterator.hasNext ( ) ) { Object element = iterator.next ( ) ; Object otherElement = otherIterator.next ( ) ; if ( otherElement == null || unsafeCompare ( element , otherElement ) != 0 ) { return false ; } } return true ; } catch ( ClassCastException e ) { return false ; } catch ( NoSuchElementException e ) { return false ; } } return containsAll ( that ) ; } 
static < R , C , V > RegularImmutableTable < R , C , V > forCells ( List < Cell < R , C , V > > cells , @Nullable final Comparator < ? super R > rowComparator , @Nullable final Comparator < ? super C > columnComparator ) { checkNotNull ( cells ) ; if ( rowComparator != null || columnComparator != null ) { Comparator < Cell < R , C , V > > comparator = new Comparator < Cell < R , C , V > > ( ) { @Override public int compare ( Cell < R , C , V > cell1 , Cell < R , C , V > cell2 ) { int rowCompare = ( rowComparator == null ) ? 0 : rowComparator.compare ( cell1.getRowKey ( ) , cell2.getRowKey ( ) ) ; if ( rowCompare != 0 ) { return rowCompare ; } return ( columnComparator == null ) ? 0 : columnComparator.compare ( cell1.getColumnKey ( ) , cell2.getColumnKey ( ) ) ; } } ; Collections.sort ( cells , comparator ) ; } return forCellsInternal ( cells , rowComparator , columnComparator ) ; } 
private static < R , C , V > RegularImmutableTable < R , C , V > forCellsInternal ( Iterable < Cell < R , C , V > > cells , @Nullable Comparator < ? super R > rowComparator , @Nullable Comparator < ? super C > columnComparator ) { Set < R > rowSpaceBuilder = new LinkedHashSet < > ( ) ; Set < C > columnSpaceBuilder = new LinkedHashSet < > ( ) ; ImmutableList < Cell < R , C , V > > cellList = ImmutableList.copyOf ( cells ) ; for ( Cell < R , C , V > cell : cells ) { rowSpaceBuilder.add ( cell.getRowKey ( ) ) ; columnSpaceBuilder.add ( cell.getColumnKey ( ) ) ; } ImmutableSet < R > rowSpace = ( rowComparator == null ) ? ImmutableSet.copyOf ( rowSpaceBuilder ) : ImmutableSet.copyOf ( ImmutableList.sortedCopyOf ( rowComparator , rowSpaceBuilder ) ) ; ImmutableSet < C > columnSpace = ( columnComparator == null ) ? ImmutableSet.copyOf ( columnSpaceBuilder ) : ImmutableSet.copyOf ( ImmutableList.sortedCopyOf ( columnComparator , columnSpaceBuilder ) ) ; return forOrderedComponents ( cellList , rowSpace , columnSpace ) ; } 
static < R , C , V > RegularImmutableTable < R , C , V > forOrderedComponents ( ImmutableList < Cell < R , C , V > > cellList , ImmutableSet < R > rowSpace , ImmutableSet < C > columnSpace ) { return ( cellList.size ( ) > ( ( ( long ) rowSpace.size ( ) * columnSpace.size ( ) ) / 2 ) ) ? new DenseImmutableTable < R , C , V > ( cellList , rowSpace , columnSpace ) : new SparseImmutableTable < R , C , V > ( cellList , rowSpace , columnSpace ) ; } 
public < E extends T > E min ( E a , E b , E c , E... rest ) { return forwardOrder.max ( a , b , c , rest ) ; } 
public < E extends T > E max ( E a , E b , E c , E... rest ) { return forwardOrder.min ( a , b , c , rest ) ; } 
public static < E extends Enum < E > > ImmutableSet < E > immutableEnumSet ( Iterable < E > elements ) { if ( elements instanceof ImmutableEnumSet ) { return ( ImmutableEnumSet < E > ) elements ; } else if ( elements instanceof Collection ) { Collection < E > collection = ( Collection < E > ) elements ; if ( collection.isEmpty ( ) ) { return ImmutableSet.of ( ) ; } else { return ImmutableEnumSet.asImmutable ( EnumSet.copyOf ( collection ) ) ; } } else { Iterator < E > itr = elements.iterator ( ) ; if ( itr.hasNext ( ) ) { EnumSet < E > enumSet = EnumSet.of ( itr.next ( ) ) ; Iterators.addAll ( enumSet , itr ) ; return ImmutableEnumSet.asImmutable ( enumSet ) ; } else { return ImmutableSet.of ( ) ; } } } 
public static < E > SetView < E > union ( final Set < ? extends E > set1 , final Set < ? extends E > set2 ) { checkNotNull ( set1 , " set1 " ) ; checkNotNull ( set2 , " set2 " ) ; return new SetView < E > ( ) { @Override public int size ( ) { int size = set1.size ( ) ; for ( E e : set2 ) { if ( !set1.contains ( e ) ) { size++ ; } } return size ; } @Override public boolean isEmpty ( ) { return set1.isEmpty ( ) && set2.isEmpty ( ) ; } @Override public UnmodifiableIterator < E > iterator ( ) { return new AbstractIterator < E > ( ) { final Iterator < ? extends E > itr1 = set1.iterator ( ) ; final Iterator < ? extends E > itr2 = set2.iterator ( ) ; @Override protected E computeNext ( ) { if ( itr1.hasNext ( ) ) { return itr1.next ( ) ; } while ( itr2.hasNext ( ) ) { E e = itr2.next ( ) ; if ( !set1.contains ( e ) ) { return e ; } } return endOfData ( ) ; } } ; } @Override public Stream < E > stream ( ) { return Stream.concat ( set1.stream ( ) , set2.stream ( ) .filter ( e - > !set1.contains ( e ) ) ) ; } @Override public Stream < E > parallelStream ( ) { return stream ( ) .parallel ( ) ; } @Override public boolean contains ( Object object ) { return set1.contains ( object ) || set2.contains ( object ) ; } @Override public < S extends Set < E > > S copyInto ( S set ) { set.addAll ( set1 ) ; set.addAll ( set2 ) ; return set ; } @Override public ImmutableSet < E > immutableCopy ( ) { return new ImmutableSet.Builder < E > ( ) .addAll ( set1 ) .addAll ( set2 ) .build ( ) ; } } ; } 
public static < E > SetView < E > symmetricDifference ( final Set < ? extends E > set1 , final Set < ? extends E > set2 ) { checkNotNull ( set1 , " set1 " ) ; checkNotNull ( set2 , " set2 " ) ; return new SetView < E > ( ) { @Override public UnmodifiableIterator < E > iterator ( ) { final Iterator < ? extends E > itr1 = set1.iterator ( ) ; final Iterator < ? extends E > itr2 = set2.iterator ( ) ; return new AbstractIterator < E > ( ) { @Override public E computeNext ( ) { while ( itr1.hasNext ( ) ) { E elem1 = itr1.next ( ) ; if ( !set2.contains ( elem1 ) ) { return elem1 ; } } while ( itr2.hasNext ( ) ) { E elem2 = itr2.next ( ) ; if ( !set1.contains ( elem2 ) ) { return elem2 ; } } return endOfData ( ) ; } } ; } @Override public int size ( ) { int size = 0 ; for ( E e : set1 ) { if ( !set2.contains ( e ) ) { size++ ; } } for ( E e : set2 ) { if ( !set1.contains ( e ) ) { size++ ; } } return size ; } @Override public boolean isEmpty ( ) { return set1.equals ( set2 ) ; } @Override public boolean contains ( Object element ) { return set1.contains ( element ) ^ set2.contains ( element ) ; } } ; } 
public UnmodifiableIterator < E > iterator ( ) { final Iterator < ? extends E > itr1 = set1.iterator ( ) ; final Iterator < ? extends E > itr2 = set2.iterator ( ) ; return new AbstractIterator < E > ( ) { @Override public E computeNext ( ) { while ( itr1.hasNext ( ) ) { E elem1 = itr1.next ( ) ; if ( !set2.contains ( elem1 ) ) { return elem1 ; } } while ( itr2.hasNext ( ) ) { E elem2 = itr2.next ( ) ; if ( !set1.contains ( elem2 ) ) { return elem2 ; } } return endOfData ( ) ; } } ; } 
static < E > Set < List < E > > create ( List < ? extends Set < ? extends E > > sets ) { ImmutableList.Builder < ImmutableSet < E > > axesBuilder = new ImmutableList.Builder < > ( sets.size ( ) ) ; for ( Set < ? extends E > set : sets ) { ImmutableSet < E > copy = ImmutableSet.copyOf ( set ) ; if ( copy.isEmpty ( ) ) { return ImmutableSet.of ( ) ; } axesBuilder.add ( copy ) ; } final ImmutableList < ImmutableSet < E > > axes = axesBuilder.build ( ) ; ImmutableList < List < E > > listAxes = new ImmutableList < List < E > > ( ) { @Override public int size ( ) { return axes.size ( ) ; } @Override public List < E > get ( int index ) { return axes.get ( index ) .asList ( ) ; } @Override boolean isPartialView ( ) { return true ; } } ; return new CartesianSet < E > ( axes , new CartesianList < E > ( listAxes ) ) ; } 
public Iterator < E > iterator ( ) { return new UnmodifiableIterator < E > ( ) { final ImmutableList < E > elements = inputSet.keySet ( ) .asList ( ) ; int remainingSetBits = mask ; @Override public boolean hasNext ( ) { return remainingSetBits != 0 ; } @Override public E next ( ) { int index = Integer.numberOfTrailingZeros ( remainingSetBits ) ; if ( index == 32 ) { throw new NoSuchElementException ( ) ; } remainingSetBits &= ~ ( 1 < < index ) ; return elements.get ( index ) ; } } ; } 
public static < E > Set < Set < E > > combinations ( Set < E > set , final int size ) { final ImmutableMap < E , Integer > index = Maps.indexMap ( set ) ; checkNonnegative ( size , " size " ) ; checkArgument ( size < = index.size ( ) , " size ( %s ) must be < = set.size ( ) ( %s ) " , size , index.size ( ) ) ; if ( size == 0 ) { return ImmutableSet. < Set < E > > of ( ImmutableSet. < E > of ( ) ) ; } else if ( size == index.size ( ) ) { return ImmutableSet. < Set < E > > of ( index.keySet ( ) ) ; } return new AbstractSet < Set < E > > ( ) { @Override public boolean contains ( @Nullable Object o ) { if ( o instanceof Set ) { Set < ? > s = ( Set < ? > ) o ; return s.size ( ) == size && index.keySet ( ) .containsAll ( s ) ; } return false ; } @Override public Iterator < Set < E > > iterator ( ) { return new AbstractIterator < Set < E > > ( ) { final BitSet bits = new BitSet ( index.size ( ) ) ; @Override protected Set < E > computeNext ( ) { if ( bits.isEmpty ( ) ) { bits.set ( 0 , size ) ; } else { int firstSetBit = bits.nextSetBit ( 0 ) ; int bitToFlip = bits.nextClearBit ( firstSetBit ) ; if ( bitToFlip == index.size ( ) ) { return endOfData ( ) ; } bits.set ( 0 , bitToFlip - firstSetBit - 1 ) ; bits.clear ( bitToFlip - firstSetBit - 1 , bitToFlip ) ; bits.set ( bitToFlip ) ; } final BitSet copy = ( BitSet ) bits.clone ( ) ; return new AbstractSet < E > ( ) { @Override public boolean contains ( @Nullable Object o ) { Integer i = index.get ( o ) ; return i != null && copy.get ( i ) ; } @Override public Iterator < E > iterator ( ) { return new AbstractIterator < E > ( ) { int i = -1 ; @Override protected E computeNext ( ) { i = copy.nextSetBit ( i + 1 ) ; if ( i == -1 ) { return endOfData ( ) ; } return index.keySet ( ) .asList ( ) .get ( i ) ; } } ; } @Override public int size ( ) { return size ; } } ; } } ; } @Override public int size ( ) { return IntMath.binomial ( index.size ( ) , size ) ; } @Override public String toString ( ) { return " Sets.combinations ( " + index.keySet ( ) + " , " + size + " ) " ; } } ; } 
public Iterator < Set < E > > iterator ( ) { return new AbstractIterator < Set < E > > ( ) { final BitSet bits = new BitSet ( index.size ( ) ) ; @Override protected Set < E > computeNext ( ) { if ( bits.isEmpty ( ) ) { bits.set ( 0 , size ) ; } else { int firstSetBit = bits.nextSetBit ( 0 ) ; int bitToFlip = bits.nextClearBit ( firstSetBit ) ; if ( bitToFlip == index.size ( ) ) { return endOfData ( ) ; } bits.set ( 0 , bitToFlip - firstSetBit - 1 ) ; bits.clear ( bitToFlip - firstSetBit - 1 , bitToFlip ) ; bits.set ( bitToFlip ) ; } final BitSet copy = ( BitSet ) bits.clone ( ) ; return new AbstractSet < E > ( ) { @Override public boolean contains ( @Nullable Object o ) { Integer i = index.get ( o ) ; return i != null && copy.get ( i ) ; } @Override public Iterator < E > iterator ( ) { return new AbstractIterator < E > ( ) { int i = -1 ; @Override protected E computeNext ( ) { i = copy.nextSetBit ( i + 1 ) ; if ( i == -1 ) { return endOfData ( ) ; } return index.keySet ( ) .asList ( ) .get ( i ) ; } } ; } @Override public int size ( ) { return size ; } } ; } } ; } 
protected Set < E > computeNext ( ) { if ( bits.isEmpty ( ) ) { bits.set ( 0 , size ) ; } else { int firstSetBit = bits.nextSetBit ( 0 ) ; int bitToFlip = bits.nextClearBit ( firstSetBit ) ; if ( bitToFlip == index.size ( ) ) { return endOfData ( ) ; } bits.set ( 0 , bitToFlip - firstSetBit - 1 ) ; bits.clear ( bitToFlip - firstSetBit - 1 , bitToFlip ) ; bits.set ( bitToFlip ) ; } final BitSet copy = ( BitSet ) bits.clone ( ) ; return new AbstractSet < E > ( ) { @Override public boolean contains ( @Nullable Object o ) { Integer i = index.get ( o ) ; return i != null && copy.get ( i ) ; } @Override public Iterator < E > iterator ( ) { return new AbstractIterator < E > ( ) { int i = -1 ; @Override protected E computeNext ( ) { i = copy.nextSetBit ( i + 1 ) ; if ( i == -1 ) { return endOfData ( ) ; } return index.keySet ( ) .asList ( ) .get ( i ) ; } } ; } @Override public int size ( ) { return size ; } } ; } 
public static < K extends Comparable < ? super K > > NavigableSet < K > subSet ( NavigableSet < K > set , Range < K > range ) { if ( set.comparator ( ) != null && set.comparator ( ) != Ordering.natural ( ) && range.hasLowerBound ( ) && range.hasUpperBound ( ) ) { checkArgument ( set.comparator ( ) .compare ( range.lowerEndpoint ( ) , range.upperEndpoint ( ) ) < = 0 , " set is using a custom comparator which is inconsistent with the natural ordering. " ) ; } if ( range.hasLowerBound ( ) && range.hasUpperBound ( ) ) { return set.subSet ( range.lowerEndpoint ( ) , range.lowerBoundType ( ) == BoundType.CLOSED , range.upperEndpoint ( ) , range.upperBoundType ( ) == BoundType.CLOSED ) ; } else if ( range.hasLowerBound ( ) ) { return set.tailSet ( range.lowerEndpoint ( ) , range.lowerBoundType ( ) == BoundType.CLOSED ) ; } else if ( range.hasUpperBound ( ) ) { return set.headSet ( range.upperEndpoint ( ) , range.upperBoundType ( ) == BoundType.CLOSED ) ; } return checkNotNull ( set ) ; } 
 < E > int resultIndex ( Comparator < ? super E > comparator , E key , List < ? extends E > list , int foundIndex ) { int lower = foundIndex ; int upper = list.size ( ) - 1 ; while ( lower < upper ) { int middle = ( lower + upper + 1 ) > > > 1 ; int c = comparator.compare ( list.get ( middle ) , key ) ; if ( c > 0 ) { upper = middle - 1 ; } else { lower = middle ; } } return lower ; } 
 < E > int resultIndex ( Comparator < ? super E > comparator , E key , List < ? extends E > list , int foundIndex ) { int lower = 0 ; int upper = foundIndex ; while ( lower < upper ) { int middle = ( lower + upper ) > > > 1 ; int c = comparator.compare ( list.get ( middle ) , key ) ; if ( c < 0 ) { lower = middle + 1 ; } else { upper = middle ; } } return lower ; } 
public static < E > int binarySearch ( List < ? extends E > list , @Nullable E key , Comparator < ? super E > comparator , KeyPresentBehavior presentBehavior , KeyAbsentBehavior absentBehavior ) { checkNotNull ( comparator ) ; checkNotNull ( list ) ; checkNotNull ( presentBehavior ) ; checkNotNull ( absentBehavior ) ; if ( ! ( list instanceof RandomAccess ) ) { list = Lists.newArrayList ( list ) ; } int lower = 0 ; int upper = list.size ( ) - 1 ; while ( lower < = upper ) { int middle = ( lower + upper ) > > > 1 ; int c = comparator.compare ( key , list.get ( middle ) ) ; if ( c < 0 ) { upper = middle - 1 ; } else if ( c > 0 ) { lower = middle + 1 ; } else { return lower + presentBehavior.resultIndex ( comparator , key , list.subList ( lower , upper + 1 ) , middle - lower ) ; } } return absentBehavior.resultIndex ( lower ) ; } 
private static < E > E getElementOrNull ( @Nullable Entry < E > entry ) { return ( entry == null ) ? null : entry.getElement ( ) ; } 
private Map < R , V > removeColumn ( Object column ) { Map < R , V > output = new LinkedHashMap < > ( ) ; Iterator < Entry < R , Map < C , V > > > iterator = backingMap.entrySet ( ) .iterator ( ) ; while ( iterator.hasNext ( ) ) { Entry < R , Map < C , V > > entry = iterator.next ( ) ; V value = entry.getValue ( ) .remove ( column ) ; if ( value != null ) { output.put ( entry.getKey ( ) , value ) ; if ( entry.getValue ( ) .isEmpty ( ) ) { iterator.remove ( ) ; } } } return output ; } 
protected Entry < R , V > computeNext ( ) { while ( iterator.hasNext ( ) ) { final Entry < R , Map < C , V > > entry = iterator.next ( ) ; if ( entry.getValue ( ) .containsKey ( columnKey ) ) { @WeakOuter class EntryImpl extends AbstractMapEntry < R , V > { @Override public R getKey ( ) { return entry.getKey ( ) ; } @Override public V getValue ( ) { return entry.getValue ( ) .get ( columnKey ) ; } @Override public V setValue ( V value ) { return entry.getValue ( ) .put ( columnKey , checkNotNull ( value ) ) ; } } return new EntryImpl ( ) ; } } return endOfData ( ) ; } 
protected C computeNext ( ) { while ( true ) { if ( entryIterator.hasNext ( ) ) { Entry < C , V > entry = entryIterator.next ( ) ; if ( !seen.containsKey ( entry.getKey ( ) ) ) { seen.put ( entry.getKey ( ) , entry.getValue ( ) ) ; return entry.getKey ( ) ; } } else if ( mapIterator.hasNext ( ) ) { entryIterator = mapIterator.next ( ) .entrySet ( ) .iterator ( ) ; } else { return endOfData ( ) ; } } } 
public static < T > Stream < T > concat ( Stream < ? extends T > ... streams ) { boolean isParallel = false ; int characteristics = Spliterator.ORDERED | Spliterator.SIZED | Spliterator.NONNULL ; long estimatedSize = 0L ; ImmutableList.Builder < Spliterator < ? extends T > > splitrsBuilder = new ImmutableList.Builder < > ( streams.length ) ; for ( Stream < ? extends T > stream : streams ) { isParallel |= stream.isParallel ( ) ; Spliterator < ? extends T > splitr = stream.spliterator ( ) ; splitrsBuilder.add ( splitr ) ; characteristics &= splitr.characteristics ( ) ; estimatedSize = LongMath.saturatedAdd ( estimatedSize , splitr.estimateSize ( ) ) ; } return StreamSupport.stream ( CollectSpliterators.flatMap ( splitrsBuilder.build ( ) .spliterator ( ) , splitr - > ( Spliterator < T > ) splitr , characteristics , estimatedSize ) , isParallel ) .onClose ( ( ) - > closeAll ( streams ) ) ; } 
public static IntStream concat ( IntStream... streams ) { boolean isParallel = false ; int characteristics = Spliterator.ORDERED | Spliterator.SIZED | Spliterator.NONNULL ; long estimatedSize = 0L ; ImmutableList.Builder < Spliterator.OfInt > splitrsBuilder = new ImmutableList.Builder < > ( streams.length ) ; for ( IntStream stream : streams ) { isParallel |= stream.isParallel ( ) ; Spliterator.OfInt splitr = stream.spliterator ( ) ; splitrsBuilder.add ( splitr ) ; characteristics &= splitr.characteristics ( ) ; estimatedSize = LongMath.saturatedAdd ( estimatedSize , splitr.estimateSize ( ) ) ; } return StreamSupport.intStream ( CollectSpliterators.flatMapToInt ( splitrsBuilder.build ( ) .spliterator ( ) , splitr - > splitr , characteristics , estimatedSize ) , isParallel ) .onClose ( ( ) - > closeAll ( streams ) ) ; } 
public static LongStream concat ( LongStream... streams ) { boolean isParallel = false ; int characteristics = Spliterator.ORDERED | Spliterator.SIZED | Spliterator.NONNULL ; long estimatedSize = 0L ; ImmutableList.Builder < Spliterator.OfLong > splitrsBuilder = new ImmutableList.Builder < > ( streams.length ) ; for ( LongStream stream : streams ) { isParallel |= stream.isParallel ( ) ; Spliterator.OfLong splitr = stream.spliterator ( ) ; splitrsBuilder.add ( splitr ) ; characteristics &= splitr.characteristics ( ) ; estimatedSize = LongMath.saturatedAdd ( estimatedSize , splitr.estimateSize ( ) ) ; } return StreamSupport.longStream ( CollectSpliterators.flatMapToLong ( splitrsBuilder.build ( ) .spliterator ( ) , splitr - > splitr , characteristics , estimatedSize ) , isParallel ) .onClose ( ( ) - > closeAll ( streams ) ) ; } 
public static DoubleStream concat ( DoubleStream... streams ) { boolean isParallel = false ; int characteristics = Spliterator.ORDERED | Spliterator.SIZED | Spliterator.NONNULL ; long estimatedSize = 0L ; ImmutableList.Builder < Spliterator.OfDouble > splitrsBuilder = new ImmutableList.Builder < > ( streams.length ) ; for ( DoubleStream stream : streams ) { isParallel |= stream.isParallel ( ) ; Spliterator.OfDouble splitr = stream.spliterator ( ) ; splitrsBuilder.add ( splitr ) ; characteristics &= splitr.characteristics ( ) ; estimatedSize = LongMath.saturatedAdd ( estimatedSize , splitr.estimateSize ( ) ) ; } return StreamSupport.doubleStream ( CollectSpliterators.flatMapToDouble ( splitrsBuilder.build ( ) .spliterator ( ) , splitr - > splitr , characteristics , estimatedSize ) , isParallel ) .onClose ( ( ) - > closeAll ( streams ) ) ; } 
public static < A , B , R > Stream < R > zip ( Stream < A > streamA , Stream < B > streamB , BiFunction < ? super A , ? super B , R > function ) { checkNotNull ( streamA ) ; checkNotNull ( streamB ) ; checkNotNull ( function ) ; boolean isParallel = streamA.isParallel ( ) || streamB.isParallel ( ) ; Spliterator < A > splitrA = streamA.spliterator ( ) ; Spliterator < B > splitrB = streamB.spliterator ( ) ; int characteristics = splitrA.characteristics ( ) & splitrB.characteristics ( ) & ( Spliterator.SIZED | Spliterator.ORDERED ) ; Iterator < A > itrA = Spliterators.iterator ( splitrA ) ; Iterator < B > itrB = Spliterators.iterator ( splitrB ) ; return StreamSupport.stream ( new AbstractSpliterator < R > ( Math.min ( splitrA.estimateSize ( ) , splitrB.estimateSize ( ) ) , characteristics ) { @Override public boolean tryAdvance ( Consumer < ? super R > action ) { if ( itrA.hasNext ( ) && itrB.hasNext ( ) ) { action.accept ( function.apply ( itrA.next ( ) , itrB.next ( ) ) ) ; return true ; } return false ; } } , isParallel ) .onClose ( streamA::close ) .onClose ( streamB::close ) ; } 
public static < A , B > void forEachPair ( Stream < A > streamA , Stream < B > streamB , BiConsumer < ? super A , ? super B > consumer ) { checkNotNull ( consumer ) ; if ( streamA.isParallel ( ) || streamB.isParallel ( ) ) { zip ( streamA , streamB , TemporaryPair::new ) .forEach ( pair - > consumer.accept ( pair.a , pair.b ) ) ; } else { Iterator < A > iterA = streamA.iterator ( ) ; Iterator < B > iterB = streamB.iterator ( ) ; while ( iterA.hasNext ( ) && iterB.hasNext ( ) ) { consumer.accept ( iterA.next ( ) , iterB.next ( ) ) ; } } } 
public static < T , R > Stream < R > mapWithIndex ( Stream < T > stream , FunctionWithIndex < ? super T , ? extends R > function ) { checkNotNull ( stream ) ; checkNotNull ( function ) ; boolean isParallel = stream.isParallel ( ) ; Spliterator < T > fromSpliterator = stream.spliterator ( ) ; if ( !fromSpliterator.hasCharacteristics ( Spliterator.SUBSIZED ) ) { Iterator < T > fromIterator = Spliterators.iterator ( fromSpliterator ) ; return StreamSupport.stream ( new AbstractSpliterator < R > ( fromSpliterator.estimateSize ( ) , fromSpliterator.characteristics ( ) & ( Spliterator.ORDERED | Spliterator.SIZED ) ) { long index = 0 ; @Override public boolean tryAdvance ( Consumer < ? super R > action ) { if ( fromIterator.hasNext ( ) ) { action.accept ( function.apply ( fromIterator.next ( ) , index++ ) ) ; return true ; } return false ; } } , isParallel ) .onClose ( stream::close ) ; } class Splitr extends MapWithIndexSpliterator < Spliterator < T > , R , Splitr > implements Consumer < T > { @Nullable T holder ; Splitr ( Spliterator < T > splitr , long index ) { super ( splitr , index ) ; } @Override public void accept ( @Nullable T t ) { this.holder = t ; } @Override public boolean tryAdvance ( Consumer < ? super R > action ) { if ( fromSpliterator.tryAdvance ( this ) ) { try { action.accept ( function.apply ( holder , index++ ) ) ; return true ; } finally { holder = null ; } } return false ; } @Override Splitr createSplit ( Spliterator < T > from , long i ) { return new Splitr ( from , i ) ; } } return StreamSupport.stream ( new Splitr ( fromSpliterator , 0 ) , isParallel ) .onClose ( stream::close ) ; } 
public static < R > Stream < R > mapWithIndex ( LongStream stream , LongFunctionWithIndex < R > function ) { checkNotNull ( stream ) ; checkNotNull ( function ) ; boolean isParallel = stream.isParallel ( ) ; Spliterator.OfLong fromSpliterator = stream.spliterator ( ) ; if ( !fromSpliterator.hasCharacteristics ( Spliterator.SUBSIZED ) ) { PrimitiveIterator.OfLong fromIterator = Spliterators.iterator ( fromSpliterator ) ; return StreamSupport.stream ( new AbstractSpliterator < R > ( fromSpliterator.estimateSize ( ) , fromSpliterator.characteristics ( ) & ( Spliterator.ORDERED | Spliterator.SIZED ) ) { long index = 0 ; @Override public boolean tryAdvance ( Consumer < ? super R > action ) { if ( fromIterator.hasNext ( ) ) { action.accept ( function.apply ( fromIterator.nextLong ( ) , index++ ) ) ; return true ; } return false ; } } , isParallel ) .onClose ( stream::close ) ; } class Splitr extends MapWithIndexSpliterator < Spliterator.OfLong , R , Splitr > implements LongConsumer , Spliterator < R > { long holder ; Splitr ( Spliterator.OfLong splitr , long index ) { super ( splitr , index ) ; } @Override public void accept ( long t ) { this.holder = t ; } @Override public boolean tryAdvance ( Consumer < ? super R > action ) { if ( fromSpliterator.tryAdvance ( this ) ) { action.accept ( function.apply ( holder , index++ ) ) ; return true ; } return false ; } @Override Splitr createSplit ( Spliterator.OfLong from , long i ) { return new Splitr ( from , i ) ; } } return StreamSupport.stream ( new Splitr ( fromSpliterator , 0 ) , isParallel ) .onClose ( stream::close ) ; } 
public static < R > Stream < R > mapWithIndex ( DoubleStream stream , DoubleFunctionWithIndex < R > function ) { checkNotNull ( stream ) ; checkNotNull ( function ) ; boolean isParallel = stream.isParallel ( ) ; Spliterator.OfDouble fromSpliterator = stream.spliterator ( ) ; if ( !fromSpliterator.hasCharacteristics ( Spliterator.SUBSIZED ) ) { PrimitiveIterator.OfDouble fromIterator = Spliterators.iterator ( fromSpliterator ) ; return StreamSupport.stream ( new AbstractSpliterator < R > ( fromSpliterator.estimateSize ( ) , fromSpliterator.characteristics ( ) & ( Spliterator.ORDERED | Spliterator.SIZED ) ) { long index = 0 ; @Override public boolean tryAdvance ( Consumer < ? super R > action ) { if ( fromIterator.hasNext ( ) ) { action.accept ( function.apply ( fromIterator.nextDouble ( ) , index++ ) ) ; return true ; } return false ; } } , isParallel ) .onClose ( stream::close ) ; } class Splitr extends MapWithIndexSpliterator < Spliterator.OfDouble , R , Splitr > implements DoubleConsumer , Spliterator < R > { double holder ; Splitr ( Spliterator.OfDouble splitr , long index ) { super ( splitr , index ) ; } @Override public void accept ( double t ) { this.holder = t ; } @Override public boolean tryAdvance ( Consumer < ? super R > action ) { if ( fromSpliterator.tryAdvance ( this ) ) { action.accept ( function.apply ( holder , index++ ) ) ; return true ; } return false ; } @Override Splitr createSplit ( Spliterator.OfDouble from , long i ) { return new Splitr ( from , i ) ; } } return StreamSupport.stream ( new Splitr ( fromSpliterator , 0 ) , isParallel ) .onClose ( stream::close ) ; } 
public static < T > java.util.Optional < T > findLast ( Stream < T > stream ) { class OptionalState { boolean set = false ; T value = null ; void set ( @Nullable T value ) { this.set = true ; this.value = value ; } T get ( ) { checkState ( set ) ; return value ; } } OptionalState state = new OptionalState ( ) ; Deque < Spliterator < T > > splits = new ArrayDeque < > ( ) ; splits.addLast ( stream.spliterator ( ) ) ; while ( !splits.isEmpty ( ) ) { Spliterator < T > spliterator = splits.removeLast ( ) ; if ( spliterator.getExactSizeIfKnown ( ) == 0 ) { continue ; } if ( spliterator.hasCharacteristics ( Spliterator.SUBSIZED ) ) { while ( true ) { Spliterator < T > prefix = spliterator.trySplit ( ) ; if ( prefix == null || prefix.getExactSizeIfKnown ( ) == 0 ) { break ; } else if ( spliterator.getExactSizeIfKnown ( ) == 0 ) { spliterator = prefix ; break ; } } spliterator.forEachRemaining ( state::set ) ; return java.util.Optional.of ( state.get ( ) ) ; } Spliterator < T > prefix = spliterator.trySplit ( ) ; if ( prefix == null || prefix.getExactSizeIfKnown ( ) == 0 ) { spliterator.forEachRemaining ( state::set ) ; if ( state.set ) { return java.util.Optional.of ( state.get ( ) ) ; } continue ; } splits.addLast ( prefix ) ; splits.addLast ( spliterator ) ; } return java.util.Optional.empty ( ) ; } 
private static < E > Collection < E > typePreservingCollection ( Collection < E > collection , @Nullable Object mutex ) { if ( collection instanceof SortedSet ) { return sortedSet ( ( SortedSet < E > ) collection , mutex ) ; } if ( collection instanceof Set ) { return set ( ( Set < E > ) collection , mutex ) ; } if ( collection instanceof List ) { return list ( ( List < E > ) collection , mutex ) ; } return collection ( collection , mutex ) ; } 
public Iterator < Entry < K , Collection < V > > > iterator ( ) { return new TransformedIterator < Entry < K , Collection < V > > , Entry < K , Collection < V > > > ( super.iterator ( ) ) { @Override Entry < K , Collection < V > > transform ( final Entry < K , Collection < V > > entry ) { return new ForwardingMapEntry < K , Collection < V > > ( ) { @Override protected Entry < K , Collection < V > > delegate ( ) { return entry ; } @Override public Collection < V > getValue ( ) { return typePreservingCollection ( entry.getValue ( ) , mutex ) ; } } ; } } ; } 
Entry < K , Collection < V > > transform ( final Entry < K , Collection < V > > entry ) { return new ForwardingMapEntry < K , Collection < V > > ( ) { @Override protected Entry < K , Collection < V > > delegate ( ) { return entry ; } @Override public Collection < V > getValue ( ) { return typePreservingCollection ( entry.getValue ( ) , mutex ) ; } } ; } 
private static JavaBeanDescriptor createDescriptorForSerialize ( Class < ? > cl ) { if ( cl.isEnum ( ) ) { return new JavaBeanDescriptor ( cl.getName ( ) , JavaBeanDescriptor.TYPE_ENUM ) ; } else if ( cl.isArray ( ) ) { return new JavaBeanDescriptor ( cl.getComponentType ( ) .getName ( ) , JavaBeanDescriptor.TYPE_ARRAY ) ; } else if ( ReflectUtils.isPrimitive ( cl ) ) { return new JavaBeanDescriptor ( cl.getName ( ) , JavaBeanDescriptor.TYPE_PRIMITIVE ) ; } else if ( Class.class.equals ( cl ) ) { return new JavaBeanDescriptor ( Class.class.getName ( ) , JavaBeanDescriptor.TYPE_CLASS ) ; } else if ( Collection.class.isAssignableFrom ( cl ) ) { return new JavaBeanDescriptor ( cl.getName ( ) , JavaBeanDescriptor.TYPE_COLLECTION ) ; } else if ( Map.class.isAssignableFrom ( cl ) ) { return new JavaBeanDescriptor ( cl.getName ( ) , JavaBeanDescriptor.TYPE_MAP ) ; } else { return new JavaBeanDescriptor ( cl.getName ( ) , JavaBeanDescriptor.TYPE_BEAN ) ; } } 
private static JavaBeanDescriptor createDescriptorIfAbsent ( Object obj , JavaBeanAccessor accessor , IdentityHashMap < Object , JavaBeanDescriptor > cache ) { if ( cache.containsKey ( obj ) ) { return cache.get ( obj ) ; } else if ( obj instanceof JavaBeanDescriptor ) { return ( JavaBeanDescriptor ) obj ; } else { JavaBeanDescriptor result = createDescriptorForSerialize ( obj.getClass ( ) ) ; cache.put ( obj , result ) ; serializeInternal ( result , obj , accessor , cache ) ; return result ; } } 
private static void serializeInternal ( JavaBeanDescriptor descriptor , Object obj , JavaBeanAccessor accessor , IdentityHashMap < Object , JavaBeanDescriptor > cache ) { if ( obj == null || descriptor == null ) { return ; } if ( obj.getClass ( ) .isEnum ( ) ) { descriptor.setEnumNameProperty ( ( ( Enum < ? > ) obj ) .name ( ) ) ; } else if ( ReflectUtils.isPrimitive ( obj.getClass ( ) ) ) { descriptor.setPrimitiveProperty ( obj ) ; } else if ( Class.class.equals ( obj.getClass ( ) ) ) { descriptor.setClassNameProperty ( ( ( Class < ? > ) obj ) .getName ( ) ) ; } else if ( obj.getClass ( ) .isArray ( ) ) { int len = Array.getLength ( obj ) ; for ( int i = 0 ; i < len ; i++ ) { Object item = Array.get ( obj , i ) ; if ( item == null ) { descriptor.setProperty ( i , null ) ; } else { JavaBeanDescriptor itemDescriptor = createDescriptorIfAbsent ( item , accessor , cache ) ; descriptor.setProperty ( i , itemDescriptor ) ; } } } else if ( obj instanceof Collection ) { Collection collection = ( Collection ) obj ; int index = 0 ; for ( Object item : collection ) { if ( item == null ) { descriptor.setProperty ( index++ , null ) ; } else { JavaBeanDescriptor itemDescriptor = createDescriptorIfAbsent ( item , accessor , cache ) ; descriptor.setProperty ( index++ , itemDescriptor ) ; } } } else if ( obj instanceof Map ) { Map map = ( Map ) obj ; map.forEach ( ( key , value ) - > { Object keyDescriptor = key == null ? null : createDescriptorIfAbsent ( key , accessor , cache ) ; Object valueDescriptor = value == null ? null : createDescriptorIfAbsent ( value , accessor , cache ) ; descriptor.setProperty ( keyDescriptor , valueDescriptor ) ; } ) ; } else { if ( JavaBeanAccessor.isAccessByMethod ( accessor ) ) { Map < String , Method > methods = ReflectUtils.getBeanPropertyReadMethods ( obj.getClass ( ) ) ; for ( Map.Entry < String , Method > entry : methods.entrySet ( ) ) { try { Object value = entry.getValue ( ) .invoke ( obj ) ; if ( value == null ) { continue ; } JavaBeanDescriptor valueDescriptor = createDescriptorIfAbsent ( value , accessor , cache ) ; descriptor.setProperty ( entry.getKey ( ) , valueDescriptor ) ; } catch ( Exception e ) { throw new RuntimeException ( e.getMessage ( ) , e ) ; } } } if ( JavaBeanAccessor.isAccessByField ( accessor ) ) { Map < String , Field > fields = ReflectUtils.getBeanPropertyFields ( obj.getClass ( ) ) ; for ( Map.Entry < String , Field > entry : fields.entrySet ( ) ) { if ( !descriptor.containsProperty ( entry.getKey ( ) ) ) { try { Object value = entry.getValue ( ) .get ( obj ) ; if ( value == null ) { continue ; } JavaBeanDescriptor valueDescriptor = createDescriptorIfAbsent ( value , accessor , cache ) ; descriptor.setProperty ( entry.getKey ( ) , valueDescriptor ) ; } catch ( Exception e ) { throw new RuntimeException ( e.getMessage ( ) , e ) ; } } } } } } 
private static void deserializeInternal ( Object result , JavaBeanDescriptor beanDescriptor , ClassLoader loader , IdentityHashMap < JavaBeanDescriptor , Object > cache ) { if ( beanDescriptor.isEnumType ( ) || beanDescriptor.isClassType ( ) || beanDescriptor.isPrimitiveType ( ) ) { return ; } if ( beanDescriptor.isArrayType ( ) ) { int index = 0 ; for ( Map.Entry < Object , Object > entry : beanDescriptor ) { Object item = entry.getValue ( ) ; if ( item instanceof JavaBeanDescriptor ) { JavaBeanDescriptor itemDescriptor = ( JavaBeanDescriptor ) entry.getValue ( ) ; item = instantiateForDeserialize ( itemDescriptor , loader , cache ) ; deserializeInternal ( item , itemDescriptor , loader , cache ) ; } Array.set ( result , index++ , item ) ; } } else if ( beanDescriptor.isCollectionType ( ) ) { Collection collection = ( Collection ) result ; for ( Map.Entry < Object , Object > entry : beanDescriptor ) { Object item = entry.getValue ( ) ; if ( item instanceof JavaBeanDescriptor ) { JavaBeanDescriptor itemDescriptor = ( JavaBeanDescriptor ) entry.getValue ( ) ; item = instantiateForDeserialize ( itemDescriptor , loader , cache ) ; deserializeInternal ( item , itemDescriptor , loader , cache ) ; } collection.add ( item ) ; } } else if ( beanDescriptor.isMapType ( ) ) { Map map = ( Map ) result ; for ( Map.Entry < Object , Object > entry : beanDescriptor ) { Object key = entry.getKey ( ) ; Object value = entry.getValue ( ) ; if ( key instanceof JavaBeanDescriptor ) { JavaBeanDescriptor keyDescriptor = ( JavaBeanDescriptor ) entry.getKey ( ) ; key = instantiateForDeserialize ( keyDescriptor , loader , cache ) ; deserializeInternal ( key , keyDescriptor , loader , cache ) ; } if ( value instanceof JavaBeanDescriptor ) { JavaBeanDescriptor valueDescriptor = ( JavaBeanDescriptor ) entry.getValue ( ) ; value = instantiateForDeserialize ( valueDescriptor , loader , cache ) ; deserializeInternal ( value , valueDescriptor , loader , cache ) ; } map.put ( key , value ) ; } } else if ( beanDescriptor.isBeanType ( ) ) { for ( Map.Entry < Object , Object > entry : beanDescriptor ) { String property = entry.getKey ( ) .toString ( ) ; Object value = entry.getValue ( ) ; if ( value == null ) { continue ; } if ( value instanceof JavaBeanDescriptor ) { JavaBeanDescriptor valueDescriptor = ( JavaBeanDescriptor ) entry.getValue ( ) ; value = instantiateForDeserialize ( valueDescriptor , loader , cache ) ; deserializeInternal ( value , valueDescriptor , loader , cache ) ; } Method method = getSetterMethod ( result.getClass ( ) , property , value.getClass ( ) ) ; boolean setByMethod = false ; try { if ( method != null ) { method.invoke ( result , value ) ; setByMethod = true ; } } catch ( Exception e ) { LogHelper.warn ( logger , " Failed to set property through method " + method , e ) ; } if ( !setByMethod ) { try { Field field = result.getClass ( ) .getField ( property ) ; if ( field != null ) { field.set ( result , value ) ; } } catch ( NoSuchFieldException e1 ) { LogHelper.warn ( logger , " Failed to set field value " , e1 ) ; } catch ( IllegalAccessException e1 ) { LogHelper.warn ( logger , " Failed to set field value " , e1 ) ; } } } } else { throw new IllegalArgumentException ( " Unsupported type " + beanDescriptor.getClassName ( ) + " : " + beanDescriptor.getType ( ) ) ; } } 
private static Method getSetterMethod ( Class < ? > cls , String property , Class < ? > valueCls ) { String name = " set " + property.substring ( 0 , 1 ) .toUpperCase ( ) + property.substring ( 1 ) ; Method method = null ; try { method = cls.getMethod ( name , valueCls ) ; } catch ( NoSuchMethodException e ) { for ( Method m : cls.getMethods ( ) ) { if ( ReflectUtils.isBeanPropertyWriteMethod ( m ) && m.getName ( ) .equals ( name ) ) { method = m ; } } } if ( method != null ) { method.setAccessible ( true ) ; } return method ; } 
private static Object instantiate ( Class < ? > cl ) throws Exception { Constructor < ? > [] constructors = cl.getDeclaredConstructors ( ) ; Constructor < ? > constructor = null ; int argc = Integer.MAX_VALUE ; for ( Constructor < ? > c : constructors ) { if ( c.getParameterTypes ( ) .length < argc ) { argc = c.getParameterTypes ( ) .length ; constructor = c ; } } if ( constructor != null ) { Class < ? > [] paramTypes = constructor.getParameterTypes ( ) ; Object[] constructorArgs = new Object[paramTypes.length] ; for ( int i = 0 ; i < constructorArgs.length ; i++ ) { constructorArgs[i] = getConstructorArg ( paramTypes[i] ) ; } try { constructor.setAccessible ( true ) ; return constructor.newInstance ( constructorArgs ) ; } catch ( InstantiationException e ) { LogHelper.warn ( logger , e.getMessage ( ) , e ) ; } catch ( IllegalAccessException e ) { LogHelper.warn ( logger , e.getMessage ( ) , e ) ; } catch ( InvocationTargetException e ) { LogHelper.warn ( logger , e.getMessage ( ) , e ) ; } } return cl.newInstance ( ) ; } 
public static Object getConstructorArg ( Class < ? > cl ) { if ( boolean.class.equals ( cl ) || Boolean.class.equals ( cl ) ) { return Boolean.FALSE ; } else if ( byte.class.equals ( cl ) || Byte.class.equals ( cl ) ) { return Byte.valueOf ( ( byte ) 0 ) ; } else if ( short.class.equals ( cl ) || Short.class.equals ( cl ) ) { return Short.valueOf ( ( short ) 0 ) ; } else if ( int.class.equals ( cl ) || Integer.class.equals ( cl ) ) { return Integer.valueOf ( 0 ) ; } else if ( long.class.equals ( cl ) || Long.class.equals ( cl ) ) { return Long.valueOf ( 0L ) ; } else if ( float.class.equals ( cl ) || Float.class.equals ( cl ) ) { return Float.valueOf ( ( float ) 0 ) ; } else if ( double.class.equals ( cl ) || Double.class.equals ( cl ) ) { return Double.valueOf ( ( double ) 0 ) ; } else if ( char.class.equals ( cl ) || Character.class.equals ( cl ) ) { return new Character ( ( char ) 0 ) ; } else { return null ; } } 
private static Object instantiateForDeserialize ( JavaBeanDescriptor beanDescriptor , ClassLoader loader , IdentityHashMap < JavaBeanDescriptor , Object > cache ) { if ( cache.containsKey ( beanDescriptor ) ) { return cache.get ( beanDescriptor ) ; } Object result = null ; if ( beanDescriptor.isClassType ( ) ) { try { result = name2Class ( loader , beanDescriptor.getClassNameProperty ( ) ) ; return result ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( e.getMessage ( ) , e ) ; } } else if ( beanDescriptor.isEnumType ( ) ) { try { Class < ? > enumType = name2Class ( loader , beanDescriptor.getClassName ( ) ) ; Method method = getEnumValueOfMethod ( enumType ) ; result = method.invoke ( null , enumType , beanDescriptor.getEnumPropertyName ( ) ) ; return result ; } catch ( Exception e ) { throw new RuntimeException ( e.getMessage ( ) , e ) ; } } else if ( beanDescriptor.isPrimitiveType ( ) ) { result = beanDescriptor.getPrimitiveProperty ( ) ; return result ; } else if ( beanDescriptor.isArrayType ( ) ) { Class < ? > componentType ; try { componentType = name2Class ( loader , beanDescriptor.getClassName ( ) ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( e.getMessage ( ) , e ) ; } result = Array.newInstance ( componentType , beanDescriptor.propertySize ( ) ) ; cache.put ( beanDescriptor , result ) ; } else { try { Class < ? > cl = name2Class ( loader , beanDescriptor.getClassName ( ) ) ; result = instantiate ( cl ) ; cache.put ( beanDescriptor , result ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( e.getMessage ( ) , e ) ; } catch ( Exception e ) { throw new RuntimeException ( e.getMessage ( ) , e ) ; } } return result ; } 
public static Class < ? > name2Class ( ClassLoader loader , String name ) throws ClassNotFoundException { if ( TYPES.containsKey ( name ) ) { return TYPES.get ( name ) ; } if ( isArray ( name ) ) { int dimension = 0 ; while ( isArray ( name ) ) { ++dimension ; name = name.substring ( 1 ) ; } Class type = name2Class ( loader , name ) ; int[] dimensions = new int[dimension] ; for ( int i = 0 ; i < dimension ; i++ ) { dimensions[i] = 0 ; } return Array.newInstance ( type , dimensions ) .getClass ( ) ; } if ( isReferenceType ( name ) ) { name = name.substring ( 1 , name.length ( ) - 1 ) ; } return Class.forName ( name , false , loader ) ; } 
private static String modifier ( int mod ) { StringBuilder modifier = new StringBuilder ( ) ; if ( Modifier.isPublic ( mod ) ) { modifier.append ( " public " ) ; } if ( Modifier.isProtected ( mod ) ) { modifier.append ( " protected " ) ; } if ( Modifier.isPrivate ( mod ) ) { modifier.append ( " private " ) ; } if ( Modifier.isStatic ( mod ) ) { modifier.append ( " static " ) ; } if ( Modifier.isVolatile ( mod ) ) { modifier.append ( " volatile " ) ; } return modifier.toString ( ) ; } 
public ClassGenerator addConstructor ( int mod , Class < ? > [] pts , Class < ? > [] ets , String body ) { StringBuilder sb = new StringBuilder ( ) ; sb.append ( modifier ( mod ) ) .append ( ' ' ) .append ( SIMPLE_NAME_TAG ) ; sb.append ( ' ( ' ) ; for ( int i = 0 ; i < pts.length ; i++ ) { if ( i > 0 ) { sb.append ( ' , ' ) ; } sb.append ( ReflectUtils.getName ( pts[i] ) ) ; sb.append ( " arg " ) .append ( i ) ; } sb.append ( ' ) ' ) ; if ( ArrayUtils.isNotEmpty ( ets ) ) { sb.append ( " throws " ) ; for ( int i = 0 ; i < ets.length ; i++ ) { if ( i > 0 ) { sb.append ( ' , ' ) ; } sb.append ( ReflectUtils.getName ( ets[i] ) ) ; } } sb.append ( ' { ' ) .append ( body ) .append ( ' } ' ) ; return addConstructor ( sb.toString ( ) ) ; } 
public Class < ? > toClass ( ClassLoader loader , ProtectionDomain pd ) { if ( mCtc != null ) { mCtc.detach ( ) ; } long id = CLASS_NAME_COUNTER.getAndIncrement ( ) ; try { CtClass ctcs = mSuperClass == null ? null : mPool.get ( mSuperClass ) ; if ( mClassName == null ) { mClassName = ( mSuperClass == null || javassist.Modifier.isPublic ( ctcs.getModifiers ( ) ) ? ClassGenerator.class.getName ( ) : mSuperClass + " $sc " ) + id ; } mCtc = mPool.makeClass ( mClassName ) ; if ( mSuperClass != null ) { mCtc.setSuperclass ( ctcs ) ; } mCtc.addInterface ( mPool.get ( DC.class.getName ( ) ) ) ; if ( mInterfaces != null ) { for ( String cl : mInterfaces ) { mCtc.addInterface ( mPool.get ( cl ) ) ; } } if ( mFields != null ) { for ( String code : mFields ) { mCtc.addField ( CtField.make ( code , mCtc ) ) ; } } if ( mMethods != null ) { for ( String code : mMethods ) { if ( code.charAt ( 0 ) == ':' ) { mCtc.addMethod ( CtNewMethod.copy ( getCtMethod ( mCopyMethods.get ( code.substring ( 1 ) ) ) , code.substring ( 1 , code.indexOf ( ' ( ' ) ) , mCtc , null ) ) ; } else { mCtc.addMethod ( CtNewMethod.make ( code , mCtc ) ) ; } } } if ( mDefaultConstructor ) { mCtc.addConstructor ( CtNewConstructor.defaultConstructor ( mCtc ) ) ; } if ( mConstructors != null ) { for ( String code : mConstructors ) { if ( code.charAt ( 0 ) == ':' ) { mCtc.addConstructor ( CtNewConstructor.copy ( getCtConstructor ( mCopyConstructors.get ( code.substring ( 1 ) ) ) , mCtc , null ) ) ; } else { String[] sn = mCtc.getSimpleName ( ) .split ( " \\$+ " ) ; mCtc.addConstructor ( CtNewConstructor.make ( code.replaceFirst ( SIMPLE_NAME_TAG , sn[sn.length - 1] ) , mCtc ) ) ; } } } return mCtc.toClass ( loader , pd ) ; } catch ( RuntimeException e ) { throw e ; } catch ( NotFoundException e ) { throw new RuntimeException ( e.getMessage ( ) , e ) ; } catch ( CannotCompileException e ) { throw new RuntimeException ( e.getMessage ( ) , e ) ; } } 
public void release ( ) { if ( mCtc != null ) { mCtc.detach ( ) ; } if ( mInterfaces != null ) { mInterfaces.clear ( ) ; } if ( mFields != null ) { mFields.clear ( ) ; } if ( mMethods != null ) { mMethods.clear ( ) ; } if ( mConstructors != null ) { mConstructors.clear ( ) ; } if ( mCopyMethods != null ) { mCopyMethods.clear ( ) ; } if ( mCopyConstructors != null ) { mCopyConstructors.clear ( ) ; } } 
public static Mixin mixin ( Class < ? > [] ics , Class < ? > [] dcs , ClassLoader cl ) { assertInterfaceArray ( ics ) ; long id = MIXIN_CLASS_COUNTER.getAndIncrement ( ) ; String pkg = null ; ClassGenerator ccp = null , ccm = null ; try { ccp = ClassGenerator.newInstance ( cl ) ; StringBuilder code = new StringBuilder ( ) ; for ( int i = 0 ; i < dcs.length ; i++ ) { if ( !Modifier.isPublic ( dcs[i].getModifiers ( ) ) ) { String npkg = dcs[i].getPackage ( ) .getName ( ) ; if ( pkg == null ) { pkg = npkg ; } else { if ( !pkg.equals ( npkg ) ) { throw new IllegalArgumentException ( " non-public interfaces class from different packages " ) ; } } } ccp.addField ( " private " + dcs[i].getName ( ) + " d " + i + " ; " ) ; code.append ( " d " ) .append ( i ) .append ( " = ( " ) .append ( dcs[i].getName ( ) ) .append ( " ) $1[ " ) .append ( i ) .append ( " ] ; \n " ) ; if ( MixinAware.class.isAssignableFrom ( dcs[i] ) ) { code.append ( " d " ) .append ( i ) .append ( " .setMixinInstance ( this ) ; \n " ) ; } } ccp.addConstructor ( Modifier.PUBLIC , new Class < ? > [] { Object[].class } , code.toString ( ) ) ; Set < String > worked = new HashSet < String > ( ) ; for ( int i = 0 ; i < ics.length ; i++ ) { if ( !Modifier.isPublic ( ics[i].getModifiers ( ) ) ) { String npkg = ics[i].getPackage ( ) .getName ( ) ; if ( pkg == null ) { pkg = npkg ; } else { if ( !pkg.equals ( npkg ) ) { throw new IllegalArgumentException ( " non-public delegate class from different packages " ) ; } } } ccp.addInterface ( ics[i] ) ; for ( Method method : ics[i].getMethods ( ) ) { if ( " java.lang.Object " .equals ( method.getDeclaringClass ( ) .getName ( ) ) ) { continue ; } String desc = ReflectUtils.getDesc ( method ) ; if ( worked.contains ( desc ) ) { continue ; } worked.add ( desc ) ; int ix = findMethod ( dcs , desc ) ; if ( ix < 0 ) { throw new RuntimeException ( " Missing method [ " + desc + " ] implement. " ) ; } Class < ? > rt = method.getReturnType ( ) ; String mn = method.getName ( ) ; if ( Void.TYPE.equals ( rt ) ) { ccp.addMethod ( mn , method.getModifiers ( ) , rt , method.getParameterTypes ( ) , method.getExceptionTypes ( ) , " d " + ix + " . " + mn + " ( $$ ) ; " ) ; } else { ccp.addMethod ( mn , method.getModifiers ( ) , rt , method.getParameterTypes ( ) , method.getExceptionTypes ( ) , " return ( $r ) d " + ix + " . " + mn + " ( $$ ) ; " ) ; } } } if ( pkg == null ) { pkg = PACKAGE_NAME ; } String micn = pkg + " .mixin " + id ; ccp.setClassName ( micn ) ; ccp.toClass ( ) ; String fcn = Mixin.class.getName ( ) + id ; ccm = ClassGenerator.newInstance ( cl ) ; ccm.setClassName ( fcn ) ; ccm.addDefaultConstructor ( ) ; ccm.setSuperClass ( Mixin.class.getName ( ) ) ; ccm.addMethod ( " public Object newInstance ( Object[] delegates ) { return new " + micn + " ( $1 ) ; } " ) ; Class < ? > mixin = ccm.toClass ( ) ; return ( Mixin ) mixin.newInstance ( ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw new RuntimeException ( e.getMessage ( ) , e ) ; } finally { if ( ccp != null ) { ccp.release ( ) ; } if ( ccm != null ) { ccm.release ( ) ; } } } 
public static Proxy getProxy ( ClassLoader cl , Class < ? > ... ics ) { if ( ics.length > MAX_PROXY_COUNT ) { throw new IllegalArgumentException ( " interface limit exceeded " ) ; } StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < ics.length ; i++ ) { String itf = ics[i].getName ( ) ; if ( !ics[i].isInterface ( ) ) { throw new RuntimeException ( itf + " is not a interface. " ) ; } Class < ? > tmp = null ; try { tmp = Class.forName ( itf , false , cl ) ; } catch ( ClassNotFoundException e ) { } if ( tmp != ics[i] ) { throw new IllegalArgumentException ( ics[i] + " is not visible from class loader " ) ; } sb.append ( itf ) .append ( ' ; ' ) ; } String key = sb.toString ( ) ; final Map < String , Object > cache ; synchronized ( PROXY_CACHE_MAP ) { cache = PROXY_CACHE_MAP.computeIfAbsent ( cl , k - > new HashMap < > ( ) ) ; } Proxy proxy = null ; synchronized ( cache ) { do { Object value = cache.get ( key ) ; if ( value instanceof Reference < ? > ) { proxy = ( Proxy ) ( ( Reference < ? > ) value ) .get ( ) ; if ( proxy != null ) { return proxy ; } } if ( value == PENDING_GENERATION_MARKER ) { try { cache.wait ( ) ; } catch ( InterruptedException e ) { } } else { cache.put ( key , PENDING_GENERATION_MARKER ) ; break ; } } while ( true ) ; } long id = PROXY_CLASS_COUNTER.getAndIncrement ( ) ; String pkg = null ; ClassGenerator ccp = null , ccm = null ; try { ccp = ClassGenerator.newInstance ( cl ) ; Set < String > worked = new HashSet < > ( ) ; List < Method > methods = new ArrayList < > ( ) ; for ( int i = 0 ; i < ics.length ; i++ ) { if ( !Modifier.isPublic ( ics[i].getModifiers ( ) ) ) { String npkg = ics[i].getPackage ( ) .getName ( ) ; if ( pkg == null ) { pkg = npkg ; } else { if ( !pkg.equals ( npkg ) ) { throw new IllegalArgumentException ( " non-public interfaces from different packages " ) ; } } } ccp.addInterface ( ics[i] ) ; for ( Method method : ics[i].getMethods ( ) ) { String desc = ReflectUtils.getDesc ( method ) ; if ( worked.contains ( desc ) ) { continue ; } worked.add ( desc ) ; int ix = methods.size ( ) ; Class < ? > rt = method.getReturnType ( ) ; Class < ? > [] pts = method.getParameterTypes ( ) ; StringBuilder code = new StringBuilder ( " Object[] args = new Object[ " ) .append ( pts.length ) .append ( " ] ; " ) ; for ( int j = 0 ; j < pts.length ; j++ ) { code.append ( " args[ " ) .append ( j ) .append ( " ] = ( $w ) $ " ) .append ( j + 1 ) .append ( " ; " ) ; } code.append ( " Object ret = handler.invoke ( this , methods[ " ) .append ( ix ) .append ( " ] , args ) ; " ) ; if ( !Void.TYPE.equals ( rt ) ) { code.append ( " return " ) .append ( asArgument ( rt , " ret " ) ) .append ( " ; " ) ; } methods.add ( method ) ; ccp.addMethod ( method.getName ( ) , method.getModifiers ( ) , rt , pts , method.getExceptionTypes ( ) , code.toString ( ) ) ; } } if ( pkg == null ) { pkg = PACKAGE_NAME ; } String pcn = pkg + " .proxy " + id ; ccp.setClassName ( pcn ) ; ccp.addField ( " public static java.lang.reflect.Method[] methods ; " ) ; ccp.addField ( " private " + InvocationHandler.class.getName ( ) + " handler ; " ) ; ccp.addConstructor ( Modifier.PUBLIC , new Class < ? > [] { InvocationHandler.class } , new Class < ? > [0] , " handler=$1 ; " ) ; ccp.addDefaultConstructor ( ) ; Class < ? > clazz = ccp.toClass ( ) ; clazz.getField ( " methods " ) .set ( null , methods.toArray ( new Method[0] ) ) ; String fcn = Proxy.class.getName ( ) + id ; ccm = ClassGenerator.newInstance ( cl ) ; ccm.setClassName ( fcn ) ; ccm.addDefaultConstructor ( ) ; ccm.setSuperClass ( Proxy.class ) ; ccm.addMethod ( " public Object newInstance ( " + InvocationHandler.class.getName ( ) + " h ) { return new " + pcn + " ( $1 ) ; } " ) ; Class < ? > pc = ccm.toClass ( ) ; proxy = ( Proxy ) pc.newInstance ( ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw new RuntimeException ( e.getMessage ( ) , e ) ; } finally { if ( ccp != null ) { ccp.release ( ) ; } if ( ccm != null ) { ccm.release ( ) ; } synchronized ( cache ) { if ( proxy == null ) { cache.remove ( key ) ; } else { cache.put ( key , new WeakReference < Proxy > ( proxy ) ) ; } cache.notifyAll ( ) ; } } return proxy ; } 
private static String asArgument ( Class < ? > cl , String name ) { if ( cl.isPrimitive ( ) ) { if ( Boolean.TYPE == cl ) { return name + " ==null?false: ( ( Boolean ) " + name + " ) .booleanValue ( ) " ; } if ( Byte.TYPE == cl ) { return name + " ==null? ( byte ) 0: ( ( Byte ) " + name + " ) .byteValue ( ) " ; } if ( Character.TYPE == cl ) { return name + " ==null? ( char ) 0: ( ( Character ) " + name + " ) .charValue ( ) " ; } if ( Double.TYPE == cl ) { return name + " ==null? ( double ) 0: ( ( Double ) " + name + " ) .doubleValue ( ) " ; } if ( Float.TYPE == cl ) { return name + " ==null? ( float ) 0: ( ( Float ) " + name + " ) .floatValue ( ) " ; } if ( Integer.TYPE == cl ) { return name + " ==null? ( int ) 0: ( ( Integer ) " + name + " ) .intValue ( ) " ; } if ( Long.TYPE == cl ) { return name + " ==null? ( long ) 0: ( ( Long ) " + name + " ) .longValue ( ) " ; } if ( Short.TYPE == cl ) { return name + " ==null? ( short ) 0: ( ( Short ) " + name + " ) .shortValue ( ) " ; } throw new RuntimeException ( name + " is unknown primitive type. " ) ; } return " ( " + ReflectUtils.getName ( cl ) + " ) " + name ; } 
public static Wrapper getWrapper ( Class < ? > c ) { while ( ClassGenerator.isDynamicClass ( c ) ) { c = c.getSuperclass ( ) ; } if ( c == Object.class ) { return OBJECT_WRAPPER ; } Wrapper ret = WRAPPER_MAP.get ( c ) ; if ( ret == null ) { ret = makeWrapper ( c ) ; WRAPPER_MAP.put ( c , ret ) ; } return ret ; } 
private static Wrapper makeWrapper ( Class < ? > c ) { if ( c.isPrimitive ( ) ) { throw new IllegalArgumentException ( " Can not create wrapper for primitive type: " + c ) ; } String name = c.getName ( ) ; ClassLoader cl = ClassUtils.getClassLoader ( c ) ; StringBuilder c1 = new StringBuilder ( " public void setPropertyValue ( Object o , String n , Object v ) { " ) ; StringBuilder c2 = new StringBuilder ( " public Object getPropertyValue ( Object o , String n ) { " ) ; StringBuilder c3 = new StringBuilder ( " public Object invokeMethod ( Object o , String n , Class[] p , Object[] v ) throws " + InvocationTargetException.class.getName ( ) + " { " ) ; c1.append ( name ) .append ( " w ; try { w = ( ( " ) .append ( name ) .append ( " ) $1 ) ; } catch ( Throwable e ) { throw new IllegalArgumentException ( e ) ; } " ) ; c2.append ( name ) .append ( " w ; try { w = ( ( " ) .append ( name ) .append ( " ) $1 ) ; } catch ( Throwable e ) { throw new IllegalArgumentException ( e ) ; } " ) ; c3.append ( name ) .append ( " w ; try { w = ( ( " ) .append ( name ) .append ( " ) $1 ) ; } catch ( Throwable e ) { throw new IllegalArgumentException ( e ) ; } " ) ; Map < String , Class < ? > > pts = new HashMap < > ( ) ; Map < String , Method > ms = new LinkedHashMap < > ( ) ; List < String > mns = new ArrayList < > ( ) ; List < String > dmns = new ArrayList < > ( ) ; for ( Field f : c.getFields ( ) ) { String fn = f.getName ( ) ; Class < ? > ft = f.getType ( ) ; if ( Modifier.isStatic ( f.getModifiers ( ) ) || Modifier.isTransient ( f.getModifiers ( ) ) ) { continue ; } c1.append ( " if ( $2.equals ( \ " " ) .append ( fn ) .append ( " \ " ) ) { w. " ) .append ( fn ) .append ( " = " ) .append ( arg ( ft , " $3 " ) ) .append ( " ; return ; } " ) ; c2.append ( " if ( $2.equals ( \ " " ) .append ( fn ) .append ( " \ " ) ) { return ( $w ) w. " ) .append ( fn ) .append ( " ; } " ) ; pts.put ( fn , ft ) ; } Method[] methods = c.getMethods ( ) ; boolean hasMethod = hasMethods ( methods ) ; if ( hasMethod ) { c3.append ( " try { " ) ; for ( Method m : methods ) { if ( m.getDeclaringClass ( ) == Object.class ) { continue ; } String mn = m.getName ( ) ; c3.append ( " if ( \ " " ) .append ( mn ) .append ( " \ " .equals ( $2 ) " ) ; int len = m.getParameterTypes ( ) .length ; c3.append ( " && " ) .append ( " $3.length == " ) .append ( len ) ; boolean override = false ; for ( Method m2 : methods ) { if ( m != m2 && m.getName ( ) .equals ( m2.getName ( ) ) ) { override = true ; break ; } } if ( override ) { if ( len > 0 ) { for ( int l = 0 ; l < len ; l++ ) { c3.append ( " && " ) .append ( " $3[ " ) .append ( l ) .append ( " ].getName ( ) .equals ( \ " " ) .append ( m.getParameterTypes ( ) [l].getName ( ) ) .append ( " \ " ) " ) ; } } } c3.append ( " ) { " ) ; if ( m.getReturnType ( ) == Void.TYPE ) { c3.append ( " w. " ) .append ( mn ) .append ( ' ( ' ) .append ( args ( m.getParameterTypes ( ) , " $4 " ) ) .append ( " ) ; " ) .append ( " return null ; " ) ; } else { c3.append ( " return ( $w ) w. " ) .append ( mn ) .append ( ' ( ' ) .append ( args ( m.getParameterTypes ( ) , " $4 " ) ) .append ( " ) ; " ) ; } c3.append ( " } " ) ; mns.add ( mn ) ; if ( m.getDeclaringClass ( ) == c ) { dmns.add ( mn ) ; } ms.put ( ReflectUtils.getDesc ( m ) , m ) ; } c3.append ( " } catch ( Throwable e ) { " ) ; c3.append ( " throw new java.lang.reflect.InvocationTargetException ( e ) ; " ) ; c3.append ( " } " ) ; } c3.append ( " throw new " + NoSuchMethodException.class.getName ( ) + " ( \ " Not found method \\\ " \ " +$2+\ " \\\ " in class " + c.getName ( ) + " .\ " ) ; } " ) ; Matcher matcher ; for ( Map.Entry < String , Method > entry : ms.entrySet ( ) ) { String md = entry.getKey ( ) ; Method method = entry.getValue ( ) ; if ( ( matcher = ReflectUtils.GETTER_METHOD_DESC_PATTERN.matcher ( md ) ) .matches ( ) ) { String pn = propertyName ( matcher.group ( 1 ) ) ; c2.append ( " if ( $2.equals ( \ " " ) .append ( pn ) .append ( " \ " ) ) { return ( $w ) w. " ) .append ( method.getName ( ) ) .append ( " ( ) ; } " ) ; pts.put ( pn , method.getReturnType ( ) ) ; } else if ( ( matcher = ReflectUtils.IS_HAS_CAN_METHOD_DESC_PATTERN.matcher ( md ) ) .matches ( ) ) { String pn = propertyName ( matcher.group ( 1 ) ) ; c2.append ( " if ( $2.equals ( \ " " ) .append ( pn ) .append ( " \ " ) ) { return ( $w ) w. " ) .append ( method.getName ( ) ) .append ( " ( ) ; } " ) ; pts.put ( pn , method.getReturnType ( ) ) ; } else if ( ( matcher = ReflectUtils.SETTER_METHOD_DESC_PATTERN.matcher ( md ) ) .matches ( ) ) { Class < ? > pt = method.getParameterTypes ( ) [0] ; String pn = propertyName ( matcher.group ( 1 ) ) ; c1.append ( " if ( $2.equals ( \ " " ) .append ( pn ) .append ( " \ " ) ) { w. " ) .append ( method.getName ( ) ) .append ( " ( " ) .append ( arg ( pt , " $3 " ) ) .append ( " ) ; return ; } " ) ; pts.put ( pn , pt ) ; } } c1.append ( " throw new " + NoSuchPropertyException.class.getName ( ) + " ( \ " Not found property \\\ " \ " +$2+\ " \\\ " field or setter method in class " + c.getName ( ) + " .\ " ) ; } " ) ; c2.append ( " throw new " + NoSuchPropertyException.class.getName ( ) + " ( \ " Not found property \\\ " \ " +$2+\ " \\\ " field or setter method in class " + c.getName ( ) + " .\ " ) ; } " ) ; long id = WRAPPER_CLASS_COUNTER.getAndIncrement ( ) ; ClassGenerator cc = ClassGenerator.newInstance ( cl ) ; cc.setClassName ( ( Modifier.isPublic ( c.getModifiers ( ) ) ? Wrapper.class.getName ( ) : c.getName ( ) + " $sw " ) + id ) ; cc.setSuperClass ( Wrapper.class ) ; cc.addDefaultConstructor ( ) ; cc.addField ( " public static String[] pns ; " ) ; cc.addField ( " public static " + Map.class.getName ( ) + " pts ; " ) ; cc.addField ( " public static String[] mns ; " ) ; cc.addField ( " public static String[] dmns ; " ) ; for ( int i = 0 , len = ms.size ( ) ; i < len ; i++ ) { cc.addField ( " public static Class[] mts " + i + " ; " ) ; } cc.addMethod ( " public String[] getPropertyNames ( ) { return pns ; } " ) ; cc.addMethod ( " public boolean hasProperty ( String n ) { return pts.containsKey ( $1 ) ; } " ) ; cc.addMethod ( " public Class getPropertyType ( String n ) { return ( Class ) pts.get ( $1 ) ; } " ) ; cc.addMethod ( " public String[] getMethodNames ( ) { return mns ; } " ) ; cc.addMethod ( " public String[] getDeclaredMethodNames ( ) { return dmns ; } " ) ; cc.addMethod ( c1.toString ( ) ) ; cc.addMethod ( c2.toString ( ) ) ; cc.addMethod ( c3.toString ( ) ) ; try { Class < ? > wc = cc.toClass ( ) ; wc.getField ( " pts " ) .set ( null , pts ) ; wc.getField ( " pns " ) .set ( null , pts.keySet ( ) .toArray ( new String[0] ) ) ; wc.getField ( " mns " ) .set ( null , mns.toArray ( new String[0] ) ) ; wc.getField ( " dmns " ) .set ( null , dmns.toArray ( new String[0] ) ) ; int ix = 0 ; for ( Method m : ms.values ( ) ) { wc.getField ( " mts " + ix++ ) .set ( null , m.getParameterTypes ( ) ) ; } return ( Wrapper ) wc.newInstance ( ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Throwable e ) { throw new RuntimeException ( e.getMessage ( ) , e ) ; } finally { cc.release ( ) ; ms.clear ( ) ; mns.clear ( ) ; dmns.clear ( ) ; } } 
private static String arg ( Class < ? > cl , String name ) { if ( cl.isPrimitive ( ) ) { if ( cl == Boolean.TYPE ) { return " ( ( Boolean ) " + name + " ) .booleanValue ( ) " ; } if ( cl == Byte.TYPE ) { return " ( ( Byte ) " + name + " ) .byteValue ( ) " ; } if ( cl == Character.TYPE ) { return " ( ( Character ) " + name + " ) .charValue ( ) " ; } if ( cl == Double.TYPE ) { return " ( ( Number ) " + name + " ) .doubleValue ( ) " ; } if ( cl == Float.TYPE ) { return " ( ( Number ) " + name + " ) .floatValue ( ) " ; } if ( cl == Integer.TYPE ) { return " ( ( Number ) " + name + " ) .intValue ( ) " ; } if ( cl == Long.TYPE ) { return " ( ( Number ) " + name + " ) .longValue ( ) " ; } if ( cl == Short.TYPE ) { return " ( ( Number ) " + name + " ) .shortValue ( ) " ; } throw new RuntimeException ( " Unknown primitive type: " + cl.getName ( ) ) ; } return " ( " + ReflectUtils.getName ( cl ) + " ) " + name ; } 
private static String args ( Class < ? > [] cs , String name ) { int len = cs.length ; if ( len == 0 ) { return " " ; } StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < len ; i++ ) { if ( i > 0 ) { sb.append ( ' , ' ) ; } sb.append ( arg ( cs[i] , name + " [ " + i + " ] " ) ) ; } return sb.toString ( ) ; } 
public Class < ? > compile ( String code , ClassLoader classLoader ) { code = code.trim ( ) ; Matcher matcher = PACKAGE_PATTERN.matcher ( code ) ; String pkg ; if ( matcher.find ( ) ) { pkg = matcher.group ( 1 ) ; } else { pkg = " " ; } matcher = CLASS_PATTERN.matcher ( code ) ; String cls ; if ( matcher.find ( ) ) { cls = matcher.group ( 1 ) ; } else { throw new IllegalArgumentException ( " No such class name in " + code ) ; } String className = pkg != null && pkg.length ( ) > 0 ? pkg + " . " + cls : cls ; try { return Class.forName ( className , true , org.apache.dubbo.common.utils.ClassUtils.getCallerClassLoader ( getClass ( ) ) ) ; } catch ( ClassNotFoundException e ) { if ( !code.endsWith ( " } " ) ) { throw new IllegalStateException ( " The java code not endsWith \ " } \ " , code: \n " + code + " \n " ) ; } try { return doCompile ( className , code ) ; } catch ( RuntimeException t ) { throw t ; } catch ( Throwable t ) { throw new IllegalStateException ( " Failed to compile class , cause: " + t.getMessage ( ) + " , class: " + className + " , code: \n " + code + " \n , stack: " + ClassUtils.toString ( t ) ) ; } } } 
public static Class < ? > forName ( String[] packages , String className ) { try { return classForName ( className ) ; } catch ( ClassNotFoundException e ) { if ( packages != null && packages.length > 0 ) { for ( String pkg : packages ) { try { return classForName ( pkg + " . " + className ) ; } catch ( ClassNotFoundException e2 ) { } } } throw new IllegalStateException ( e.getMessage ( ) , e ) ; } } 
public static Class < ? > classForName ( String className ) throws ClassNotFoundException { switch ( className ) { case " boolean " : return boolean.class ; case " byte " : return byte.class ; case " char " : return char.class ; case " short " : return short.class ; case " int " : return int.class ; case " long " : return long.class ; case " float " : return float.class ; case " double " : return double.class ; case " boolean[] " : return boolean[].class ; case " byte[] " : return byte[].class ; case " char[] " : return char[].class ; case " short[] " : return short[].class ; case " int[] " : return int[].class ; case " long[] " : return long[].class ; case " float[] " : return float[].class ; case " double[] " : return double[].class ; default: } try { return arrayForName ( className ) ; } catch ( ClassNotFoundException e ) { if ( className.indexOf ( '.' ) == -1 ) { try { return arrayForName ( " java.lang. " + className ) ; } catch ( ClassNotFoundException e2 ) { } } throw e ; } } 
public static Class < ? > getBoxedClass ( Class < ? > type ) { if ( type == boolean.class ) { return Boolean.class ; } else if ( type == char.class ) { return Character.class ; } else if ( type == byte.class ) { return Byte.class ; } else if ( type == short.class ) { return Short.class ; } else if ( type == int.class ) { return Integer.class ; } else if ( type == long.class ) { return Long.class ; } else if ( type == float.class ) { return Float.class ; } else if ( type == double.class ) { return Double.class ; } else { return type ; } } 
public static Class < ? > getGenericClass ( Class < ? > cls , int i ) { try { ParameterizedType parameterizedType = ( ( ParameterizedType ) cls.getGenericInterfaces ( ) [0] ) ; Object genericClass = parameterizedType.getActualTypeArguments ( ) [i] ; if ( genericClass instanceof ParameterizedType ) { return ( Class < ? > ) ( ( ParameterizedType ) genericClass ) .getRawType ( ) ; } else if ( genericClass instanceof GenericArrayType ) { Type type = ( ( GenericArrayType ) genericClass ) .getGenericComponentType ( ) ; if ( type instanceof TypeVariable ) { return type.getClass ( ) ; } return ( ( ( GenericArrayType ) genericClass ) .getGenericComponentType ( ) instanceof Class < ? > ) ? ( Class < ? > ) ( ( GenericArrayType ) genericClass ) .getGenericComponentType ( ) : ( ( GenericArrayType ) genericClass ) .getGenericComponentType ( ) .getClass ( ) ; } else if ( genericClass != null ) { if ( genericClass instanceof TypeVariable ) { return genericClass.getClass ( ) ; } return ( Class < ? > ) genericClass ; } } catch ( Throwable e ) { } if ( cls.getSuperclass ( ) != null ) { return getGenericClass ( cls.getSuperclass ( ) , i ) ; } else { throw new IllegalArgumentException ( cls.getName ( ) + " generic type undefined! " ) ; } } 
public static String getSizeMethod ( Class < ? > cls ) { try { return cls.getMethod ( " size " , new Class < ? > [0] ) .getName ( ) + " ( ) " ; } catch ( NoSuchMethodException e ) { try { return cls.getMethod ( " length " , new Class < ? > [0] ) .getName ( ) + " ( ) " ; } catch ( NoSuchMethodException e2 ) { try { return cls.getMethod ( " getSize " , new Class < ? > [0] ) .getName ( ) + " ( ) " ; } catch ( NoSuchMethodException e3 ) { try { return cls.getMethod ( " getLength " , new Class < ? > [0] ) .getName ( ) + " ( ) " ; } catch ( NoSuchMethodException e4 ) { return null ; } } } } } 
public static String getMethodName ( Method method , Class < ? > [] parameterClasses , String rightCode ) { if ( method.getParameterTypes ( ) .length > parameterClasses.length ) { Class < ? > [] types = method.getParameterTypes ( ) ; StringBuilder buf = new StringBuilder ( rightCode ) ; for ( int i = parameterClasses.length ; i < types.length ; i++ ) { if ( buf.length ( ) > 0 ) { buf.append ( " , " ) ; } Class < ? > type = types[i] ; String def ; if ( type == boolean.class ) { def = " false " ; } else if ( type == char.class ) { def = " \'\\0\' " ; } else if ( type == byte.class || type == short.class || type == int.class || type == long.class || type == float.class || type == double.class ) { def = " 0 " ; } else { def = " null " ; } buf.append ( def ) ; } } return method.getName ( ) + " ( " + rightCode + " ) " ; } 
public static Method searchMethod ( Class < ? > currentClass , String name , Class < ? > [] parameterTypes ) throws NoSuchMethodException { if ( currentClass == null ) { throw new NoSuchMethodException ( " class == null " ) ; } try { return currentClass.getMethod ( name , parameterTypes ) ; } catch ( NoSuchMethodException e ) { for ( Method method : currentClass.getMethods ( ) ) { if ( method.getName ( ) .equals ( name ) && parameterTypes.length == method.getParameterTypes ( ) .length && Modifier.isPublic ( method.getModifiers ( ) ) ) { if ( parameterTypes.length > 0 ) { Class < ? > [] types = method.getParameterTypes ( ) ; boolean match = true ; for ( int i = 0 ; i < parameterTypes.length ; i++ ) { if ( !types[i].isAssignableFrom ( parameterTypes[i] ) ) { match = false ; break ; } } if ( !match ) { continue ; } } return method ; } } throw e ; } } 
public static String getInitCode ( Class < ? > type ) { if ( byte.class.equals ( type ) || short.class.equals ( type ) || int.class.equals ( type ) || long.class.equals ( type ) || float.class.equals ( type ) || double.class.equals ( type ) ) { return " 0 " ; } else if ( char.class.equals ( type ) ) { return " '\\0' " ; } else if ( boolean.class.equals ( type ) ) { return " false " ; } else { return " null " ; } } 
public CtClass build ( ClassLoader classLoader ) throws NotFoundException , CannotCompileException { ClassPool pool = new ClassPool ( true ) ; pool.appendClassPath ( new LoaderClassPath ( classLoader ) ) ; CtClass ctClass = pool.makeClass ( className , pool.get ( superClassName ) ) ; imports.stream ( ) .forEach ( pool::importPackage ) ; for ( String iface : ifaces ) { ctClass.addInterface ( pool.get ( iface ) ) ; } for ( String constructor : constructors ) { ctClass.addConstructor ( CtNewConstructor.make ( constructor , ctClass ) ) ; } for ( String field : fields ) { ctClass.addField ( CtField.make ( field , ctClass ) ) ; } for ( String method : methods ) { ctClass.addMethod ( CtNewMethod.make ( method , ctClass ) ) ; } return ctClass ; } 
public Class < ? > doCompile ( String name , String source ) throws Throwable { CtClassBuilder builder = new CtClassBuilder ( ) ; builder.setClassName ( name ) ; Matcher matcher = IMPORT_PATTERN.matcher ( source ) ; while ( matcher.find ( ) ) { builder.addImports ( matcher.group ( 1 ) .trim ( ) ) ; } matcher = EXTENDS_PATTERN.matcher ( source ) ; if ( matcher.find ( ) ) { builder.setSuperClassName ( matcher.group ( 1 ) .trim ( ) ) ; } matcher = IMPLEMENTS_PATTERN.matcher ( source ) ; if ( matcher.find ( ) ) { String[] ifaces = matcher.group ( 1 ) .trim ( ) .split ( " \\ , " ) ; Arrays.stream ( ifaces ) .forEach ( i - > builder.addInterface ( i.trim ( ) ) ) ; } String body = source.substring ( source.indexOf ( ' { ' ) + 1 , source.length ( ) - 1 ) ; String[] methods = METHODS_PATTERN.split ( body ) ; String className = ClassUtils.getSimpleClassName ( name ) ; Arrays.stream ( methods ) .map ( String::trim ) .filter ( m - > !m.isEmpty ( ) ) .forEach ( method - > { if ( method.startsWith ( className ) ) { builder.addConstructor ( " public " + method ) ; } else if ( FIELD_PATTERN.matcher ( method ) .matches ( ) ) { builder.addField ( " private " + method ) ; } else { builder.addMethod ( " public " + method ) ; } } ) ; ClassLoader classLoader = org.apache.dubbo.common.utils.ClassUtils.getCallerClassLoader ( getClass ( ) ) ; CtClass cls = builder.build ( classLoader ) ; return cls.toClass ( classLoader , JavassistCompiler.class.getProtectionDomain ( ) ) ; } 
public Class < ? > doCompile ( String name , String sourceCode ) throws Throwable { int i = name.lastIndexOf ( '.' ) ; String packageName = i < 0 ? " " : name.substring ( 0 , i ) ; String className = i < 0 ? name : name.substring ( i + 1 ) ; JavaFileObjectImpl javaFileObject = new JavaFileObjectImpl ( className , sourceCode ) ; javaFileManager.putFileForInput ( StandardLocation.SOURCE_PATH , packageName , className + ClassUtils.JAVA_EXTENSION , javaFileObject ) ; Boolean result = compiler.getTask ( null , javaFileManager , diagnosticCollector , options , null , Arrays.asList ( javaFileObject ) ) .call ( ) ; if ( result == null || !result ) { throw new IllegalStateException ( " Compilation failed. class: " + name + " , diagnostics: " + diagnosticCollector ) ; } return classLoader.loadClass ( name ) ; } 
public JavaFileObject getJavaFileForOutput ( Location location , String qualifiedName , Kind kind , FileObject outputFile ) throws IOException { JavaFileObject file = new JavaFileObjectImpl ( qualifiedName , kind ) ; classLoader.add ( qualifiedName , file ) ; return file ; } 
public Iterable < JavaFileObject > list ( Location location , String packageName , Set < Kind > kinds , boolean recurse ) throws IOException { Iterable < JavaFileObject > result = super.list ( location , packageName , kinds , recurse ) ; ClassLoader contextClassLoader = Thread.currentThread ( ) .getContextClassLoader ( ) ; List < URL > urlList = new ArrayList < URL > ( ) ; Enumeration < URL > e = contextClassLoader.getResources ( " com " ) ; while ( e.hasMoreElements ( ) ) { urlList.add ( e.nextElement ( ) ) ; } ArrayList < JavaFileObject > files = new ArrayList < JavaFileObject > ( ) ; if ( location == StandardLocation.CLASS_PATH && kinds.contains ( JavaFileObject.Kind.CLASS ) ) { for ( JavaFileObject file : fileObjects.values ( ) ) { if ( file.getKind ( ) == Kind.CLASS && file.getName ( ) .startsWith ( packageName ) ) { files.add ( file ) ; } } files.addAll ( classLoader.files ( ) ) ; } else if ( location == StandardLocation.SOURCE_PATH && kinds.contains ( JavaFileObject.Kind.SOURCE ) ) { for ( JavaFileObject file : fileObjects.values ( ) ) { if ( file.getKind ( ) == Kind.SOURCE && file.getName ( ) .startsWith ( packageName ) ) { files.add ( file ) ; } } } for ( JavaFileObject file : result ) { files.add ( file ) ; } return files ; } 
public Object getInternalProperty ( String key ) { Configuration firstMatchingConfiguration = null ; for ( Configuration config : configList ) { try { if ( config.containsKey ( key ) ) { firstMatchingConfiguration = config ; break ; } } catch ( Exception e ) { logger.error ( " Error when trying to get value for key " + key + " from " + config + " , will continue to try the next one. " ) ; } } if ( firstMatchingConfiguration != null ) { return firstMatchingConfiguration.getProperty ( key ) ; } else { return null ; } } 
default < T > T convert ( Class < T > cls , String key , T defaultValue ) { String value = ( String ) getProperty ( key ) ; if ( value == null ) { return defaultValue ; } Object obj = value ; if ( cls.isInstance ( value ) ) { return cls.cast ( value ) ; } if ( Boolean.class.equals ( cls ) || Boolean.TYPE.equals ( cls ) ) { obj = Boolean.valueOf ( value ) ; } else if ( Number.class.isAssignableFrom ( cls ) || cls.isPrimitive ( ) ) { if ( Integer.class.equals ( cls ) || Integer.TYPE.equals ( cls ) ) { obj = Integer.valueOf ( value ) ; } else if ( Long.class.equals ( cls ) || Long.TYPE.equals ( cls ) ) { obj = Long.valueOf ( value ) ; } else if ( Byte.class.equals ( cls ) || Byte.TYPE.equals ( cls ) ) { obj = Byte.valueOf ( value ) ; } else if ( Short.class.equals ( cls ) || Short.TYPE.equals ( cls ) ) { obj = Short.valueOf ( value ) ; } else if ( Float.class.equals ( cls ) || Float.TYPE.equals ( cls ) ) { obj = Float.valueOf ( value ) ; } else if ( Double.class.equals ( cls ) || Double.TYPE.equals ( cls ) ) { obj = Double.valueOf ( value ) ; } } else if ( cls.isEnum ( ) ) { obj = Enum.valueOf ( cls.asSubclass ( Enum.class ) , value ) ; } return cls.cast ( obj ) ; } 
public static int getServerShutdownTimeout ( ) { int timeout = DEFAULT_SERVER_SHUTDOWN_TIMEOUT ; Configuration configuration = Environment.getInstance ( ) .getConfiguration ( ) ; String value = StringUtils.trim ( configuration.getString ( SHUTDOWN_WAIT_KEY ) ) ; if ( value != null && value.length ( ) > 0 ) { try { timeout = Integer.parseInt ( value ) ; } catch ( Exception e ) { } } else { value = StringUtils.trim ( configuration.getString ( SHUTDOWN_WAIT_SECONDS_KEY ) ) ; if ( value != null && value.length ( ) > 0 ) { try { timeout = Integer.parseInt ( value ) * 1000 ; } catch ( Exception e ) { } } } return timeout ; } 
public String generate ( ) { if ( !hasAdaptiveMethod ( ) ) { throw new IllegalStateException ( " No adaptive method exist on extension " + type.getName ( ) + " , refuse to create the adaptive class! " ) ; } StringBuilder code = new StringBuilder ( ) ; code.append ( generatePackageInfo ( ) ) ; code.append ( generateImports ( ) ) ; code.append ( generateClassDeclaration ( ) ) ; Method[] methods = type.getMethods ( ) ; for ( Method method : methods ) { code.append ( generateMethod ( method ) ) ; } code.append ( " } " ) ; if ( logger.isDebugEnabled ( ) ) { logger.debug ( code.toString ( ) ) ; } return code.toString ( ) ; } 
private String generateMethodContent ( Method method ) { Adaptive adaptiveAnnotation = method.getAnnotation ( Adaptive.class ) ; StringBuilder code = new StringBuilder ( 512 ) ; if ( adaptiveAnnotation == null ) { return generateUnsupported ( method ) ; } else { int urlTypeIndex = getUrlTypeIndex ( method ) ; if ( urlTypeIndex != -1 ) { code.append ( generateUrlNullCheck ( urlTypeIndex ) ) ; } else { code.append ( generateUrlAssignmentIndirectly ( method ) ) ; } String[] value = getMethodAdaptiveValue ( adaptiveAnnotation ) ; boolean hasInvocation = hasInvocationArgument ( method ) ; code.append ( generateInvocationArgumentNullCheck ( method ) ) ; code.append ( generateExtNameAssignment ( value , hasInvocation ) ) ; code.append ( generateExtNameNullCheck ( value ) ) ; code.append ( generateExtensionAssignment ( ) ) ; code.append ( generateReturnAndInvocation ( method ) ) ; } return code.toString ( ) ; } 
private String generateExtNameAssignment ( String[] value , boolean hasInvocation ) { String getNameCode = null ; for ( int i = value.length - 1 ; i > = 0 ; --i ) { if ( i == value.length - 1 ) { if ( null != defaultExtName ) { if ( ! " protocol " .equals ( value[i] ) ) { if ( hasInvocation ) { getNameCode = String.format ( " url.getMethodParameter ( methodName , \ " %s\ " , \ " %s\ " ) " , value[i] , defaultExtName ) ; } else { getNameCode = String.format ( " url.getParameter ( \ " %s\ " , \ " %s\ " ) " , value[i] , defaultExtName ) ; } } else { getNameCode = String.format ( " ( url.getProtocol ( ) == null ? \ " %s\ " : url.getProtocol ( ) ) " , defaultExtName ) ; } } else { if ( ! " protocol " .equals ( value[i] ) ) { if ( hasInvocation ) { getNameCode = String.format ( " url.getMethodParameter ( methodName , \ " %s\ " , \ " %s\ " ) " , value[i] , defaultExtName ) ; } else { getNameCode = String.format ( " url.getParameter ( \ " %s\ " ) " , value[i] ) ; } } else { getNameCode = " url.getProtocol ( ) " ; } } } else { if ( ! " protocol " .equals ( value[i] ) ) { if ( hasInvocation ) { getNameCode = String.format ( " url.getMethodParameter ( methodName , \ " %s\ " , \ " %s\ " ) " , value[i] , defaultExtName ) ; } else { getNameCode = String.format ( " url.getParameter ( \ " %s\ " , %s ) " , value[i] , getNameCode ) ; } } else { getNameCode = String.format ( " url.getProtocol ( ) == null ? ( %s ) : url.getProtocol ( ) " , getNameCode ) ; } } } return String.format ( CODE_EXT_NAME_ASSIGNMENT , getNameCode ) ; } 
public static < T > ExtensionLoader < T > getExtensionLoader ( Class < T > type ) { if ( type == null ) { throw new IllegalArgumentException ( " Extension type == null " ) ; } if ( !type.isInterface ( ) ) { throw new IllegalArgumentException ( " Extension type ( " + type + " ) is not an interface! " ) ; } if ( !withExtensionAnnotation ( type ) ) { throw new IllegalArgumentException ( " Extension type ( " + type + " ) is not an extension , because it is NOT annotated with @ " + SPI.class.getSimpleName ( ) + " ! " ) ; } ExtensionLoader < T > loader = ( ExtensionLoader < T > ) EXTENSION_LOADERS.get ( type ) ; if ( loader == null ) { EXTENSION_LOADERS.putIfAbsent ( type , new ExtensionLoader < T > ( type ) ) ; loader = ( ExtensionLoader < T > ) EXTENSION_LOADERS.get ( type ) ; } return loader ; }